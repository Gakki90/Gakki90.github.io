<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>经典面试题汇总</title>
      <link href="/2019/09/21/%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2019/09/21/%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="1-在浏览器地址栏输入URL，按下回车后究竟发生了什么？"><a href="#1-在浏览器地址栏输入URL，按下回车后究竟发生了什么？" class="headerlink" title="1. 在浏览器地址栏输入URL，按下回车后究竟发生了什么？"></a>1. 在浏览器地址栏输入URL，按下回车后究竟发生了什么？</h2><ol><li>查询ip地址：首先浏览器解析出url中的域名，然后去看浏览器有无DNS缓存，因为DNS协议将域名解析为ip地址，没有就去本地客户端中（hosts文件）查找，再没有就去DNS服务器上找，使用递归查询。</li><li>tcp与http连接：先tcp经过三次握手建立链接后然后http在tcp基础上建立连接</li><li>html渲染</li></ol><p>优化方法：</p><ol><li>减少dns查询：保存服务器域名的ip信息</li><li>减少http请求数量。<br>## </li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO复用,AIO,BIO,NIO,同步，异步，阻塞和非阻塞 区别</title>
      <link href="/2019/09/18/java-NIO%E4%B8%8EIO%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/09/18/java-NIO%E4%B8%8EIO%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是AIO，BIO-NIO"><a href="#1-什么是AIO，BIO-NIO" class="headerlink" title="1. 什么是AIO，BIO,NIO"></a>1. 什么是AIO，BIO,NIO</h2><p>AIO:异步非阻塞IO<br>BIO：阻塞IO<br>NIO：非阻塞io</p><h2 id="2-同步与异步，阻塞与非阻塞"><a href="#2-同步与异步，阻塞与非阻塞" class="headerlink" title="2. 同步与异步，阻塞与非阻塞"></a>2. 同步与异步，阻塞与非阻塞</h2><p>同步与异步对针对应用程序与内核的交互而言的：<br>同步：进程触发IO操作并等待或者轮询的查看IO操作是否完成都是同步的<br>异步：进程触发IO操作，直接返回，IO交给内核处理，内核处理完后通知进程IO完成</p><p>阻塞与非阻塞是针对应用程序的执行状态而言的：<br>同步可以是阻塞和非阻塞的，而异步就一定是非阻塞的<br>阻塞：进程给cpu传达一个任务，直到任务完成，进程才继续执行下一个任务<br>非阻塞：进程给cpu传达一个任务，然后继续处理下一个任务，然后通过轮询的方式去查看cpu之前的任务是否完成。</p><h2 id="3-四种高性能IO模型"><a href="#3-四种高性能IO模型" class="headerlink" title="3. 四种高性能IO模型"></a>3. 四种高性能IO模型</h2><ol><li>同步阻塞IO：最简单的io模型，用户线程在内核进行io操作时阻塞</li><li>同步非阻塞IO ：用户线程发起io请求立即返回，并不断发起io请求，知道数据到达后，才真正读取到数据，继续执行，轮询消耗了cpu大量资源，一般很少用</li><li>IO多路复用：IO多路复用模型是建立在内核提供的多路分离函数select基础上的，使用select可以避免非阻塞模型中轮询情况<img src="/2019/09/18/java-NIO与IO的区别/1.png">select函数貌似与非阻塞io并无区别，关键在与select函数可以管理多个socket的io请求，达到在同一个线程内同时处理多个io请求的目的，并且select函数允许用户线程只注册自己感兴趣的事件，这里就使用了Reactor模式，<img src="/2019/09/18/java-NIO与IO的区别/2.png">此多路io复用模型也被称为异步阻塞io模型，这里的阻塞是指select函数执行时线程被阻塞，并不是用户线程被阻塞，并不能称为完全的异步</li><li>异步IO：基于Proactor模式，使用内核提供的异步IO api发起read请求，发起后立即返回，然后操作系统开启独立的内核线程去处理IO的操作，由内核去读取数据并放到用户指定的缓冲区，然后通知用户直接调用即可<img src="/2019/09/18/java-NIO与IO的区别/3.png">异步io并不常用，而是使用io多路复用模型去模拟异步IO(将数据写到缓冲区)，java7已经支持异步IO<br>参考自博客<a href="https://www.cnblogs.com/aspirant/p/6877350.html" target="_blank" rel="noopener">https://www.cnblogs.com/aspirant/p/6877350.html</a></li></ol><h2 id="2-IO与NIO的区别"><a href="#2-IO与NIO的区别" class="headerlink" title="2. IO与NIO的区别"></a>2. IO与NIO的区别</h2><ol><li>IO面向流，NIO面向缓冲：IO每次从流中读取多个字节，直至读取到所有字节，不能移动流中的数据，NIO每次将数据读取到一个稍后处理的缓冲区。</li><li>IO阻塞，NIO非阻塞：当一个线程调用read或write，该线程直到读取完数据之前，不能干任何事情：而NIO当目前没有数据可用时，就什么都不获取，转而去做别的事情，而不是保持线程阻塞。</li><li>选择器：NIO的选择器允许一个线程来监视到个通道，注册多个通道使用一个选择器来选择通道：这些通道里已经有可以处理的输入，或者已准备写入的通道。这个选择器，使得一个线程可以很容易来管理多个通道。<br>参考自博客<a href="https://blog.csdn.net/charjay_lin/article/details/81810922" target="_blank" rel="noopener">https://blog.csdn.net/charjay_lin/article/details/81810922</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NIO </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS相关知识</title>
      <link href="/2019/09/14/OS%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/09/14/OS%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-0-虚拟内存"><a href="#1-0-虚拟内存" class="headerlink" title="1.0 虚拟内存"></a>1.0 虚拟内存</h2><h3 id="1-1-局部性原理"><a href="#1-1-局部性原理" class="headerlink" title="1.1 局部性原理"></a>1.1 局部性原理</h3><ul><li>时间局部性：一条指令执行完，那么在不久的将来很有可能再次使用</li><li>空间局部性：某一块内存正在使用，那么在不久的将来它附近的内存很有可能被使用</li></ul><p>基于局部性原理所以我们决定，我们把应用程序代码不全部加载到内存中去，只是加载一小部分，这就是虚拟内存。</p><p>虚拟内存有一张页表，代表虚拟内存到物理内存的映射，还有一个有效位，代表物理内存一帧是否被缓存到内存中</p><h3 id="1-2-虚拟内存置换算法"><a href="#1-2-虚拟内存置换算法" class="headerlink" title="1.2 虚拟内存置换算法"></a>1.2 虚拟内存置换算法</h3><ol><li>最佳置换：在已知道所有页面什么时候被使用的情况下，替换未来时间最长时间不被用到的页面，很难实现。</li><li>LRU（最近最少使用的页面）：替换到现在为止最长时间没用到的页面</li><li>FIFO：先替换最先来的</li><li>二级机会算法：时钟算法。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见设计模式</title>
      <link href="/2019/09/12/%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/12/%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>属于创建型设计模式，提供了创建对象的最佳方式，定义一个创建对象的接口，让其子类决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。<br>主要解决接口选择问题<br>描述：比如你需要一辆汽车，可以从工厂里面提货，不用去管着辆汽车是怎么做出来的，以及这个汽车里面的具体实现<br>应用场景：1.数据库访问，当用户不知道最后系统采用哪一种数据库，以及数据可能变化时2. 设计连接服务器的框架，三个协议“pop3”，“IMAP”，“HTTP”，让他们共同实现一个接口<br>具体代码参考<a href="https://www.runoob.com/design-pattern/factory-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/factory-pattern.html</a></p><img src="/2019/09/12/常见设计模式/1.jpg"><h3 id="三种工厂模式"><a href="#三种工厂模式" class="headerlink" title="三种工厂模式"></a>三种工厂模式</h3><ol><li>简单工厂：没有抽象，只是对产品的使用和创建进行简单解耦，如果要扩展就需要对代码进行修改</li><li>工厂方法：可以有多个工厂，工厂有共同的接口，但一种工厂只能创造一种产品</li><li>抽象工厂：一个工厂生产一系列的产品，例如神舟厂家生产自家的键盘，鼠标，而惠普厂家生产自家的键盘，鼠标，但神州厂家和惠普厂家都继承同一个抽象工厂类。<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2>代理模式提供对目标对象另外的访问方式，这样做的好处是可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。<img src="/2019/09/12/常见设计模式/1.jpg">代理对象是对目标对象的扩展，并会调用目标对象<br>有三种代理模式<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3>被代理（目标）对象和代理对象要实现相同的接口或者是继承相同的父类<br>优点:可以在不修改目标的前提下对目标功能扩展<br>缺点<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3></li><li>代理对象可以不实现接口，目标对象要实现接口</li><li>代理对象的生成，是利用JDK的API，动态的在内存中构建代理对象</li><li>动态代理又称：JDK代理，接口代理</li></ol><p>代理类所在的包：java.lang.reflect.Proxy<br>使用Proxy的静态方法</p><pre><code>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )</code></pre><p>参数分别代表：类加载器，目标对象实现的接口，时间处理函数</p><h3 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h3><p>目标对象和代理对象都不需要实现接口，而是创建一个目标对象的子类实现代理，又称子类代理。它被广泛应用到许多AOP的框架使用<br>代理的类不能为final，如果目标对象的方法如果为final/static，那么就不会被拦截，不会指向目标对象额外的业务方法。<br>实现方法比较复杂，需要引入spring-core-3.2.5.jar<br>在Spring AOP中，如果加入的容器对象有实现接口，则jDK代理，否则Cglib代理。<br>参考自博客<a href="https://www.cnblogs.com/cenyu/p/6289209.html" target="_blank" rel="noopener">https://www.cnblogs.com/cenyu/p/6289209.html</a></p><h3 id="JDK代理与子类代理的区别"><a href="#JDK代理与子类代理的区别" class="headerlink" title="JDK代理与子类代理的区别"></a>JDK代理与子类代理的区别</h3><ol><li>JDK是实现了被代理对象的接口，而子类代理是继承了被代理对象</li><li>都是在运行期间生产字节码，jdk是直接写class字节码，而子类是用ASM框架写class字节码，所以创建效率低于jdk</li><li>jdk是通过反射实现方法调用，子类是通过fashclass机制（为被代理类和代理类的方法分配index，使用时直接定位到该方法），所以执行效率高于jdk。</li></ol><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><img src="/2019/09/12/常见设计模式/1.png"><p>命令模式主要是实现undo和redo<br>可以两个栈实现：撤回栈和恢复栈。<br>撤回栈主要每次操作后的结果，点击撤回后就弹出撤回栈栈顶元素到恢复栈，点击恢复就弹出恢复栈栈顶元素到撤回栈</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美团后端研发岗面经-第一面</title>
      <link href="/2019/09/07/%E7%BE%8E%E5%9B%A2%E5%90%8E%E7%AB%AF%E7%A0%94%E5%8F%91%E5%B2%97%E9%9D%A2%E7%BB%8F-%E7%AC%AC%E4%B8%80%E9%9D%A2/"/>
      <url>/2019/09/07/%E7%BE%8E%E5%9B%A2%E5%90%8E%E7%AB%AF%E7%A0%94%E5%8F%91%E5%B2%97%E9%9D%A2%E7%BB%8F-%E7%AC%AC%E4%B8%80%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p>本来以为第一面肯定是算法面，结果一上来就是怼项目，然后是基础知识，最后是一道算法。</p><p>首先是自我介绍，接下来就到项目了</p><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>问了我关于项目的架构以及项目的难点亮点，关于我项目的两个难点</p><h3 id="图片回显"><a href="#图片回显" class="headerlink" title="图片回显"></a>图片回显</h3><p>客户端上传图片，然后保存到服务器，生成他的唯一id(hashcode+随机数)，然后回显，然后他说有更好的办法</p><h3 id="数据新增字段"><a href="#数据新增字段" class="headerlink" title="数据新增字段"></a>数据新增字段</h3><p>在数据库新增字段时，先将mapper下的文件删除然后再用mybatis-generator生成一遍，否则会导致项目的崩溃，也有更好的办法<br>在数据库字段中有一个update_time来实现乐观锁机制，逻辑删除</p><h3 id="库存问题"><a href="#库存问题" class="headerlink" title="库存问题"></a>库存问题</h3><p>商品购买中，最重要的是库存机制，一定要记录正确，比如秒杀情况<br>常见的实现方案有5种：</p><ul><li>代码同步，例如synchronized，lock等，有以下缺陷：<ol><li>synchronized的作用范围是jvm实例，如果做了集群，分布式，那就没用了</li><li>synchronized作用在对象实例上，如果不是单个实例，那么不会对多个实例进行同步</li><li>单个jvm中，也不能保证数据库事务的隔离性，具体看下边的的分析<br>spring事务的开启和提交是通过AOP来实现的，在进行方法之前就开启了事务，所以是先开启事务然后获得锁，退出锁然后提交事务，所以在另一个方法执行时，前一个方法又可能刚退出锁未提交时事务。</li></ol></li><li>不查询，直接更新：意思是只要更新后库存大于0，就更新 update table set surplus = (surplus - buyQuantity) where id = 1 and (surplus - buyQuantity) &gt; 0 ;可行，但不具备通用性，只能用于库存大于0的情况</li><li>使用乐观锁（CAS):先取回剩余库存，然后更新库存<pre><code>public void buy(String productName, Integer buyQuantity) {  // 其他校验...  Product product = getByDB(productName);//product为此时的库存  int result = update table set surplus = (surplus - buyQuantity) where id = 1 and surplus = product ;  while (result == 0) {//result等于0更新失败，那就循环更新      product = getByDB(productName);//product为此时的库存      if (product &gt; buyQuantity) {          result = update table set surplus = (surplus - buyQuantity) where id = 1 and surplus = product ;      } else {          return &quot;库存不足&quot;;      }  }</code></pre>这里数据库的隔离级别必须是读已提交，因为如果用可重复读，一个事务如果更新不成功那么每次他读到的库存都是原来的库存，导致程序死循环,这被称之为活锁，乐观锁也就没有了意义。还有一个问题，如果只是取得库存，存在ABA问题（具体可以去看浅谈数据库那一篇文章），所以要增加版本号字段，每次取得版本号字段来代替取库存，然后每次更新完是版本号+1，还要限制失败循环次数。</li><li>悲观锁：在查询语句上增加for update，表级锁，相当于事务串行化，加锁顺序要一致，否知会出现死锁。</li><li>使用分布式：zookeeper，redis，synchornized的同步仅在单个jvm中，而分布式的锁是全局可见的，当然悲观锁也是全局可见的</li></ul><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul><li>数据库引擎及其实现</li><li>linux命令</li><li>写一个shell脚本（完全不会）</li><li>协程<br>  协程：又称微线程，python，go中有协程，协程的效率高于线程，因为线程切换很耗费，线程需要内核来参与管理调度，而协程对内核不可见，可以理解为用户空间线程。</li><li>进程与线程</li><li>TCP首部</li><li>TCP流量控制</li><li>http与https的区别</li></ul><h2 id="java相关"><a href="#java相关" class="headerlink" title="java相关"></a>java相关</h2><ul><li>hashmap，为什么扩容是二的倍数</li><li>hashmap会导致什么样的线程不安全的结果</li><li>JVM</li><li>内存回收与GC</li><li>分布式（不会）<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2>搜索引擎输入词的联想功能怎么实现（字典树）<br>这里介绍下字典树的原理和实现<br>三个基本性质：</li></ul><ol><li>根节点不包含字符，每条边代表一个字符</li><li>根节点到某一节点的路径代表一个字符串</li><li>每个节点包含的子节点都不一样<img src="/2019/09/07/美团后端研发岗面经-第一面/1.jpg">这里还要记录每个词出现的频率，来实现词汇的优先级<pre><code>public class TrieTreeDemo { public static class TrieNode{     int count;     HashMap&lt;Character,TrieNode&gt; children;     TrieNode(){         count=1;         children=new HashMap&lt;&gt;();     } } public void insert(TrieNode node,String word){     char[] chars=word.toCharArray();     for (int i = 0; i &lt;chars.length ; i++) {         if(!node.children.containsKey(chars[i])){             node.children.put(chars[i],new TrieNode());         }else {             node.children.get(chars[i]).count++;         }         node=node.children.get(chars[i]);     } } public int search(TrieNode node ,String word){     char[] chars=word.toCharArray();     for (int i = 0; i &lt;chars.length ; i++) {         if(!node.children.containsKey(chars[i])){             return 0;         }         node=node.children.get(chars[i]);     }     return node.count; }}测试代码：String[] words={&quot;中国&quot;,&quot;美国&quot;,&quot;英国&quot;,&quot;俄罗斯&quot;,&quot;美国&quot;,&quot;中国&quot;,&quot;中国&quot;};     String[] searchWords={&quot;中国&quot;,&quot;日国&quot;};     TrieTreeDemo.TrieNode trieNode=new TrieTreeDemo.TrieNode();     TrieTreeDemo tree=new TrieTreeDemo();     for (String word:words){         tree.insert(trieNode,word);     }     for (String word:searchWords){         int count=tree.search(trieNode,word);         System.out.println(word+&quot;&#39;s count is&quot;+count);     }</code></pre><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2>两个大数相加<br>思路：用字符串表示，注意最高位的进位问题</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java并发编程</title>
      <link href="/2019/09/05/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/09/05/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-锁的种类"><a href="#1-锁的种类" class="headerlink" title="1. 锁的种类"></a>1. 锁的种类</h2><p>jvm的锁大致分为重量级锁，自选锁，轻量级锁，偏向锁<br>锁的使用方式为：先提供偏向锁，如果不满足时，使用轻量级锁，在不瞒足，升级为重量级锁。自旋锁是一种过渡状态，不是实际的锁。锁只能升级。</p><h2 id="2-0-Synchronized原理"><a href="#2-0-Synchronized原理" class="headerlink" title="2.0 Synchronized原理"></a>2.0 Synchronized原理</h2><p>synchronized又被称为内置锁<br>每个对象都有一个监视器锁（monitor），当monitor被占用时就会处于锁定状态，线程执行monitorenter指令尝试获得monitor的所有权，过程如下：</p><ol><li>当monitor的进入数为0，代表空闲，则该线程可以进入，然后将进入数设置为1</li><li>当该线程已经占有monitor，只是重新进入，则进入monitor的进入数加1</li><li>其他线程想要尝试获得该对象，就会被阻塞，知道占有线程调用monitorexit退出，monitor进入数为0.</li></ol><h2 id="3-0-CAS"><a href="#3-0-CAS" class="headerlink" title="3.0 CAS"></a>3.0 CAS</h2><p>compare and switch,用与代替互斥量实现轻量级锁，操作涉及三个操作数：内存位置，预期原值，新值。如果在内存位置的值与预期原值相匹配，那么处理器就会将他更新为新值，否则不会做任何操作。</p><h3 id="3-1-实现原理"><a href="#3-1-实现原理" class="headerlink" title="3.1 实现原理"></a>3.1 实现原理</h3><p>java不能直接访问操作系统底层，通过native(jni)来访问，Unsafe类实现原子性操作</p><h3 id="3-2-存在的问题：ABA"><a href="#3-2-存在的问题：ABA" class="headerlink" title="3.2 存在的问题：ABA"></a>3.2 存在的问题：ABA</h3><p>一个线程占有了一个变量(变量N，值为1），然后第二个线程用CAS同时去操作，第一个线程将N变为2，而此时又有 第三个线程来抢占了，将N变为1，然后第二个线程获取到的N是旧值，虽然与前面相等，但实际的N已经经历了1到2到1的改变。</p><p>解决：给变量加一个版本号</p><h2 id="4-0-ReentrantLock原理（实现了lock接口）"><a href="#4-0-ReentrantLock原理（实现了lock接口）" class="headerlink" title="4.0 ReentrantLock原理（实现了lock接口）"></a>4.0 ReentrantLock原理（实现了lock接口）</h2><p>synchronized与ReentrantLock都是可重入锁（当一个方法得到了锁，那么它里面的方法也同时占有锁)<br>不同点在于ReentrantLock多了三个特性：</p><ol><li>添加了公平锁：当一个线程释放锁，其他被阻塞的线程按序进行获取。</li><li>可添加多个条件，synchronized要么唤醒全部线程，要么唤醒一个线程</li><li>可中断的锁等待，让在等待的线程可以去做别的事情。</li><li>它是一种定时的锁等待（trylock），睡眠时间包括固定和随机部分，从而降低了活锁的可能性。</li><li>非块结构的加锁，比如在遍历散列链时，需要获得下一个节点的锁才能去释放该节点的锁，reentrantlock提供了连锁式加锁或者称为锁耦合。</li></ol><p>Q: 为什么有了ReentrantLock还要内置锁<br>A: 因为内置锁在这些方面优于ReentrantLock</p><ol><li>内置锁是自动释放锁的，reetrantlock需要再finally中释放锁，</li><li>JDK1.5 之前，线程转储上给出的信息只是内置锁的信息，能够检测和识别发生死锁的线程。<h3 id="4-1-AQS"><a href="#4-1-AQS" class="headerlink" title="4.1 AQS"></a>4.1 AQS</h3>AbstractQueuedSynchronized简称AQS，用于构建锁和同步容器的框架，concurrent包里大多都是基于AQS构建，<br>AQS使用FIFO队列表示排队的线程，每个线程维护一个watistatus表示等待状态，AQS中还有一个表示状态的字段state，在ReentrantLock用于表示线程重入锁的次数，在信号量表示剩余的许可数量，在futureTask中用于表示任务的状态。用CAS操作实现线程获得锁的过程</li></ol><h2 id="5-0-实现线程的三种方式"><a href="#5-0-实现线程的三种方式" class="headerlink" title="5.0 实现线程的三种方式"></a>5.0 实现线程的三种方式</h2><ol><li><p>继承Thread类：Thread类本身就实现了Runnable接口，</p><pre><code>public class MyThread extends Thread {  　　public void run() {  　　 System.out.println(&quot;MyThread.run()&quot;);  　　}  }  MyThread myThread1 = new MyThread();  MyThread myThread2 = new MyThread();  myThread1.start();  myThread2.start();</code></pre></li><li><p>实现Runnable接口：继承Thread类因为单继承所以存在局限性。Runnable只有一个方法： </p><pre><code>public class MyThread extends OtherClass implements Runnable {  　　public void run() {  　　 System.out.println(&quot;MyThread.run()&quot;);  　　}  } 启动：MyThread myThread = new MyThread();  Thread thread = new Thread(myThread);  thread.start();  </code></pre></li><li><p>实现Callable接口通过FutureTask包装器来创建线程<br>Callable只有一个接口，但允许有返回值</p><pre><code>public class SomeCallable&lt;V&gt; extends OtherClass implements Callable&lt;V&gt; { @Override public V call() throws Exception {     // TODO Auto-generated method stub     return null; }}启动：Callable&lt;V&gt; oneCallable = new SomeCallable&lt;V&gt;();   //由Callable&lt;Integer&gt;创建一个FutureTask&lt;Integer&gt;对象：   FutureTask&lt;V&gt; oneTask = new FutureTask&lt;V&gt;(oneCallable);   //注释：FutureTask&lt;Integer&gt;是一个包装器，它通过接受Callable&lt;Integer&gt;来创建，它同时实现了Future和Runnable接口。 //由FutureTask&lt;Integer&gt;创建一个Thread对象：   Thread oneThread = new Thread(oneTask);   oneThread.start();   //至此，一个线程就创建完成了。</code></pre></li><li><p>使用ExecutorSerivice，Callable，Future实现有返回结果的线程<br>这三个接口都属于Executor框架，ExecutorSerivice用于创建线程池，Future接受返回值，再用get方法即可得到目的值，get方法是阻塞的，得不到结果就会一直等待，<br>```<br>import java.util.concurrent.<em>;<br>import java.util.Date;<br>import java.util.List;<br>import java.util.ArrayList;<br>/*</em> </p></li></ol><ul><li><p>有返回值的线程 </p></li><li><p>/<br>@SuppressWarnings(“unchecked”)<br>public class Test {<br>public static void main(String[] args) throws ExecutionException,<br>   InterruptedException {<br>  System.out.println(“—-程序开始运行—-“);<br>  Date date1 = new Date();<br>  int taskSize = 5;<br>  // 创建一个线程池<br>  ExecutorService pool = Executors.newFixedThreadPool(taskSize);<br>  // 创建多个有返回值的任务<br>  List<future> list = new ArrayList<future>();<br>  for (int i = 0; i &lt; taskSize; i++) {<br>   Callable c = new MyCallable(i + “ “);<br>   // 执行任务并获取Future对象<br>   Future f = pool.submit(c);<br>   // System.out.println(“&gt;&gt;&gt;” + f.get().toString());<br>   list.add(f);<br>  }<br>  // 关闭线程池<br>  pool.shutdown();  </future></future></p><p>  // 获取所有并发任务的运行结果<br>  for (Future f : list) {<br>   // 从Future对象上获取任务的返回值，并输出到控制台<br>   System.out.println(“&gt;&gt;&gt;” + f.get().toString());<br>  }  </p><p>  Date date2 = new Date();<br>  System.out.println(“—-程序结束运行—-，程序运行时间【”  </p><pre><code>+ (date2.getTime() - date1.getTime()) + &quot;毫秒】&quot;);</code></pre><p>}<br>}  </p></li></ul><p>class MyCallable implements Callable<object> {<br>private String taskNum;<br>MyCallable(String taskNum) {<br>   this.taskNum = taskNum;<br>}<br>public Object call() throws Exception {<br>   System.out.println(“&gt;&gt;&gt;” + taskNum + “任务启动”);<br>   Date dateTmp1 = new Date();<br>   Thread.sleep(1000);<br>   Date dateTmp2 = new Date();<br>   long time = dateTmp2.getTime() - dateTmp1.getTime();<br>   System.out.println(“&gt;&gt;&gt;” + taskNum + “任务终止”);<br>   return taskNum + “任务返回运行结果,当前任务时间【” + time + “毫秒】”;<br>}<br>}</object></p><pre><code>Q: 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？A: 因为我们在调用start后，线程就处于就绪状态，之后就等待分配时间片来运行，如果只是调用run方法，那么还是在原来的主线程运行这个方法。## 6. 线程间的协作线程状态：新建，就绪，运行，阻塞，终止### 6.1 wait/notify/notifyAllwait()：阻塞线程，并让出锁。wait(long timeout)可以设置阻塞时间，0即代表只能通过notify/notifyall方法唤醒，wait方法只能在获取到了monitor对象后使用，因为每个OBject都有monitor对象，所以这三个方法属于Object类，而不是属于thread。### 6.2 sleep/yield/join属于线程的三个方法，* sleep():sleep与wait的区别在与：sleep只是暂停，腾出cpu的使用权，但不会释放锁。* yield()：很少使用，暂停当前线程，以便别的线程可以执行，不能指定时间，也不保证当前线程立即停止。* join():作用是让父进程等待子进程执行完后再执行，将异步的线程转换为同步的，join方法底层就是用wait()方法来实现的。参考博客&lt;https://www.cnblogs.com/paddix/p/5381958.html&gt;### 6.3 守护线程与非守护线程* 守护线程：在程序运行时在后台提供通用服务的进程，比如垃圾回收的线程，不可或缺的线程。## 7.0 线程池三种线程池：1、new SingleThreadExecutor()——创建一个单线程的线程池2、new FixedThreadPool(int n)——创建一个固定大小的线程池3、new CachedThreadPool()——创建一个可缓存的线程池4、new ScheduledThreadPool()——创建一个固定长度的线程池，而且以延迟或定时的方式执行任务。### 7.1 excute与submit区别1. 接收参数不一样，excute()接收runnable类型参数，而submit接收callable类型参数2. excute方法没有返回值，submit方法会放回Future&lt;T&gt;类型返回值3. submit方法适合处理异常，在future.get抛出的异常### 7.2 使用线程池的好处1. 降低资源消耗，频繁的创建线程和销毁线程需要耗费资源2. 提高响应效率，任务到达就可以开始处理3. 提高线程可管理性4. 放置服务器过载### 7.3 线程池中的类与接口{% asset_img 1.png %}### 7.4 三种线程池实现原理三种线程最终都是通过构造不同参数的ThreadPoolExecutor来创建的{% asset_img 2.png %}1. corePoolSize：线程池中维持不会释放的线程数2. maximumPoolSize：池中最大的线程数，超出corePoolSize小于maximumPoolSize会在执行任务后释放3. keepAliveTime，会被释放的线程的缓存时间\4. UNIT 时间单位5. workQueue 缓存异步任务的队列6. threadFactory，用来构造线程池里的worker线程。7. handler 任务队列已满处理策略执行方式：当核心线程数没满时，来了任务直接提交，当满了时，就加入任务队列，当任务队列满了时就继续创建线程。《阿里巴巴java开发手册中》规定不能用Executor默认的静态方法创建线程池，因为默认的线程池maximumPoolSize都是2的31次方，容易导致OOM，必须要用ThreadPoolExecutor设定具体参数。### 7.5 三种任务队列1. SynchronousQueue：直接提交策略适用于CachedThreadPool。，它将任务直接提交给线程而不保持它们。如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。2. LinkedBlockingQueue——无界队列，适用于FixedThreadPool与SingleThreadExcutor。基于链表的阻塞队列，创建的线程数不会超过corePoolSizes（maximumPoolSize值与其一致），当线程正忙时，任务进入队列等待。按照FIFO原则对元素进行排序，吞吐量高于ArrayBlockingQueue。3. ArrayListBlockingQueue——有界队列，有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。newFixedThreadPool和newSingleThreadExcutor默认使用2### 7.6 任务队列已满处理策略ThreadPoolExcutor.AbortPolicy()——终止策略是默认的饱和策略，直接抛出异常，默认操作ThreadPoolExcutor.CallerRunsPolicy()——只用调用者所在线程来运行任务ThreadPoolExcutor.DiscardOldersPolicy()——丢弃队列里最近的一个任务，并执行当前任务ThreadPoolExcutor.DiscardPolicy()——不处理，直接丢掉关于excute()方法，它的执行实际上分了三步：1、当少量的线程在运行，线程的数量还没有达到corePoolSize，那么启用新的线程来执行新任务。2、如果线程数量已经达到了corePoolSize，那么尝试把任务缓存起来，然后再次检查线程池的状态，看这个时候是否能添加一个额外的线程，来执行这个任务。如果这个检查到线程池关闭了，就拒绝任务。3、如果我们没法缓存这个任务，那么我们就尝试去添加线程去执行这个任务，如果失败，可能任务已被取消或者任务队列已经饱和，就拒绝掉这个任务。## 8.0 并发容器类节选自《java并发编程实战》第五章* ReadAndWrite：读-写锁，普通的锁可以避免“读/写”，“写/写”的冲突，但也避免了“读/读”冲突，降低了性能，而读写锁加锁策略中，允许“读/读”的情况发生，可以选择公平还是非公平的读写锁* ConcurrentHashMap:分段锁（segment），他与其他并发容器一起增强了同步容器类：他们提供的迭代器不会抛出ConcurrentModificationException，取而代之的是在改变时new新的数据从而不影响原有的数据 ，iterator完成后再将头指针替换为新的数据，因此不需要再同步过程中对容器加锁，并且具有弱一致性，可以在迭代时容忍并发的修改。Segment继承了ReentrantLock，是一种个可重入锁。&gt; 快速失败策略：util包中。比如list，实现的是fast-failed迭代器，一旦在迭代时另一个线程对集合进行修改，就会抛出上面的异常* CopyOnwriteArraylist:用于替代同步list，它的线程安全性在于每次修改时，都会创建一个新的容器副本，从而实现可变性。* 阻塞队列:上文的任务队列都是阻塞队列，可用于生产者-消费者模式，synchronousQueue，这个队列不会为队列中元素维护存储空间。他维护的是一组线程，仅当有足够多的消费者，并且总是有一个消费者准备好交付工作时，才适合用这个队列* 双端队列与工作密取：Deque和BlockingDeque分别对Queue和BlockingQueue进行了扩展。deque是一个双端队列。工作密取：在前面的模式中消费者共享同一队列，而在工作密取模式中，消费者没个都有自己的双端队列，当它自己的工作完成了，他就会从其他消费者的队列的末尾秘密的获取工作。* 闭锁和栅栏：闭锁：在闭锁到达结束状态前，这扇门是一直关闭的，并且没有任何线程能通过，栅栏：阻塞一组线程知道某个事件发生，栅栏是阻塞线程，而闭锁是阻塞事件。=## 9.0 临界区，互斥量，信号量之间的关系这应该是属于c++范畴，但还是在这里记录一下* 临界区：提供多个线程的串行化来单独访问同一资源或代码，速度快，适合控制数据访问，只能应用在同一程序中。* 互斥量：跟临界区很像，只有拥有互斥对象的线程才能访问资源，但可以实现不同应用程序之间的线程对同一个资源的共享。* 信号量：上面都是单独访问资源，而信号量而允许多个线程一起访问资源，但设有最大访问数量## 10.0 死锁死锁发生的条件：* 占有并等待* 循环并等待* 非抢占* 互斥针对对象之间协作造成的死锁最好的解决方法是使用开放调用：如果在调用某个方法时，不需要锁，那么这种调用就称为开放调用。### 10.1 死锁的避免和诊断考虑获取锁的顺序* 使用定时的锁trylock，当获取锁的时间超过了某个阈值，就返回失败* 通过线程转储信息来分析死锁：线程转储信息包括了各个运行中的线程的栈追踪信息，加锁信息。### 10.2 其他活跃性危险除了死锁，还有以下几点活跃性危险1. 饥饿：死锁和饥饿都是竞争资源引起的，但死锁时同步的，饥饿是异步的，饥饿涉及到的线程只有一个，而死锁有多个。线程优先级调度中低优先级的线程容易发生饥饿2. 糟糕的响应性：一些运行时间较长的任务会影响前台程序的响应，应该降低他们的优先级3. 活锁：这问题尽管不会阻塞线程，也不能继续执行，线程不断执行相同的操作，而且总会失败。## 11.0 ThreadLocal类很多地方叫做线程本地变量，也叫线程本地存储。比如说我们有一个数据连接管理类</code></pre><p>class ConnectionManager {  </p><p> private static Connection connect = null;  </p><p> public static Connection openConnection() {<br> if(connect == null){<br> connect = DriverManager.getConnection();<br> }<br> return connect;<br> }  </p><p> public static void closeConnection() {<br> if(connect!=null)<br> connect.close();<br> }<br>}  </p><pre><code>这段代码不是线程安全的，因为有可能两个线程同时检测到connect为null，或者一个线程正在使用，另一个线程正在关闭。这时候可以用threadlocal类，每个线程的连接互不依赖的，为每一个线程都设置一个独有的数据库连饥饿副本，每个线程可以独立的改变自己的副本，而不会影响其他线程所对应的副本。### 11.1 Threadlocal的方法ThreadLocal有四个方法</code></pre><p>void set(Object value)设置当前线程的线程局部变量的值。<br>public Object get()该方法返回当前线程所对应的线程局部变量。<br>public void remove()将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。<br>protected Object initialValue()返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。</p><pre><code>JDK5.0以后就从Object改成了泛型，简化了ThreadLocal的使用### 11.2 ThreadLocal&lt;T&gt;的具体实现用map的保存线程与变量副本的对应关系</code></pre><p> public void set(T value) {<br>       Thread t = Thread.currentThread();<br>       ThreadLocalMap map = getMap(t);<br>       if (map != null)<br>           map.set(this, value);<br>       else<br>           createMap(t, value);<br>   }<br>```<br>Spring 中session会话也是基于THreadlocal实现的<br>hreadLocal内部的ThreadLocalMap键为弱引用，会有内存泄漏的 风险。适用于无状态，副本变量独立后不影响业务逻辑的高并发场景。如果 如果业务逻辑强依赖于副本变量，则不适合用ThreadLocal解决，需要另寻解决方法。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode算法题</title>
      <link href="/2019/09/02/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>/2019/09/02/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p>思路：空间换时间，用hashmap存储他们的值和下标，遍历一遍</p><pre><code>  public int[] twoSum(int[] nums, int target) {        HashMap&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;();        for (int i = 0; i &lt; nums.length; i++) {            int complement=target-nums[i];            if(map.containsKey(complement)){                return new int[]{map.get(complement),i};            }            map.put(nums[i], i);        }        return new int[0];    }</code></pre><h2 id="2-生产者与消费者"><a href="#2-生产者与消费者" class="headerlink" title="2.生产者与消费者"></a>2.生产者与消费者</h2><pre><code>producer{    while(true){        wait(space)//等待缓冲区有空闲位置        wait(mutex)//获得锁，放置其他线程对缓冲区进行操作        buffer.push(item,in)//将item放置in的位置        in=(in+1)%10        signal(mutex)        signal(items)//通知消费者有可消费空间    }}comsumer{    while(true){        wait(items)        wait(mutex)        buffer.pop(out)        out=(out+1)%10        signal(mutex)        signal(space)    }}</code></pre><h2 id="3-读者-写者"><a href="#3-读者-写者" class="headerlink" title="3.读者-写者"></a>3.读者-写者</h2><p>可以有多个读者，但只能有一个写者,有人读的时候不能写</p><pre><code>writer{    while(true){        wait(wrt)        write()        signal(wrt)    }}reader{    while(true){        wait(mutex)        readcount++        if(readcount==1){            wait（wrt）        }        sinal(mutex)        ···        wait(mutex)        readcount--        if(readcount==0){            signal(wrt)        }        signal(mutex)    }}</code></pre><h2 id="4-最长的回文子串"><a href="#4-最长的回文子串" class="headerlink" title="4.最长的回文子串"></a>4.最长的回文子串</h2><p>题目；给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br>示例：</p><pre><code>输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。</code></pre><p>思路:动态规划，用一个二维boolean数组A[i][j]记录从下标i到j是否是回文串，如果A[i][j]是回文串那么A[i+1][J-1]也是回文串。先单独计算相邻两个字符是否是相等的，也就是计算长度为2的回文串，然后以长度3的滑动窗口去扫描字符串，判断是否是回文串，依次增大滑动窗口的大小，直到=length；</p><pre><code>public String longestPalindrome(String s) {        if(s==null||s.length()==0){            return &quot;&quot;;        }        int length=s.length();        boolean[][] isPalindrome=new boolean[length][length];        char[] chars=s.toCharArray();        int palindromeStart=0;        int palindromeEnd=0;        for (int i = 0; i &lt;length ; i++) {            isPalindrome[i][i]=true;            for (int j = i; j &lt;length-1 ; j++) {                if(chars[j]==chars[j+1]){                    isPalindrome[j][j+1]=true;                    palindromeStart=j;                    palindromeEnd=j+1;                }            }        }        for (int l = 3; l &lt;=length ; l++) {//长度为length结束            for (int start = 0; start+l-1 &lt;length ; start++) {                    int end=start+l-1;                    if(chars[start]==chars[end]&amp;&amp;isPalindrome[start+1][end-1]==true){                        isPalindrome[start][end]=true;                        palindromeStart=start;                        palindromeEnd=end;                    }            }        }        return s.substring(palindromeStart,palindromeEnd+1);    }</code></pre><p>为什么不一起计算：因为当长度为2，即j=i+1，isPalindrome[start+1][end-1]无效，会越过彼此。</p><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组</p><pre><code>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[  [-1, 0, 1],  [-1, -1, 2]]</code></pre><p>思路：重点在与不重复，如何去重，将数组排序，然后从头开始遍历，定义两个指针，指向当前下标的前一个位置和最后面的位置，</p><pre><code>public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {        List&lt;List&lt;Integer&gt;&gt;  lists=new ArrayList&lt;&gt;();        if (nums == null||nums.length==0) {            return lists;        }        Arrays.sort(nums);        int length=nums.length;        if(nums[0]&lt;=0&amp;&amp;nums[length-1]&gt;=0) {//为了包含数组全是0的情况            for (int i = 0; i &lt; length ; i++) {                if(i&gt;0&amp;&amp;nums[i]==nums[i-1]){//从第二位开始去重                    continue;                }                int start = i+1;                int end = length - 1;                while (start &lt; end) {                    int result = nums[start] + nums[end] + nums[i];                    if (result == 0) {                        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();                        list.add(nums[start]);                        list.add(nums[end]);                        list.add(nums[i]);                        lists.add(list);                        while (start &lt; end &amp;&amp; nums[start] == nums[start + 1]) {                            start++;                        }                        while (end &gt; start &amp;&amp; nums[end] == nums[end - 1]) {                            end--;                        }                        start++;                        end--;                    } else if (start &lt; end &amp;&amp; result &lt; 0) {                        start++;                    } else if (end &gt; start &amp;&amp; result &gt; 0) {                        end--;                    }                }            }        }        return lists;    }</code></pre><h2 id="字符串转整数"><a href="#字符串转整数" class="headerlink" title="字符串转整数"></a>字符串转整数</h2><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><pre><code>public int myAtoi(String str) {        str=str.trim();        if (str == null || str.length() == 0) {            return 0;        }        char[] chars=str.toCharArray();        int length=chars.length;        boolean isPositive=true;        int i=0;        if(chars[i]==&#39;-&#39;){            i++;            isPositive=false;        }        if(chars[0]==&#39;+&#39;){            i++;        }        long combine= 0;        for (; i &lt; length; i++) {            int digit=chars[i]-&#39;0&#39;;            if(digit&gt;=0&amp;&amp;digit&lt;=9){                combine*=10;                combine+=digit;                if(isPositive&amp;&amp;combine&gt;Integer.MAX_VALUE){                    return Integer.MAX_VALUE;                }                if(!isPositive&amp;&amp;combine&gt;Integer.MAX_VALUE){                    return -Integer.MIN_VALUE;                }            }else {                break;            }        }        return (int) (isPositive?combine:-combine);    }</code></pre><h2 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16.最接近的三数之和"></a>16.最接近的三数之和</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><p>思路：仍然沿用15题的思路</p><pre><code>public int threeSumClosest(int[] nums, int target) {        if (nums == null||nums.length==0) {            return -1;        }        Arrays.sort(nums);        int length=nums.length;        int ans=nums[0]+nums[1]+nums[2];            for (int i = 0; i &lt; length ; i++) {                if(i&gt;0&amp;&amp;nums[i]==nums[i-1]){                    continue;                }                int start = i+1;                int end = length - 1;                while (start &lt; end) {                     int result = nums[start] + nums[end] + nums[i];                    if (Math.abs(result-target)&lt;Math.abs(ans-target)) {                        ans=result;                    }                    if ( result &lt; target) {                        start++;                    } else if (result &gt; target) {                        end--;                    }else {                        return result;                    }                }            }        return ans;     }}</code></pre><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h2><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><pre><code>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807</code></pre><p>思路：注意看清题目：是逆序，也就说头结点是最小的</p><pre><code>public ListNode addTwoNumbers(ListNode l1, ListNode l2) {        ListNode pNode=new ListNode(0);        ListNode pHead=pNode;        ListNode p=l1;        ListNode q=l2;        int carry=0;        while (p!=null||q!=null){            int x=p!=null?p.val:0;            int y=q!=null?q.val:0;            int sum=x+y+carry;            carry=sum/10;            ListNode pNext=new ListNode(sum%10);            pNode.next=pNext;            pNode=pNode.next;            if(p!=null)                p=p.next;            if(q!=null)                q=q.next;        }        if(carry!=0){            ListNode tail=new ListNode(1);            pNode.next=tail;        }        return pHead.next;      }</code></pre><h2 id="23-合并k个有序链表"><a href="#23-合并k个有序链表" class="headerlink" title="23.合并k个有序链表"></a>23.合并k个有序链表</h2><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。<br>思路：用最小堆，将每个链表的头结点加入进去，每次取出最小值</p><pre><code> public ListNode mergeKLists(ListNode[] lists) {       if(lists==null||lists.length==0){           return null;       }        PriorityQueue&lt;ListNode&gt; heap = new PriorityQueue&lt;&gt;(Comparator.comparingInt(ListNode-&gt;ListNode.val));//构造int比较器        int length = lists.length;        for (int i = 0; i &lt; length; i++) {            if(lists[i]!=null){            heap.offer(lists[i]);            }        }        ListNode pCurrent = new ListNode(0);        ListNode pHead = pCurrent;        while (!heap.isEmpty()) {            ListNode pNode = heap.poll();            pCurrent.next = pNode;            pCurrent = pCurrent.next;            if (pNode.next != null) {                heap.offer(pNode.next);            }        }        return pHead.next;    }</code></pre><h2 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61.旋转链表"></a>61.旋转链表</h2><p>题目：给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/rotate-list著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</code></pre><p>思路：先将链表连成环，然后新的头结点就在n-k处，n是链表的节点个数，k指的是对n求余。</p><pre><code> public ListNode rotateRight(ListNode head, int k) {        if (head == null || k &lt; 0) {            return null;        }        //convert to circle        ListNode pHead = head;        ListNode pNode = head;        int countOfNode = 1;        while (pNode.next != null) {            countOfNode++;            pNode = pNode.next;        }        pNode.next = pHead;        int index = countOfNode - (k % countOfNode);        for (int i = 0; i &lt; index; i++) {            pNode = pNode.next;        }        ListNode newHead = pNode.next;        pNode.next = null;        return newHead;    }</code></pre><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h2><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>也就是求构成的最大面积<br>思路：暴力法复杂度为O（n），可采用双指针（l，r），首先指向数组的头尾，比较height[l]height[r]的长度，我们知道移动长的那条是不会影响矩形面积的，应该说不会增大，所以每次移动短的那根。</p><pre><code>public int maxArea(int[] height) {        if(height==null||height.length&lt;2){            return 0;        }        int length=height.length;        int l=0;        int r=length-1;        int max=0;        while (l&lt;r){            max=Math.max(max,(r-l)*Math.min(height[r],height[l]));            if(height[r]&gt;height[l]){                l++;            }else {                r--;            }        }        return max;    }</code></pre><h2 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43.字符串相乘"></a>43.字符串相乘</h2><p>题目：给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式</p><p>思路：示例</p><pre><code>num1=&quot;24&quot; num2=&quot;48&quot;那么就等于        32   +   16   +  16   +  8    =  9792当num1的下标为i，num2的小标为j，那么想乘后的数字在新的数组的位置就是i+j和i+j+1，注意i+j+1是低位，然后每次得到的乘积加上之前乘积的高位就是新的乘积，对他进行高位低位分配，因为两个一位数相乘最多只有两位</code></pre><pre><code>public String multiply(String num1, String num2) {        if(num1==null||num2==null||num1.length()==0||num2.length()==0){            return &quot;&quot;;        }        if(num1.equals(&quot;0&quot;)||num2.equals(&quot;0&quot;)){            return &quot;0&quot;;        }        int length1=num1.length();        int length2=num2.length();        char[] str=new char[length1+length2];        for (int i = 0; i &lt; length1+length2; i++){            str[i]=&#39;0&#39;;//如果不赋值为‘0’，那么它就是ASCALL里的0，为‘’空值        }        char[] chars1=num1.toCharArray();        char[] chars2=num2.toCharArray();        for (int i = length1-1; i &gt;=0 ; i--) {//下标大的为低位            for (int j = length2-1; j &gt;=0 ; j--) {                int mul=(chars1[i]-&#39;0&#39;)*(chars2[j]-&#39;0&#39;);                int p1=i+j;int p2=i+j+1;int sum=mul+(str[p2]-&#39;0&#39;);//加上低位原来的数                str[p2]= (char) (sum%10+&#39;0&#39;);                str[p1]+= sum/10;//这里就不用加‘0’了            }        }        int i=0;        for (; i &lt;length1+length2 ; i++) {            if(str[i]!=&#39;0&#39;){                break;            }        }        return String.valueOf(str,i,length2+length1-i);    }</code></pre><h2 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h2><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p><p>说明:</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p><p>思路:这题主要是在不要大意，题目简单，但考虑的因素有点多<br>从尾部开始判断两个数组的数字大小，由于是存放在nums1中，所以当n=0，即可break，而当m=0,那么就把nums2中的元素全部转移到nums1中。</p><pre><code>public void merge(int[] nums1, int m, int[] nums2, int n) {        if(m&lt;=0&amp;&amp;n&lt;=0){            return;        }        int length=nums1.length;        for (int i = length-1; i &gt;=0 ; i--) {            if(n==0){                break;            }             if(m==0){                nums1[i]=nums2[n-1];                n--;            }            else if(nums1[m-1]&gt;nums2[n-1]){                nums1[i]=nums1[m-1];                m--;            }else {                nums1[i]=nums2[n-1];                n--;            }        }    }</code></pre><h2 id="算法题从控制台输入多个字符串接收"><a href="#算法题从控制台输入多个字符串接收" class="headerlink" title="算法题从控制台输入多个字符串接收"></a>算法题从控制台输入多个字符串接收</h2><p>平时都是做leetcode上的题，没怎么去了解从控制台输入。<br>当时题的输入是这样的：</p><pre><code>4str1str2str3str42str5str6</code></pre><p>将前四个字符串放到一个list中，将后两个字符串放入另一个list中</p><pre><code>try {            String line = null;            boolean flag=true;            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));            int count=Integer.valueOf(br.readLine());            while ((line = br.readLine()) != null) {                if (line.equalsIgnoreCase(&quot;&quot;)) {                    break;                } else {                    if(count&gt;0){                        str1.add(line);                        count--;                    }else if(count==0) {                        count--;                    }else {                        str2.add(line);                    }                }            }        } catch (Exception e) {            e.printStackTrace();        }</code></pre><pre><code>输入：int[] a={1,2,3,4,5},int[] b={23,42,33,5},int c=3;</code></pre><p>输入一个java语句，提取其中的数字</p><pre><code>boolean flag=true;            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));            String line=br.readLine();            char[] chars=line.toCharArray();            int start=0;            int length=chars.length;            for (int i = 0; i &lt;length ; i++) {                if(chars[i]-&#39;0&#39;&gt;=0&amp;&amp;chars[i]-&#39;0&#39;&lt;=9){                    if(chars[i-1]-&#39;0&#39;&gt;9||chars[i-1]-&#39;0&#39;&lt;0){                        start=i;                    }                    if(chars[i+1]-&#39;0&#39;&gt;9||chars[i+1]-&#39;0&#39;&lt;0){                        arrlist.add(Integer.valueOf(line.substring(start,i+1)));                    }                }            }            for (int n:arrlist){                System.out.println(n);            }        } catch (Exception e) {            e.printStackTrace();        }</code></pre><p>sc.nextInt 会将光标停留在本行，当按下回车会导致空字符传入到sc.nextLine(),这时候用加一句sc.nextLine()就可以避免空字符传入到下一个sc.nextLine().</p><h2 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a>9.回文数</h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。负数不是回文数</p><p>思路：官方解法：比如123321，翻转一半的数字，变成123和123，然后判读两数是否相等，如果12321，两数变成12，和123，则判断x==reverseNum/10；</p><pre><code> public boolean isPalindrome(int x) {        if(x&lt;0||(x%10==0&amp;&amp;x!=0)){            return false;        }        int reverseNum=0;        while (reverseNum&lt;x){            reverseNum=reverseNum*10+x%10;            x/=10;        }        return x==reverseNum||x==reverseNum/10;    }</code></pre><h2 id="2的幂"><a href="#2的幂" class="headerlink" title="2的幂"></a>2的幂</h2><p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。<br>2的负数次方不算2的幂次方<br>思路：通过n和n-1相与</p><pre><code>public boolean isPowerOfTwo(int n) {        if(n==0){            return false;        }        return n&gt;0&amp;&amp;(n&amp;(n-1))==0;    }</code></pre><h2 id="147-排序链表"><a href="#147-排序链表" class="headerlink" title="147.排序链表"></a>147.排序链表</h2><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><p>思路：归并排序，找出中间节点，然后划分，然后对两边的数字进行排序。<br>快慢指针可以找出中间节点：我的理解：不从链表的第一个节点开始，而是从链表外看，慢指针第一次跳一格，那么就落在第一个节点，快指针一次跳两格，那么就跳在第二个节点，那么进行n次，那么慢指针落在n处，快指针落在2n步</p><pre><code> public ListNode sortList(ListNode head) {            if(head==null||head.next==null){                return head;            }            ListNode slow=head;            ListNode fast=head.next;            while (fast!=null&amp;&amp;fast.next!=null){                slow=slow.next;                fast=fast.next;                if(fast!=null){                    fast=fast.next;                }            }           ListNode right=sortList(slow.next);            slow.next=null;//拆分成两段            ListNode left=sortList(head);            ListNode p=new ListNode(0);            ListNode newHead=p;            while (left!=null&amp;&amp;right!=null){                if(left.val&lt;right.val){                    p.next=left;                    left=left.next;                }else {                    p.next=right;                    right=right.next;                }                p=p.next;            }            p.next=(left==null?right:left);            return newHead.next;    }</code></pre><h2 id="33-搜索旋转数组"><a href="#33-搜索旋转数组" class="headerlink" title="33.搜索旋转数组"></a>33.搜索旋转数组</h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>思路：<br>往后规约有两种情况：</p><ol><li>nums[start]&lt;nums[mid],说明前面部分是升序的，那么如果target&gt;nums[mid]或者&lt;nums[start]。那么就往后规约</li><li>nums[start]&gt;nums[mid],说明后面部分是升序的，那么如果target&gt;nums[mid]并且&lt;nums[start]。那么就往后规约</li><li>其他情况往前规约<pre><code>public int search(int[] nums, int target) {     if(nums==null||nums.length==0){         return -1;     }     int start=0;     int length=nums.length;     int end=nums.length;     while (start&lt;end){         int mid=(start+end)/2;         if(nums[start]&lt;nums[mid]&amp;&amp;(nums[start]&gt;target||nums[mid]&lt;target)){             start=mid+1;         }else if(target&gt;nums[mid]&amp;&amp;target&lt;nums[start]){             start=mid+1;         }else if(nums[mid]==target){             return mid;         }         else {             end=mid-1;         }     }     return start==end&amp;&amp;start&lt;nums.length&amp;&amp;(nums[start]==target)?start:-1; }</code></pre>本题中还要防止输入两个数的情况，比如[1,3]和0，那么会越过数组边界</li></ol><h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><p>思路：</p><ol><li><p>找到从根节点到p，q的两条路径，然后寻找最后一个相同的节点，复杂度较高，而且需要额外空间</p><pre><code>List&lt;List&lt;TreeNode&gt;&gt; lists = new ArrayList&lt;&gt;(); List&lt;TreeNode&gt; list = new ArrayList&lt;&gt;(); public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {         core(root,p,q);     int length=lists.get(0).size()&lt;lists.get(1).size()?lists.get(0).size():lists.get(1).size();     for (int i = length-1; i &gt;=0 ; i--) {         if(lists.get(0).get(i)==lists.get(1).get(i)){             return lists.get(0).get(i);         }     }     return null; } public void core(TreeNode root, TreeNode p, TreeNode q) {     if (root == null) {         return;     }     list.add(root);     if (root == p || root == q) {         List&lt;TreeNode&gt; path = new ArrayList&lt;&gt;(list);         lists.add(path);     }     core(root.left, p, q);     core(root.right, p, q);     list.remove(list.size() - 1);     return; }</code></pre><h2 id="89-格雷编码"><a href="#89-格雷编码" class="headerlink" title="89.格雷编码"></a>89.格雷编码</h2><p>题目；<br>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p></li></ol><p>给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。</p><pre><code>输入: 2输出: [0,1,3,2]解释:00 - 001 - 111 - 310 - 2</code></pre><p>思路：动态规划，从n-1的数的编码得到n的数的编码，其实就是在n-1的数的基础上在前面加上2的n-1次方，但是要逆序添加进list，</p><pre><code>public List&lt;Integer&gt; grayCode(int n) {        List&lt;Integer&gt; list=new ArrayList&lt;&gt;();        list.add(0);        for (int i = 0; i &lt;n ; i++) {            int add=1&lt;&lt;i;            for (int j = list.size()-1; j &gt;=0 ; j--) {                list.add(list.get(j)+add);            }        }        return list;    }</code></pre><h2 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125.验证回文串"></a>125.验证回文串</h2><p>题目：给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p>说明：本题中，我们将空字符串定义为有效的回文串。</p><p>思路：先将字符串进行字符筛选，然后再判断是否是字符串</p><pre><code> public boolean isPalindrome(String s) {        if(s==null||s.length()==0){            return true;    }        s=s.toLowerCase();        char[] ca=s.toCharArray();        int index=0;        for (int i = 0; i &lt;ca.length ; i++) {                if((ca[i]&gt;=&#39;a&#39;&amp;&amp;ca[i]&lt;=&#39;z&#39;)||(ca[i]&gt;=&#39;0&#39;&amp;&amp;ca[i]&lt;=&#39;9&#39;)){                    ca[index++]=ca[i];                }        }        int start=0;        while (start&lt;index-1){            if(ca[start]!=ca[index-1]){                return false;            }            start++;            index--;        }        return true;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP协议总结</title>
      <link href="/2019/09/01/TCP-IP%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2019/09/01/TCP-IP%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>因为之前有一篇图解http总结，这里直接从运输层开始，主要是对以前tcp/ip学过的总结。</p><h2 id="1-0-运输层"><a href="#1-0-运输层" class="headerlink" title="1.0 运输层"></a>1.0 运输层</h2><h3 id="1-1-多路复用与多路分解"><a href="#1-1-多路复用与多路分解" class="headerlink" title="1.1 多路复用与多路分解"></a>1.1 多路复用与多路分解</h3><ul><li>多路分解：从运输层报文段中的数据交付到正确的套接字的工作</li><li>多路复用：从主机的不同套接字收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后传递到网络层。</li></ul><p>UDP套接字由一个二元组来全面标识，包含一个目的端口号和一个目的ip地址，所以不同的源ip地址或源端口号，如果他们udp套接字相同，将会通过相同的套接字定向到相同的目的进程。<br>而TCP套接字支持并行，也就是可以有两个相同套接字一起工作，TCP套接字由一个四元组标识，包含目的端口号，源端口号，目的ip地址，源ip地址，所以不同的源ip地址或源端口号就算他们的目的端口号，目的ip地址相同，也会被分解到不同的套接字。</p><h3 id="1-2-UDP"><a href="#1-2-UDP" class="headerlink" title="1.2 UDP"></a>1.2 UDP</h3><p>特性</p><ul><li>无需建立连接：在发送报文段之前，双方不会“握手”。udp也不会维护连接状态，不需要像tcp一样维护接受和发送的缓存，拥塞控制参数等</li><li>实时性较强，tcp由于其拥塞控制而较弱</li><li>分组首部开销小</li><li>面向数据包的不可靠连接</li></ul><p>DNS（域名系统）就是udp的一个例子。</p><h4 id="1-2-1-UDP报文段"><a href="#1-2-1-UDP报文段" class="headerlink" title="1.2.1 UDP报文段"></a>1.2.1 UDP报文段</h4><img src="/2019/09/01/TCP-IP协议总结/1.jpg"><p>四个字段每个都只占两个字节</p><ul><li>长度：用来指示udp报文段中的字节数（首部加数据）</li><li>检验和：提供了差错检测功能，对报文段中所有的16比特字的和进行反码运算，求和时任何溢出都要被回卷（将最高位溢出的1加到最低位上），得到的值就是检验和的值。</li></ul><h3 id="1-3-可靠数据传输原理"><a href="#1-3-可靠数据传输原理" class="headerlink" title="1.3 可靠数据传输原理"></a>1.3 可靠数据传输原理</h3><p>可靠数据传输协议往往建立在不可靠的ip网络层协议上。<br>可靠传输需要的技术（rdt3.0）：</p><ol><li>检验和</li><li>序号</li><li>定时器：用于实现重传机制</li><li>肯定和否定确认</li><li>滑动窗口协议</li><li>选择重传</li></ol><p>rdt3.0 协议的最大缺陷是他是一个停等协议，他必须等待确认信号后才能发送下一个分组。但会带来下列问题:</p><ol><li>必须增加序号范围，每个分组要具有唯一的序号</li><li>协议的发送方和接受方需要缓存多个分组，那么未确认的分组和已接收的分组。</li><li>所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失和损坏及延时过大的分组，有两种方法：<ul><li>回退N步： 允许发送端发送多个分组，当已发送而未被确认的分组数不能大于N个，N是滑动窗口的大小，当等于n时，窗口已满，则会通知上层等下再调用，当某一分组发送后丢失，出现超时，发送方会重传所有已被发送而未被确认的分组，即回退n步。在这里，如果某一分组丢失，则接受端接收后面的分组时发送的ack还是丢失分组前的，这里就是累计确认。<img src="/2019/09/01/TCP-IP协议总结/2.jpg"></li><li>选择重传：GBN协议中许多分组没必要重传， 选择重传机制让发送端只重传那些丢失超时的分组。每个分组都是单独的定时器，用于超时事件。 <img src="/2019/09/01/TCP-IP协议总结/3.jpg"></li></ul></li></ol><h3 id="1-4-TCP"><a href="#1-4-TCP" class="headerlink" title="1.4 TCP"></a>1.4 TCP</h3><ul><li>面向连接：在数据传输前，双方必须握手，即他们必须先发送预备报文段，</li><li>全双工：双方都可以发送和接受报文。</li><li>面向流的可靠连接<br>MSS：最大报文段长度，</li></ul><h4 id="TCP怎么实现有序"><a href="#TCP怎么实现有序" class="headerlink" title="TCP怎么实现有序"></a>TCP怎么实现有序</h4><ol><li>序号</li><li>确认号</li><li>超时机制</li><li>重组：会将无序的报文重组再传递到高层<h4 id="1-4-1-TCP报文段"><a href="#1-4-1-TCP报文段" class="headerlink" title="1.4.1 TCP报文段"></a>1.4.1 TCP报文段</h4></li></ol><img src="/2019/09/01/TCP-IP协议总结/4.jpg"><ol><li>序号和确认号：用于分组标识，序号好理解，而确认号是因为tcp是全双工的，在接收分组同时还是发送分组，所以这时候他就将累计确认的确认号放置于此发送给它的另一方。</li><li>滑动窗口：用于流量控制<h4 id="1-4-2-往返时间估计和超时"><a href="#1-4-2-往返时间估计和超时" class="headerlink" title="1.4.2 往返时间估计和超时"></a>1.4.2 往返时间估计和超时</h4>tcp采用超时/重传机制处理丢失的报文段，但超时间隔长度的设置是个问题。</li></ol><p>EstimatedRTT = (1-a)<em>EstimatedRTT+a</em>SampleRTT，a一般取0.125</p><ul><li>RTT：往返时间</li><li>报文段的样本RTT（SampleRTT）表示从某报文段被发出到接收到确认的时间</li><li>EstimatedRTT：是一个sampleRTT的加权平均值</li></ul><p>而超时间隔：</p><p>TimeoutInterval=EstimatedRTT+4*DevRTT</p><ul><li>DevRTT: RTT偏差：DevRTT = (1-b)DevRTT+b*|EstimatedRTT - SampleRTT|，b取0.25。<h4 id="1-4-3-可靠数据传输"><a href="#1-4-3-可靠数据传输" class="headerlink" title="1.4.3 可靠数据传输"></a>1.4.3 可靠数据传输</h4>发送方只用超时来恢复报文段的丢失。发送方有3个与发送和重传有关的事件: 从上层应用接受数据，定时器超时和收到ACK。</li></ul><p>超时间隔加倍：TCP每次在重传后会把超时间隔设置成原来的两倍，而不是从RTT公式计算。</p><p>快速重传：由于超时间隔加倍会增加端到端的时延，接收端采取累计确认。在期望报文段到达之前会不断发送相同的ack确认号，此为冗余ACk，在发送方收到3个冗余ACk，会采取快速重传，在定时器过期之前重传丢失的报文段。<br>Q：为什么是接收到3个冗余ack才开始重传<br>A：主要是因为考虑到分组的丢失是网络故障还是乱序造成的，如果是两次冗余ack，很有可能是乱序导致的，三个ack就有可能是网络故障，四次就更有可能。参考<a href="https://blog.csdn.net/u010202588/article/details/54563648" target="_blank" rel="noopener">https://blog.csdn.net/u010202588/article/details/54563648</a></p><p>选择重传：TCP更像是一种选择重传，但他结合了GBC和选择重传，发送方收到冗余ack或者超时，只会重传一个报文。</p><h4 id="1-4-4-流量控制"><a href="#1-4-4-流量控制" class="headerlink" title="1.4.4 流量控制"></a>1.4.4 流量控制</h4><p>TCP通过滑动窗口机制来提供流量控制，用于给发送方表明接收方还有多少可用的缓存空间。</p><ul><li><p>死锁：当B的接收窗口到达0，告诉发送方A停止发送数据，然后B又有了一些缓存，然后发送报文段告诉A，这段报文段丢失了，然后就出现了A等B，B等A的死锁情况。为了解决这个问题，tcp引入了持续计时器，当A收到B接收窗口为0的报文就启动计时器，到时间就发送一个大小为一个字节的报文去探测接收端的情况，如果还是为0，那么就重启定时器。</p></li><li><p>滑动窗口协议（ARQ）：TCP为了提高信道的利用率没有用停等协议，而是用ARQ协议：TCP发送端根据接收报文中的接收窗口rwnd来调整发送窗口：</p><h4 id="1-4-5-连接管理"><a href="#1-4-5-连接管理" class="headerlink" title="1.4.5 连接管理"></a>1.4.5 连接管理</h4><p>三次握手:</p><img src="/2019/09/01/TCP-IP协议总结/6.jpg"></li><li><p>SYN:报文段首部的同步位</p></li><li><p>seq：初始序号</p></li><li><p>ACK:首部的确认位</p></li><li><p>ack：确认号<br>Q: 为什么需要三次握手<br>A：</p></li></ul><ol><li>放止已失效的连接请求报文突然有传送到了服务器，从而产生错误连接</li><li>两次握手可能产生死锁，a向b发送请求，b收到请求后发送确认信号，开始发送数据，而a并没有受到b的确认信号（丢失），那么a不知道b的序列号，无法接收b的数据，b在发送数据超时后会重复发送，从而死锁。</li></ol><p>四次挥手：</p><img src="/2019/09/01/TCP-IP协议总结/7.jpg"><p>Q: 为什么客户端需要等待2MSL(MSL：报文最大生存时间)?<br>A: TCP报文段在网络中的最大生存周期建议是2min .</p><ol><li>如果最后的ACK丢失，客户端就可以重传最后的确认报文</li><li>假设直接进入客户端closed状态，服务端发送的数据还在网络中，而另一个应用重新占据此端口，就会导致上一个程序的数据发送给了这个新的连接。</li></ol><h4 id="1-4-6-拥塞控制"><a href="#1-4-6-拥塞控制" class="headerlink" title="1.4.6 拥塞控制"></a>1.4.6 拥塞控制</h4><p>参考自博客<a href="https://blog.csdn.net/jtracydy/article/details/52366461" target="_blank" rel="noopener">https://blog.csdn.net/jtracydy/article/details/52366461</a></p><h5 id="1-4-6-1-拥塞控制与流量控制"><a href="#1-4-6-1-拥塞控制与流量控制" class="headerlink" title="1.4.6.1 拥塞控制与流量控制"></a>1.4.6.1 拥塞控制与流量控制</h5><p>两者都是通过遏制发送方来达到的，但拥塞控制是一个全局的过程，设计到所有的主机，路由器，放止过多的数据注入到网络中个，而流量控制是端对端的问题</p><h5 id="1-4-6-2-慢启动"><a href="#1-4-6-2-慢启动" class="headerlink" title="1.4.6.2 慢启动"></a>1.4.6.2 慢启动</h5><p>刚开始传送数据时，为了探测网络状况，首先将cwnd设为1，发送m1后，然后当发送方收到m1的确认报文后，再发送m2，m3，之后收到m2和m3的确认报文后，又发送四个，即每经过一次传输轮次，cwnd就加倍。</p><h5 id="1-4-6-3-拥塞避免"><a href="#1-4-6-3-拥塞避免" class="headerlink" title="1.4.6.3 拥塞避免"></a>1.4.6.3 拥塞避免</h5><p>为了防止慢启动cwnd增加过快，设置了一个慢开始门限(ssthresh),当cwnd&gt;ssthresh时就进入拥塞避免状态,没经过一个RTT时间就让cwnd+1，而不是加倍</p><h5 id="1-4-6-4-发生超时"><a href="#1-4-6-4-发生超时" class="headerlink" title="1.4.6.4 发生超时"></a>1.4.6.4 发生超时</h5><p>无论是慢启动状态还是拥塞避免状态，一旦出现网络拥塞即发生超时事件，就会将慢开始门限（ssthresh）设置为cwnd值的一半，cwnd的值置为1，然后重新进入慢启动状态</p><h5 id="1-4-6-4-收到3个冗余ACK"><a href="#1-4-6-4-收到3个冗余ACK" class="headerlink" title="1.4.6.4 收到3个冗余ACK"></a>1.4.6.4 收到3个冗余ACK</h5><p>这里涉及到一个概念快速重传：当接收方收到失序的报文段时，会立即发送三个之前的已经确认的报文的确认报文，当接收方接收到后，不必等定时器过期，直接发送报文段。<br>在收到3个冗余ACK，这里不再是将cwnd设置为1，而是用快恢复：将ssthresh设置为cwnd的一半，然后cwnd=ssthresh，然后执行拥塞避免算法，是窗口缓慢增大。</p><h2 id="2-0-网络层"><a href="#2-0-网络层" class="headerlink" title="2.0 网络层"></a>2.0 网络层</h2><h3 id="2-1-转发与路由"><a href="#2-1-转发与路由" class="headerlink" title="2.1 转发与路由"></a>2.1 转发与路由</h3><ul><li>转发是将分组从路由器的输入端口转移到合适输出端口（转发表）。</li><li>路由涉及到一个网络中的所有路由器，决定了从源到目的地的路径（路由协议）。<h3 id="2-2-连接建立"><a href="#2-2-连接建立" class="headerlink" title="2.2 连接建立"></a>2.2 连接建立</h3>需要源到目的地沿着所选择的路径握手，以便建立起连接状态。<br>与TCP连接不同：网络层的连接建立是主机和主机之间，而tcp三次握手是不同应用之间。<h3 id="2-3-数据报网络与虚电路网络"><a href="#2-3-数据报网络与虚电路网络" class="headerlink" title="2.3 数据报网络与虚电路网络"></a>2.3 数据报网络与虚电路网络</h3>类似于运输层的TCP和UDP的连接和无连接服务，网络也分连接和无连接网络，不同的是网路层的服务是主机到主机，并且由网络核心实现。<h4 id="2-3-1-数据报网络"><a href="#2-3-1-数据报网络" class="headerlink" title="2.3.1 数据报网络"></a>2.3.1 数据报网络</h4></li><li>提供无连接服务</li><li>不事先为系列分组的传输确定传输路径</li><li>不同分组路径可能不同<h4 id="2-3-2-虚电路网络"><a href="#2-3-2-虚电路网络" class="headerlink" title="2.3.2 虚电路网络"></a>2.3.2 虚电路网络</h4></li><li>提供连接服务</li><li>事先就确定了传输路径</li><li>系列分组传输路径相同<h3 id="2-4-IPv4"><a href="#2-4-IPv4" class="headerlink" title="2.4 IPv4"></a>2.4 IPv4</h3><img src="/2019/09/01/TCP-IP协议总结/8.jpg"></li></ul><table><thead><tr><th>首部</th><th align="center">描述</th></tr></thead><tbody><tr><td>版本</td><td align="center">IPv4与IPv6</td></tr><tr><td>首部长度</td><td align="center">ip首部一般是20字节</td></tr><tr><td>服务类型</td><td align="center">FTP，IP电话应用等不同类型的ip数据区分开来</td></tr><tr><td>数据报长度</td><td align="center">该字段为16bit所有理论最大长度为2的16次方-1（总长度）</td></tr><tr><td>标识，标志，片偏移</td><td align="center">与ip分片有关</td></tr><tr><td>寿命TTL</td><td align="center">没经过一台路由器减一</td></tr><tr><td>协议</td><td align="center">指示了ip数据要交付给运输层的哪种协议，类似于运输层到应用层的端口号</td></tr><tr><td>首部检验和</td><td align="center">只对首部进行检验和</td></tr><tr><td>选项</td><td align="center">允许ip首部被扩展</td></tr></tbody></table><h4 id="2-4-1-IP数据报分片"><a href="#2-4-1-IP数据报分片" class="headerlink" title="2.4.1 IP数据报分片"></a>2.4.1 IP数据报分片</h4><p>链路层帧能承载的最大数据量为MTU（最大传送单元），严格限制着ip数据报的长度，过大的ip分组如何压缩进链路层帧的有效载荷？分片<br>IP数据报被分为许多片，到达目的地后进行组装。<br>与之相关的字段有数据报长度，标识，标志，片偏移<br>分片时每个片的标识是一样的，标志都置为1，只有最后一个片标志为0，而片偏移指示了它在原数据报中的位置。<br>每一片的长度都应该是8的倍数（一字节等于8bit）。</p><h3 id="2-5-选路算法"><a href="#2-5-选路算法" class="headerlink" title="2.5 选路算法"></a>2.5 选路算法</h3><p>全局的：采用链路状态算法，一开始就知道所有路由器具有完全的拓扑，费用信息<br>分散的：距离矢量算法，只知道邻居的信息。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈数据库</title>
      <link href="/2019/08/24/%E6%B5%85%E8%B0%88%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2019/08/24/%E6%B5%85%E8%B0%88%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="1-0-乐观锁与悲观锁"><a href="#1-0-乐观锁与悲观锁" class="headerlink" title="1.0 乐观锁与悲观锁"></a>1.0 乐观锁与悲观锁</h2><p>在单实例jvm中，处理并发问题，可以用synchronized，volatile，ReentrantLock等关键字。但是在分布式的环境中，上述方法却不能再跨jvm场景中处理并发问题，需要用其他方式。如数据库的锁机制丶缓存数据库如redis以及Zookeeper分布式锁</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h4><p>系统认为大多数情况下是不存在竞争问题，只在数据库更新操作时才对数据进行冲突检测，如果数据不一致，则会返回失败信息。</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式:"></a>实现方式:</h4><ol><li>添加一个版本号字段version，每次更新时先取版本号，更新提交时将之前的版本号与当前版本号对比，如果相等就将版本号+1，并更新其他字段，如果不相等，那么本次操作就执行失败<br>例如：update table set columnA = 1,version=version+1 where id=#{id} and version = #{oldVersion}</li><li>借助更新时间戳，添加一个更新时间戳字段，检测方法与1类似。</li><li>前两种方式检测的时候只有数据有改变就会失败，而有些字段只关心字段是否满足某一区间并不关心他们是否有冲突，且不用借助其他字段，用本身为判定条件。例如：库存，只要保证库存更新后值大于0 就行：update product set rest = rest– #{deduct} where name = ‘abc’ and rest &gt;= #{deduct}</li></ol><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>检测数据冲突时并不依赖数据库的锁机制，不会影响请求的性能，当产生并发切竞争较小时只有少部分请求会失败。</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>需要对表加额外的字段，增加了数据库的冗余，另外，如果单行数据竞争很大，version值不断变化，导致请求失败，影响系统的可用性。</p><p>综上，乐观锁适合于并发量高，但冲突（竞争率）较低，写操作不频繁，失败成本不高的场景</p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>系统每次对数据操作时，必须加锁不然会发生问题，这样的悲观保守的态度</p><h4 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h4><p>通过数据库锁机制实现，即对查询语句添加forupdate关键字。</p><p>如下sql语句 select * from table where id = 1 for update 当一个请求A开启事务并执行此sql同时未提交事务时，另一个线程B发起请求，此时B将阻塞在加了锁的查询语句上，直到A请求的事务提交或者回滚，B才会继续执行，保证了访问的隔离性。</p><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><p>可以严格保证数据访问的安全</p><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><p>每次请求都会额外产生锁的开销，未获取的锁的请求则会被阻塞，容易造成性能问题，还可能产生死锁情况。<br>当A操作执行其update操作时需要用到B操作的锁,而B操作这时也要用到A操作的锁，出现死锁时系统会自动回滚一个事务。可以考虑用乐观锁或者按照顺序去获得锁。</p><p>综上，悲观锁适合于并发量较小、失败成本高丶又需要独占读取结果并依赖读取的结果进行判断的业务场景比较适合使用悲观锁。</p><h2 id="排他锁与共享锁"><a href="#排他锁与共享锁" class="headerlink" title="排他锁与共享锁"></a>排他锁与共享锁</h2><p>共享锁：读锁，多个事务可以对同一行数据共享一把锁，只能读不能修改<br>排他锁：一个事务能获取一个数据行的排它锁，另一个事务就无法获取了，获取了排他锁的事务可以对数据行进行读取或修改。</p><p>默认的select语句是不加锁，select。。。lock in share 实现共享锁，利用for update加了排他锁之后不可以加其他的锁，只能用普通的select查询数据，不能用共享锁也不能用排他锁查询或修改。</p><h2 id="2-0-数据库的引擎"><a href="#2-0-数据库的引擎" class="headerlink" title="2.0 数据库的引擎"></a>2.0 数据库的引擎</h2><p>mysql引擎取决于mysql在安装时如何被编译的，要添加一个新的的引擎，就必须重新编译mysql，mysql有3个引擎<br>ISAM/MyISAM/HEAP,另外两种类型是INNODB/BERKLEY</p><ul><li>ISAM:设计之初就是认为表的查询次数远大于修改次数<br>ISAM查询速度快，不占用大内存和硬盘，但不支持事务，也不容错，一旦硬盘崩溃了，那么数据库文件就无法恢复了。</li><li>MyISAM：ISAM的升级版，提供索引和字段管理的功能，支持表锁定，myisam查询速度快，但同样损坏后不能进行数据恢复。</li><li>HEAP：允许只主流在内存里的临时表，速度最快，但容易丢失数据，不稳定</li><li>INNODB：支持事务。支持外键</li></ul><h3 id="2-1-INNODB与MyISAM对比"><a href="#2-1-INNODB与MyISAM对比" class="headerlink" title="2.1 INNODB与MyISAM对比"></a>2.1 INNODB与MyISAM对比</h3><table><thead><tr><th>-</th><th align="center">INNODB</th><th align="right">MyISAM</th></tr></thead><tbody><tr><td>是否支持事务</td><td align="center">是</td><td align="right">否</td></tr><tr><td>是否支持外键</td><td align="center">是</td><td align="right">否</td></tr><tr><td>是否支持行级锁</td><td align="center">是</td><td align="right">否</td></tr><tr><td>执行速度</td><td align="center">慢</td><td align="right">快</td></tr><tr><td>总的来说，</td><td align="center"></td><td align="right"></td></tr></tbody></table><h3 id="2-2-INNODB与MyISAM使用的索引区别"><a href="#2-2-INNODB与MyISAM使用的索引区别" class="headerlink" title="2.2 INNODB与MyISAM使用的索引区别"></a>2.2 INNODB与MyISAM使用的索引区别</h3><ul><li><p>MyISAM: B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</p><img src="/2019/08/24/浅谈数据库/5.png"></li><li><p>InnoDB: 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p><img src="/2019/08/24/浅谈数据库/6.png"></li></ul><h3 id="2-3-索引的使用及其优化策略"><a href="#2-3-索引的使用及其优化策略" class="headerlink" title="2.3 索引的使用及其优化策略"></a>2.3 索引的使用及其优化策略</h3><p>使用索引的好处：</p><ol><li>大大减少存储引擎需要扫描的数据量</li><li>进行排序避免使用临时表</li><li>将随机IO变成顺序IO</li></ol><h3 id="索引的最左匹配原则"><a href="#索引的最左匹配原则" class="headerlink" title="索引的最左匹配原则"></a>索引的最左匹配原则</h3><p>当我们为三个列建立联合索引时，</p><pre><code>ALTER TABLE people ADD INDEX lname_fname_age (lname,fname,age); </code></pre><p>相当于创建了（lname）单列索引，（lname,fname）组合索引，和(lname,fname,age)组合索引，最左边的列名优先，当查询中不包含最左边的列名时，将不会同过索引查询。</p><h3 id="2-3-INNODB与MyISAM使用的锁"><a href="#2-3-INNODB与MyISAM使用的锁" class="headerlink" title="2.3 INNODB与MyISAM使用的锁"></a>2.3 INNODB与MyISAM使用的锁</h3><ul><li>MyISAM使用表级锁</li><li>InnoDB使用行级锁和表级锁，默认为行级锁</li></ul><h2 id="3-0-数据库表中的常见七大约束"><a href="#3-0-数据库表中的常见七大约束" class="headerlink" title="3.0 数据库表中的常见七大约束"></a>3.0 数据库表中的常见七大约束</h2><ol><li>not null：此列不允许为空</li><li>default ：默认值</li><li>comment：列描述，没有实际含义，但不等同于注释</li><li>zerofill：假如值未达到字段所允许的最大值，则会在前面添加0，但实际存储的还是未加0的。</li><li>primary key：主键约束，用于唯一约束字段数据，不能为空，不能重复，字段要为整数类型，一张表只能有一个主键，但可以复合主键，</li><li>auto_increment：自增长，</li><li>unique：唯一键，不能重复，但允许为空，可以有多个空值。</li></ol><h2 id="4-0-数据库主键和外键"><a href="#4-0-数据库主键和外键" class="headerlink" title="4.0 数据库主键和外键"></a>4.0 数据库主键和外键</h2><p>举个栗子</p><ul><li>学生表(学号，姓名，性别，班级)<br>其中每个学生的学号是唯一的，学号就是一个主键 </li><li>课程表(课程编号,课程名,学分)<br>其中课程编号是唯一的,课程编号就是一个主键 </li><li>成绩表(学号,课程号,成绩)<br>成绩表中单一一个属性无法唯一标识一条记录，学号和课程号的组合才可以唯一标识一条记录，所以 学号和课程号的属性组是一个主键 </li></ul><p>成绩表中的学号不是成绩表的主键，而在学生表中是主键，就称成绩表中的学号为学生表的外键。同理 成绩表中的课程号是课程表的外键 </p><h2 id="5-0-聚集索引与非聚集索引"><a href="#5-0-聚集索引与非聚集索引" class="headerlink" title="5.0 聚集索引与非聚集索引"></a>5.0 聚集索引与非聚集索引</h2><ul><li>聚集索引：键值的逻辑顺序就决定了表中相应行的物理顺序，　聚集索引确定表中数据的物理顺序。聚集索引类似于电话簿，后者按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样。 {% asset_img 1.jpg %}</li><li>非聚集索引：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。聚集索引的叶子节点就是数据节点，然而非聚集索引的叶子节点任然是索引节点，只不过有一个指针指向对应的数据块。{% asset_img 2.jpg %}</li></ul><p>每张表只能有一个聚集索引（理论上），但可以有多个非聚集索引</p><h3 id="5-1-聚集索引该如何使用"><a href="#5-1-聚集索引该如何使用" class="headerlink" title="5.1 聚集索引该如何使用"></a>5.1 聚集索引该如何使用</h3><ol><li>有人认为主键就是聚集索引，我们通常在每个表中建立一个id列，这个id是auto——increment，作为主键，然而如果将他作为聚集索引，是没有意义的，因为id号是自动生成的，我们不会按照id号去查询，造成一种资源的浪费，<br>最好的办法是在日期上建立聚集索引。聚集索引某一范围内的数据。</li><li>所有需要提高查询速度的字段都加进聚集索引，并不能提高查询速度</li></ol><p>水可载舟，亦可覆舟”，索引也一样。索引有助于提高检索性能，但过多或不当的索引也会导致系统低效。因为用户在表中每加进一个索引，数据库就要做更多的工作。过多的索引甚至会导致索引碎片。<br>    　　所以说，我们要建立一个“适当”的索引体系，特别是对聚合索引的创建，更应精益求精，以使您的数据库能得到高性能的发挥。</p><p>摘抄自博客<a href="https://www.cnblogs.com/aspnethot/articles/1504082.html" target="_blank" rel="noopener">https://www.cnblogs.com/aspnethot/articles/1504082.html</a></p><h3 id="5-2-数据库表的连接"><a href="#5-2-数据库表的连接" class="headerlink" title="5.2 数据库表的连接"></a>5.2 数据库表的连接</h3><p>分为外连接和内连接和交叉连接，</p><ul><li>外连接又分左外连接，右外连接，全外连接{% asset_img 1.png %}{% asset_img 2.png %}{% asset_img 3.png %}{% asset_img 4.png %}</li><li>交叉连接指的是笛卡尔积</li></ul><p>具体可以参考博客<a href="https://www.cnblogs.com/thomasguan/p/4252410.html" target="_blank" rel="noopener">https://www.cnblogs.com/thomasguan/p/4252410.html</a></p><h2 id="6-0-事务"><a href="#6-0-事务" class="headerlink" title="6.0 事务"></a>6.0 事务</h2><p>事务是数据库单独执行的一个单元。逻辑上的一组操作，组成这组操作的各个单元要么全部成功，要么全部失败。<br>四大特性（ACID）</p><ul><li>原子性：事务不可分割，要么全部成功，要么全部失败</li><li>一致性：事务必须从一个一致性状态转换到另一个一致性状态</li><li>隔离性：多个事务并发执行时，将一个事务的内部操作隔离起来，不为其他事务可见。</li><li>持久性：事务完成后，对数据库的修改是永久性的</li></ul><h3 id="6-1-隔离性"><a href="#6-1-隔离性" class="headerlink" title="6.1 隔离性"></a>6.1 隔离性</h3><p>如果不考虑隔离会发生什么：事务A，事务B并发执行时</p><ol><li>脏读：A读取了B未提交的数据，B回滚，那么A读到的数据就是脏数据</li><li>不可重复读： A重复读同一数据，B对这个数据进行修改，然后发现前后数据不一致。</li><li>虚读（幻读）：A对数据表记录进行统计，有n个，然而B<br>对数据进行增删，A发现前后数据不一致。</li></ol><p>不可重复读侧重于修改，虚读侧重于增删。</p><p>隔离级别：由强到弱</p><ol><li>串行化，可避免所有问题   （锁住整张表）</li><li>可重复读，可避免不可重复，脏读（分有无索引）</li><li>读已提交，可避免脏读（锁住一行）</li><li>读未提交，不能避免</li></ol><p>mysql数据库默认是2</p><p>Q: 有了这些隔离级别为什么还要悲观锁与乐观锁<br>A:</p><ol><li>如果设置了数据库的隔离级别，就不能动态调整事务隔离级别了，</li><li>有时候为了减轻数据库压力，放宽事务的锁，把压力放在服务器上，使用同步锁</li><li>加锁可以在数据库实现，也可以在应用程序上实现，使用乐观锁和悲观锁让程序在应用程序有一个动态调整事务隔离级别的可能性。</li></ol><h2 id="7-0-大表优化"><a href="#7-0-大表优化" class="headerlink" title="7.0 大表优化"></a>7.0 大表优化</h2><p>如果mysql单表记录数过多，crud性能下降，常见的优化措施有：</p><ol><li>限定数据查询的范围：禁止那些没有具体范围的查询</li><li>读写分离：经典的数据库拆分方法，主库负责写，从库负责读</li><li>垂直分区:将数据库表按列拆分，将一张列比较多的表拆分成若干个列较少的表。根据数据库的相关性拆分，比如一张表既有用户信息也有登录信息，就可以将表拆分成两个表。<br>优点：行数据变小，减少读取的block数，减少io，简化了表的结构，易于表的维护<br>缺点：会产生数据的冗余，并引起连接操作，此外，会使事务变的复杂</li><li>水平分区：对数据库表按行拆分，表结构不变。如果数据记录太多，就可以将他拆分成几个数据表存储，水平拆分可以支持很大的数据量，如果只是分表，所有的信息还是存储在一个计算机上，那是没用的，所以最好水平分库，将不同数据表储存在不同计算机上（分布式）。<br> 优点：能支持很大的数据量，应用端改造较少，<br> 缺点：分片事务难以解决 ，因为拆分会带来逻辑、部署、运维的各种复杂度，如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</li></ol><p>下面补充一下数据库分片的两种常见方案：<br>客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。<br>中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。</p><h2 id="8-0-MYSQL（结构化查询语句）"><a href="#8-0-MYSQL（结构化查询语句）" class="headerlink" title="8.0 MYSQL（结构化查询语句）"></a>8.0 MYSQL（结构化查询语句）</h2><h3 id="8-1-简单查询"><a href="#8-1-简单查询" class="headerlink" title="8.1 简单查询"></a>8.1 简单查询</h3><p>以下sql来自于《MYSQL必知必会》</p><pre><code>SELECT DISTINT vend_id FROM products //返回id不同的列SELECT prod_name FROM products LIMIT 5 //限制返回五条记录SELECT prod_name FROM products LIMIT 3，4 //限制返回4条记录，从第3条开始，注意有第0行的存在</code></pre><h3 id="8-2-排序检索"><a href="#8-2-排序检索" class="headerlink" title="8.2 排序检索"></a>8.2 排序检索</h3><pre><code>SELECT user_id FROM user_info ORDER BY user_level //按user_level从小到大排列SELECT user_id FROM user_info ORDER BY user_level DESC //使用DESC 按user_level从大到小排列SELECT user_id FROM user_info ORDER BY user_level ，product_name //先按user_level从小到大排列，如果user_level相同，则会按product_name排序</code></pre><h3 id="8-3-过滤数据"><a href="#8-3-过滤数据" class="headerlink" title="8.3 过滤数据"></a>8.3 过滤数据</h3><p>使用where</p><pre><code>SELECT prod_name ,prod_price FROM products WHERE prod_price BETWEEN 5 AND 10; //查询某一个区间的值</code></pre><p>in操作符可以实现between操作符相同的功能；<br>and的优先级高于or，必要时可以加括号处理；</p><h3 id="8-4-通配符"><a href="#8-4-通配符" class="headerlink" title="8.4 通配符"></a>8.4 通配符</h3><p>LIKE操作符后面跟上统配符可实现特殊的查找<br>通配符有两种</p><ol><li>%代表匹配0个或1一个或多个任意字符</li><li>_代表匹配一个任意字符</li></ol><p>不要过度使用通配符，会影响性能，如果实在是需要，那么不要把统配符放在最前面。</p><h3 id="8-5-创建计算字段"><a href="#8-5-创建计算字段" class="headerlink" title="8.5 创建计算字段"></a>8.5 创建计算字段</h3><pre><code>SELECT Concat(goods_id,&#39;(&#39;,color,&#39;)&#39;) FROM goods_detail ORDER BY goods_id; //使用concat关键字来组合字符串。SELECT goods_id*stock AS price FROM goods_detail ORDER BY goods_id;//使用*获取计算结果，并用AS赋值为新的字段名</code></pre><h3 id="8-6-函数"><a href="#8-6-函数" class="headerlink" title="8.6 函数"></a>8.6 函数</h3><p>函数的可移植性不强，因为每个DBMS的函数可能不同，但在必要时，通过函数可以实现很方便的查找</p><ol><li>文本处理函数，Trim（），Upper(), Soundex()(转换成发音)</li><li>日期处理函数，Date（），Year（），Month（）<pre><code>SELECT order_id FROM order_info where Month(order_date)=7//查询七月的订单SELECT order_id FROM order_info where Date(order_date)=&#39;2019-07-10&#39;;//日期的格式必须是yyyy-mm-dd；</code></pre></li><li>数值处理函数,Abs(),Mod().</li><li>聚集函数：AVG(),COUNT(),MAX(),MIN(),SUM()<pre><code>SELECT AVG(order_price) AS average FROM order_info ORDER BY order_price;</code></pre><h3 id="8-7-分组查询"><a href="#8-7-分组查询" class="headerlink" title="8.7 分组查询"></a>8.7 分组查询</h3>使用 GROUP BY 语句可以实现对各种系列数目的统计<pre><code>SELECT user_id ,COUNT(*) AS count FROM order_info GROUP BY user_id;</code></pre></li></ol><p>使用HAVING关键字可以过滤分组，同时HAVING关键字也可以替换前面所有的WHERE使用的地方，WHERE，HAVING,GROUP BY使用的顺序如下</p><pre><code>SELECT vend_id,COUNT(*) FROM products WHERE prod_price&gt;=10 GROUP BY VEND_ID HAVING COUNT(*)&gt;2SELECT&gt;FROM&gt;WHERE&gt;GROUP BY&gt;HAVING&gt;ORDER BY&gt;LIMIT</code></pre><h3 id="8-8-子查询"><a href="#8-8-子查询" class="headerlink" title="8.8 子查询"></a>8.8 子查询</h3><p>最常见的子查询就是使用where 。。in（），括号中添加另一个查询语句，当然也有作为计算字段作为子查询</p><pre><code>SELECT user_id, user_level ,        (SELECT COUNT(*) FROM order_info WHERE                          order_info.user_id =user_info.user_id) AS count                   FROM user_info ORDER BY user_id;</code></pre><h3 id="8-9-联结"><a href="#8-9-联结" class="headerlink" title="8.9 联结"></a>8.9 联结</h3><p>在关系数据库中，不同表之间可以有关联，使用联结可以更方便的查询</p><ol><li><p>通过完全限定列名查询</p><pre><code>SELECT user_info.user_id, user_level ,order_id FROM user_info,order_info    WHERE user_info.user_id=order_info.user_id          ORDER BY user_info.user_id;//这里的user_id要使用完全限定列名，不然会有歧义</code></pre></li><li><p>笛卡尔积，如果没有用联结条件，那么查询的数据数目就是user的数目*order查询到的数目</p></li><li><p>内联结,</p><pre><code>SELECT user_info.user_id, user_level ,order_idFROM user_info INNER JOIN order_info    ON  user_info.user_id=order_info.user_id        ORDER BY user_info.user_id;</code></pre><p>可以达到同一同样的效果</p></li><li><p>左外联结与右外联结，同时返回另一个表中不匹配的项</p></li><li><p>自联结，对同一个表使用自联结</p><pre><code>SELECT p1.id,p1.name FROM products AS p1,products AS p2 WHERE P1.id=p2.id AND p1.level=19;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer算法题</title>
      <link href="/2019/08/16/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98-%E9%9D%A2%E8%AF%95%E8%83%BD%E5%8A%9B%E7%AF%87/"/>
      <url>/2019/08/16/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98-%E9%9D%A2%E8%AF%95%E8%83%BD%E5%8A%9B%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="面试能力篇"><a href="#面试能力篇" class="headerlink" title="面试能力篇"></a>面试能力篇</h1><a id="more"></a><h2 id="53-在排序数组中查找数字"><a href="#53-在排序数组中查找数字" class="headerlink" title="53.在排序数组中查找数字"></a>53.在排序数组中查找数字</h2><p>题目一:统计一个数字在排序数组中出现的次数</p><p>思路：找到数字在数组第一次出现的位置，和第二次出现的位置，使用二分法求，当数字在出现的位置前面一个数不等于他，那么它就是第一个数，同理当数字在出现的位置后面一个数不等于他，那么它就是第一个数</p><pre><code>  public int getNumberOfK(int[] arr,int k){        if(arr==null||arr.length&lt;=0){            return -1;        }        int length=arr.length;        int first=getFirstIndexOfK(arr,k,0,length);        int last=getLastIndexOfK(arr,k,0,length);        if(first==-1||last==-1)            return -1;        else            return last-first+1;    }    int getFirstIndexOfK(int[] arr,int k,int start,int end){        int mid=(start+end)/2;        while (start&lt;=end){            if(arr[mid]&gt;k){                end=mid-1;            }else if(arr[mid]&lt;k){                start=mid+1;            }else {                if(mid&gt;0&amp;&amp;arr[mid-1]!=k){                    return mid;                }else {                    end=mid-1;                }            }            mid=(start+end)/2;        }        return -1;    }    int getLastIndexOfK(int[] arr,int k,int start,int end){        int mid=(start+end)/2;        while (start&lt;=end){            if(arr[mid]&gt;k){                end=mid-1;            }else if(arr[mid]&lt;k){                start=mid+1;            }else {                if(mid&gt;0&amp;&amp;arr[mid+1]!=k){                    return mid;                }else {                    start=mid+1;                }            }            mid=(start+end)/2;        }        return -1;    }</code></pre><p>题目二：一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在0<del>n-1之内。在范围0</del>n-1内的n个数字有且只有一个不在数组中，找出该数字</p><p>思路：仍然基于二分法，当数字的下标大于他的值并且他的前一个数的下标等于他的值，那么就是所求的数</p><pre><code>int getFirstDiffer(int[] arr,int start,int end){        int mid=(start+end)/2;        while (start&lt;=end){           if(arr[mid]==mid){               start=mid+1;           }else {               if(mid&gt;0&amp;&amp;arr[mid-1]&gt;mid-1){                   end=mid-1;               }else {                   return mid;               }           }            mid=(start+end)/2;        }        return -1;    }</code></pre><p>题目三：<br>假设单调递增的数组里每个元素都是整数且都是唯一的。请实现函数，找出数组中任意一个数值等于其下标的元素。如</p><p>{-3,-1,1,3,5}，数字3和下标相等</p><pre><code>int getNumberSameAsIndex(int[] arr,int start,int end){        int mid=(start+end)/2;        while (start&lt;=end){           if(arr[mid]==mid){               return arr[mid];           }else if(arr[mid]&lt;mid){               start=mid+1;           }else{               end=mid-1;           }            mid=(start+end)/2;        }        return -1;    }</code></pre><h2 id="54-二叉搜索树的第k大节点"><a href="#54-二叉搜索树的第k大节点" class="headerlink" title="54.二叉搜索树的第k大节点"></a>54.二叉搜索树的第k大节点</h2><p>题目：给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。</p><p>思路：中序遍历</p><pre><code>int findKthNode(TreeNode pRoot,int k){        int[] arr=new int[1];        findKthNode(pRoot,k,arr);        return arr[0];    }    int index=0;    void findKthNode(TreeNode pRoot,int k,int[] arr ){        if(pRoot==null){            return;        }        TreeNode pNode=pRoot;        findKthNode(pNode.left,k,arr);        index++;        if(index==k){            arr[0]=pNode.value;        }        findKthNode(pNode.right,k,arr);    }</code></pre><h2 id="55-二叉树的深度"><a href="#55-二叉树的深度" class="headerlink" title="55.二叉树的深度"></a>55.二叉树的深度</h2><p>题目一：求一棵二叉树的深度<br>思路：当输入根节点，树的深度就等于左子树的深度和右子树的深度中较大的加一，递归下去。</p><pre><code>  int findTreeDepth(TreeNode pRoot) {        if(pRoot==null){            return 0;        }        int left=findTreeDepth(pRoot.left);        int right=findTreeDepth(pRoot.right);        return left&gt;right?(left+1):(right+1);    }</code></pre><p>题目二：判断一棵树是不是平衡二叉树<br>平衡二叉树的定义：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p><p>思路：从叶节点开始往上遍历，判断每一层是否是平衡二叉树，这里要定义一个全局变量，isbalanced，若某一处不是平衡的，那么这棵树就不是平衡二叉树</p><pre><code>private boolean isBalanced=true;    public boolean isBalanced_Solution(TreeNode root){        getDepth(root);        return isBalanced;    }    public int getDepth(TreeNode root){        if(root==null){            return 0;        }        int left=getDepth(root.left);        int right=getDepth(root.right);        int depth=1+(left&gt;right?left:right);        if(left-right&gt;=-1&amp;&amp;left-right&lt;=1&amp;&amp;isBalanced){            isBalanced=true;        }else {            isBalanced=false;        }        return depth;    }</code></pre><h2 id="56-数组中数字出现的次数"><a href="#56-数组中数字出现的次数" class="headerlink" title="56.数组中数字出现的次数"></a>56.数组中数字出现的次数</h2><p>题目一：数组中有两个数字恰好都只出现一次，其他的出现两次</p><p>思路：划分，将两个数字划分到两个不同的数组，然后异或，关键是怎么划分，划分的同时，两个相同的数字一定要划分到同一个数组。</p><ol><li>先求出整个数组异或的结果，也就是不相同的两个数字异或的结果，然后转换为二进制，求第一个1出现的地方（indexOf1），出现了1，那么不相同的两个数字在这一位上要么是1，要么是0.</li><li>遍历数组，如果这个数在indexOf1上是1，就划分到一个数组，如果是0，那就划分到另一个数组。</li></ol><p>试想一下，两个相同的数字那么他们在这一位上肯定是相同的，那么他们肯定会被划分到同一个数组。</p><pre><code>public int[] findNumsAppearOnce(int[] num){        if(num==null||num.length&lt;=0){            return new int[2];        }        int length=num.length;        int resultOfXOR=0;        for (int i = 0; i &lt;length ; i++) {            resultOfXOR^=num[i];        }        int indexOf1=indexOfFirst1(resultOfXOR);        int[] result=new int[2];        for (int i = 0; i &lt;length ; i++) {            if(isBit1(num[i],indexOf1)){                result[1]^=num[i];            }else {                result[0]^=num[i] ;            }        }        return result;    }   public int indexOfFirst1(int num){       int indexOf1=0;       while ((num&amp;1)==0){          num= num&gt;&gt;1;           indexOf1++;       }       return indexOf1;   }   public boolean isBit1(int num,int indexOf1){       num=num&gt;&gt;indexOf1;       if((num&amp;1)==1){           return true;       }       else {           return false;       }   }</code></pre><p>题目二：数组中有一个数字只出现一次，而其他数字出现三次</p><p>思路：将数组中所有数字某一位的bit位加起来对3求余，余数就是只出现一次数字某一位bit位的数字</p><pre><code>public int singleNumber(int[] nums) {      if(nums==null||nums.length&lt;=0){            return -1;        }        int[] bitSum=new int[32];        int length=nums.length;        for (int i = 0; i &lt;length; i++) {            int bitMask=1;            for (int j = 0; j &lt;32 ; j++) {                if((nums[i]&amp;bitMask)!=0){                    bitSum[j]++;                }                bitMask=bitMask&lt;&lt;1;            }        }        int result=0;        for (int i = 31; i &gt;=0 ; i--) {            result=result&lt;&lt;1;            result+=bitSum[i]%3;        }        return result;    }</code></pre><h2 id="57-和为s的数字"><a href="#57-和为s的数字" class="headerlink" title="57.和为s的数字"></a>57.和为s的数字</h2><p>题目一：输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p><p>思路：定义两个指针指向头尾，然后如果他们相加小于s那么头指针就++；大于s尾指针++,左右逼近</p><pre><code>public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int sum) {                    ArrayList&lt;Integer&gt; result=new ArrayList&lt;&gt;();        if (array==null||array.length&lt;=1){                return result;            }            int i=0;            int j=array.length-1;            int max=array[j]*array[j-1];            while (i&lt;j){                if(array[i]+array[j]==sum){                    if(array[i]*array[j]&lt;max) {                        result.add(array[i]);                        result.add(array[j]);                        max=array[i]*array[j];                    }                    i++;                    j--;                }else if(array[i]+array[j]&lt;sum){                    i++;                }else {                    j--;                }            }            return result;    }</code></pre><p>其实这里并不需要判断他是不是最小的那个，当左右逼近时，乘积最小的那个数其实就是靠近最外围的。</p><p>题目二：和为s的连续整数序列<br>输入一个整数s，输出所有的和为s的连续整数序列</p><pre><code>输入 15输出 12345,456，78</code></pre><p>思路：定义两个指针small和big，数值等于1和2，然后从big++，比较此时的和与s，如果小于s，big++，如果大于s，就去掉small。让small指向2，循环往复，知道small大于或等于s的中间值。</p><pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) {         ArrayList&lt;ArrayList&lt;Integer&gt; &gt; result=new ArrayList&lt;&gt;();            if(sum&lt;3){                return result;            }            ArrayList&lt;Integer&gt; sequence=new ArrayList&lt;&gt;();            int small=1;            int big=2;            sequence.add(small);            sequence.add(big);            int middle=(sum+1)/2;            int currentSum=3;            while (small&lt;middle){                if(currentSum==sum){                    ArrayList&lt;Integer&gt; path=new ArrayList&lt;&gt;(sequence);                    result.add(path);                    big++;                    sequence.add(big);                    currentSum+=big;                }else if(currentSum&lt;sum){                    big++;                    sequence.add(big);                    currentSum+=big;                }else {                    currentSum-=small;                    small++;                    sequence.remove(0);                }            }            return result;    }</code></pre><h2 id="58-翻转字符串"><a href="#58-翻转字符串" class="headerlink" title="58.翻转字符串"></a>58.翻转字符串</h2><p>题目一：翻转单词顺序，</p><pre><code>输入： &quot;i am a student&quot;输出： &quot;student a am i&quot;</code></pre><p>先全部翻转一遍，然后对每个单词单独翻转<br>这道题题目限制较松，不存在输入两边有空格的情况，中间的空格也不需要处理，</p><pre><code> public String reverseWords(String s) {        if (s == null) {            return &quot;&quot;;        }        s=s.trim();        char[] str = s.toCharArray();        int length = str.length;        reverseString(str, 0, length - 1);        int begin=0;        for (int i = 1; i &lt; length; i++) {            if (str[i]==&#39; &#39;){                if(i-begin&lt;2){                    continue;                }                reverseString(str,begin,i-1);                begin=i+1;            }        }        if(begin&lt;length){            reverseString(str,begin,length-1);        }        return String.valueOf(str);    }    private void reverseString(char[] str, int start, int end) {        while (start &lt; end) {            char temp = str[start];            str[start] = str[end];            str[end] = temp;            start++;            end--;        }    }</code></pre><p>题目二：左旋转字符串<br>输入一个字符串和一个数字k，将前面k个字符转到后面</p><pre><code>输入： &quot;abcdefg&quot; 和2输出： &quot;cdefgab&quot;</code></pre><p>沿用上一题的reverseString函数，只需要三次调用即可解决</p><pre><code> public String leftRotateString(String s,int k){        if(s==null||s.length()==0||k&lt;0||k&gt;s.length()){            return &quot;&quot;;        }        char[] chars=s.toCharArray();        int length=chars.length;        reverseString(chars,0,chars.length-1);        reverseString(chars,0,length-1-k);        reverseString(chars,length-k,length-1);        return String.valueOf(chars);    }</code></pre><p>注意k的取值</p><h2 id="59-队列中的最大值"><a href="#59-队列中的最大值" class="headerlink" title="59.队列中的最大值"></a>59.队列中的最大值</h2><p>题目一：定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}，{2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}，{2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><p>思路：用一个双端队列，用于保存数字的下标</p><ol><li>当队列为空时直接加入数值的下标，当当前的数值的下标减去队列里第一个元素的下标大于等于滑动窗口大小k时，将对头移出</li><li>移出比队列中当前元素还小的值</li><li>从第三个数开始将对头元素录入结果集。<pre><code>public int[] maxSlidingWindow(int[] num, int k) {     if(num==null||num.length==0||k&lt;=0){         return new int[0];     }     ArrayDeque&lt;Integer&gt; queue=new ArrayDeque&lt;&gt;();     int length=num.length;     int[] maxValue=new int[length-k+1];     int j=0;     for (int i = 0; i &lt; length; i++) {         if (queue.isEmpty()){             queue.add(i);         }         if(i-queue.peekFirst()&gt;=k){             queue.pollFirst();         }         while (!queue.isEmpty()&amp;&amp;num[queue.peekLast()]&lt;=num[i]){             queue.pollLast();         }         queue.add(i);         if(i+2&gt;k){             maxValue[j++]=num[queue.peekFirst()];         }     }     return maxValue; }</code></pre></li></ol><p>题目二：请定义一个队列并实现函数max得到队列里的最大值，要求函数max、push_back和pop_front的时间复杂度都是O(1)。</p><p>思路：用两个双端队列，一个队列用于存放最大值，一个队列按先进先出的顺序push和pop，这里定义一个内部类，将数值和他的index联系起来，存放最大值的队列依据于滑动窗口。</p><pre><code>class QueueWithMax {    ArrayDeque&lt;InternalData&gt; data=new ArrayDeque&lt;&gt;();    ArrayDeque&lt;InternalData&gt; maximum=new ArrayDeque&lt;&gt;();    int curIndex=0;    private class InternalData{        int number;        int index;        public InternalData(int number,int index){            this.number=number;            this.index=index;        }    }    public void push_back(int number){        InternalData internalData=new InternalData(number,curIndex);        data.add(internalData);        while (!maximum.isEmpty()&amp;&amp;maximum.peekLast().number&lt;=internalData.number){            maximum.pollLast();        }        maximum.add(internalData);        curIndex++;    }    public void pop_front(){        if(data.isEmpty()){            System.out.println(&quot;queue is empty&quot;);            return;        }        InternalData curData=data.pollFirst();        if(curData.index==maximum.peekFirst().index){            maximum.pollFirst();        }    }    public int max(){        if(data.isEmpty()){            System.out.println(&quot;queue is empty&quot;);            return 0;        }        return maximum.peekFirst().number;    }}</code></pre><h2 id="60-n个骰子的点数"><a href="#60-n个骰子的点数" class="headerlink" title="60.n个骰子的点数"></a>60.n个骰子的点数</h2><p>题目:把n个骰子扔在地上，朝上一面加起来的和，计算各种和的可能的概率。</p><p>思路：递归,自顶向下<br>定义一个大小为maxvalue-n+1的数组，来存储次数</p><pre><code>int g_maxValue=6;    public void printProbability(int n){        if(n&lt;1){            return;        }        int maxValue=g_maxValue*n;        int[] probabilities=new int[maxValue-n+1];        for (int i = 1; i &lt;=g_maxValue ; i++) {                getProbability(n,n-1,i,probabilities);        }        double total=(int)Math.pow(g_maxValue,n);        for (int i = n; i &lt;=maxValue ; i++) {            double ratio=(double)probabilities[i-n]/total;//要将数组中的            System.out.println(ratio);        }    }    void getProbability(int original,int current,int sum,int[] probabilities){        if(current==0){            probabilities[sum-original]++;            return;        }        for (int i = 1; i &lt;=g_maxValue ; i++) {                getProbability(original,current-1,sum+i,probabilities);        }    }</code></pre><p>思路二：动态规划，定义两个大小为maxValue+1数组，存储次数，扔第一个骰子，那么从1到6都是1次，扔第二个骰子，有六种可能，那么和为n的概率就等于上一次n-1，n-2，n-3，n-4，n-5，n-6概率的总和，有点抽象，就是第二次可以扔出6种可能（1-6），那么和为7的次数，就等于上一次7-1,7-2,7-3,7-4,7-5,7-6的次数的总和</p><pre><code>public void printProbabilityByLoop(int n){        if(n&lt;1){            return;        }        int maxValue=n*g_maxValue;        int[][] probabilities=new int[2][maxValue+1];        int flag=1;        for (int i = 1; i &lt;=g_maxValue ; i++) {            probabilities[flag][i]=1;        }        for (int k = 2; k &lt;=n ; k++) {            for (int j = 0; j &lt;k ; j++) {                probabilities[1-flag][j]=0;            }            for (int j = k; j &lt;= g_maxValue*k; j++) {                probabilities[1-flag][j]=0;                for (int i = 1; i &lt;j&amp;&amp;i&lt;=g_maxValue ; i++) {                    probabilities[1-flag][j]+=probabilities[flag][j-i];                }            }            flag=1-flag;        }        double total=Math.pow(g_maxValue,n);        for (int i = n; i &lt;=maxValue ; i++) {            double ratio=(double)probabilities[flag][i]/total;            System.out.println(i+&quot; : &quot;+ratio);        }    }</code></pre><h2 id="61-扑克牌中的顺子"><a href="#61-扑克牌中的顺子" class="headerlink" title="61.扑克牌中的顺子"></a>61.扑克牌中的顺子</h2><p>题目：给定一个数组，判断他是否是连续的，其中0可以为任何数字。<br>排序后统计0的个数和间隔的个数，相比较</p><pre><code> public boolean isContinuous(int[] nums){       if(nums==null||nums.length==0){           return false;       }       Arrays.sort(nums);       int numberOfZero=0;       int numberOfGap=0;       int length=nums.length;       for (int i = 0; i &lt; length&amp;&amp;nums[i]==0; i++) {           numberOfZero++;       }       int small=numberOfZero;       int big=small+1;       while (big&lt;length){           if(nums[big]==nums[small]){               return false;           }           numberOfGap+=nums[big]-nums[small]-1;           small=big;           big=small+1;       }       return numberOfGap&gt;numberOfZero?false:true;   }</code></pre><h2 id="62-约瑟夫环"><a href="#62-约瑟夫环" class="headerlink" title="62.约瑟夫环"></a>62.约瑟夫环</h2><p>题目：0, 1, … , n-1 这n个数字排成一个圈圈，从数字0开始每次从圆圏里删除第m个数字。求出这个圈圈里剩下的最后一个数字。删除数字后，从删除数字后的下一个数字开始计数。</p><p>思路：常规解法，创造一个环形链表</p><pre><code> public int lastRemaining(int n,int m){        if(n&lt;=0||m&lt;=0){            return -1;        }        ListNode pNode=createCircleList(n);        int count=1;        int alive=5;        while (alive&gt;1){            while (count&lt;m){                pNode=pNode.next;                if(pNode.value!=-1){                    count++;                }            }            pNode.value=-1;            count=0;            alive--;        }        int result=-1;        for (int i = 0; i &lt;n ; i++) {            if(pNode.value!=-1){               result=pNode.value;            }            pNode=pNode.next;        }       return result;    }  public ListNode createCircleList(int n){      ListNode pHead=new ListNode(0);      ListNode curNode=pHead;      for (int i = 1; i &lt;n ; i++) {          ListNode pNode=new ListNode(i);          curNode.next=pNode;          curNode=curNode.next;      }      curNode.next=pHead;      return pHead;  }</code></pre><p>思路二：数学推导：具体我也没咋看懂，但代码很简洁，时间复杂度为O（n）.</p><pre><code>int lastRemainingByMath(int n,int m){      if(n&lt;1||m&lt;1){          return -1;      }      int last=0;      for (int i = 2; i &lt;=n ; i++) {          last=(last+m)%i;      }      return last;  }</code></pre><h2 id="63-股票的最大利润"><a href="#63-股票的最大利润" class="headerlink" title="63.股票的最大利润"></a>63.股票的最大利润</h2><p>题目：给定一组按时间先后顺序的股票价格，求他们的最大利润</p><pre><code>输入：{9,8,5,7,12,16,14}输出: 11 //16-5</code></pre><p>思路：求数组中的最大差异，当然大数要在小数后边，这里用动态规划，每次放入一个数，就求这个数与前面的数中最小的值的差，那么就是求这个差的最大值。</p><pre><code>public int getMaxDiff(int[] nums){        if(nums==null||nums.length==0){            return -1;        }        int length=nums.length;        int min=nums[0];        int diff=nums[1]-nums[0];        for (int i = 2; i &lt;length; i++) {            if(nums[i-1]&lt;min){                min=nums[i-1];            }            int curDiff=nums[i]-min;            if(curDiff&gt;diff){                diff=curDiff;            }        }        return diff;    }</code></pre><h2 id="64-求1-2-3-…-n"><a href="#64-求1-2-3-…-n" class="headerlink" title="64.求1+2+3+…+n"></a>64.求1+2+3+…+n</h2><p>题目：不用if for while else swich case等关键字求1加到n<br>思路：递归，这里用一个短路运算符&amp;&amp;用于循环的终止条件。</p><pre><code> public int getSum(int n){        int result=n;        int a=0;        boolean value=(n&gt;0)&amp;&amp;(a==(result+=getSum(n-1)));        return result;    }</code></pre><h2 id="65-不同加减乘除法做加法"><a href="#65-不同加减乘除法做加法" class="headerlink" title="65.不同加减乘除法做加法"></a>65.不同加减乘除法做加法</h2><p>题目：不用+-x÷实现加法<br>思路：用位运算，分三步走，第一步先异或，不考虑进位，第二步用与，计算进位，然后左移一步，第三再将异或后的值与进位相异或，那么这时候也有可能继续产生进位，循环下去。</p><pre><code>public int add(int num1,int num2){       int sum;       int carry;       while (num2!=0){           sum=num1^num2;           carry=(num1&amp;num2)&lt;&lt;1;           num1=sum;           num2=carry;       }       return num1;   }</code></pre><h2 id="66-构建乘积数组"><a href="#66-构建乘积数组" class="headerlink" title="66.构建乘积数组"></a>66.构建乘积数组</h2><p>题目:给定长度为 n 的整数数组 A，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p><pre><code>输入: [1,2,3,4]输出: [24,12,8,6]</code></pre><p>思路：这里不能用到除法，换个方向想，新建数组B，B[i]=A[0]+A[1]+A[2]+…+A[i-1]+A[i+1]+…+A[n-1],看成两部分，一一部分是A[0]+A[1]+A[2]+…+A[i-1],另一部分A[i+1]+…+A[n-1],那么分两部走，第一步从头开始A[0]+A[1]+A[2]+…+A[i-1]=B[i-1]*A[i-1],第二步从尾开始，不太好阐述，直接看代码</p><pre><code> public int[] multiply(int[] A){       if(A==null||A.length==0) {           return new int[0];       }       int length=A.length;       int[] B=new int[length];       B[0]=1;       for (int i = 1; i &lt;length ; i++) {           B[i]=B[i-1]*A[i-1];       }       int temp=1;       for (int i = length-2; i&gt;=0 ; i--) {           temp*=A[i+1];           B[i]*=temp;       }       return B;   }</code></pre><h2 id="67-之字形打印矩阵"><a href="#67-之字形打印矩阵" class="headerlink" title="67.之字形打印矩阵"></a>67.之字形打印矩阵</h2><p>题目描述：给你一个包含 m x n 个元素的矩阵 (m 行, n 列), 求该矩阵的之字型遍历。</p><pre><code>样例：对于如下矩阵：[  [1, 2,  3,  4],  [5, 6,  7,  8],  [9,10, 11, 12]]返回 [1, 2, 5, 9, 6, 3, 4, 7, 10, 11, 8, 12]</code></pre><p>思路：注意边界条件，每次按斜上方，斜下方顺序遍历矩阵，内嵌循环的终止后，判断他们是否都超出了边界，怎样超出的，重置他们。</p><pre><code> public int[] printZMatrix(int[][] matrix){       if(matrix==null||matrix.length==0){           return new int[0];       }       int rows=matrix.length;       int cols=matrix[0].length;       int size=rows*cols;       int[] result=new int[size];       int i=0;       int j=0;       int  count=0;//循环中止条件       while (count&lt;size){            while (count&lt;size&amp;&amp;i&gt;=0&amp;&amp;j&lt;cols){//向斜上方                result[count++]=matrix[i][j];                i-=1;                j+=1;            }            if(j&lt;cols){//这时候i已经越过了，重置i；                i+=1;            }else {//i和j都越过了，重置i，j                i+=2;                j-=1;            }            while (count&lt;size&amp;&amp;i&lt;rows&amp;&amp;j&gt;=0){//向斜下方                result[count++]=matrix[i][j];                i+=1;                j-=1;            }            if(i&gt;=rows){//重置                i-=1;                j+=2;            }else {//重置                j+=1;            }       }        return result;   }</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章主要讲了应聘者所要具有的综合素质，包括编程能力，学习能了，沟通能力，发散思维能力，抽象建模能力，知识迁移能力。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解http总结</title>
      <link href="/2019/08/13/%E5%9B%BE%E8%A7%A3http%E6%80%BB%E7%BB%93/"/>
      <url>/2019/08/13/%E5%9B%BE%E8%A7%A3http%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>《图解http》精华总结</p><a id="more"></a><p><strong>注：鉴于大部分的笔记都在纸质笔记本上，这里只对《图解http》粗略记载一下重要的知识点，包括以后面试题中关于计算机网络的知识点都可以记载于此</strong></p><h2 id="第一章-Web网络基础"><a href="#第一章-Web网络基础" class="headerlink" title="第一章 Web网络基础"></a>第一章 Web网络基础</h2><h3 id="URI-与-URL"><a href="#URI-与-URL" class="headerlink" title="URI 与 URL"></a>URI 与 URL</h3><p>URI用字符串表示某一网络资源，URL表示资源的地点（互联网上所处的位置）。</p><h2 id="第二章-简单的http协议"><a href="#第二章-简单的http协议" class="headerlink" title="第二章 简单的http协议"></a>第二章 简单的http协议</h2><h3 id="2-1无状态协议"><a href="#2-1无状态协议" class="headerlink" title="2.1无状态协议"></a>2.1无状态协议</h3><p>HTTP协议不对请求和响应之间的通信状态进行保存，这时为了更快的处理大量事务，确保协议的可伸缩性。为了实现期望的保存状态的功能，于是引入了Cookie奇数。</p><h3 id="2-2-http-1-1-中的方法"><a href="#2-2-http-1-1-中的方法" class="headerlink" title="2.2 http/1.1 中的方法"></a>2.2 http/1.1 中的方法</h3><ul><li>GET 获取资源</li><li>POST 传输实体主体</li><li>PUT 传输文件</li><li>HEAD 获得报文首部</li><li>DELETE 删除文件</li><li>OPTIONS 询问指定资源支持的方法</li><li>TARCE 追踪路径</li><li>CONNECT 要求用隧道协议连接代理<h3 id="2-3-http的持久性连接"><a href="#2-3-http的持久性连接" class="headerlink" title="2.3 http的持久性连接"></a>2.3 http的持久性连接</h3>最初的http通信没进行一次就要断开一次tcp连接，但后来发展成了持久性连接：只要一方没有明确提出断开连接，则保持tcp连接状态。</li><li>管线化：http持久连接中，发送方不同等待响应即可直接发送另一个请求。</li></ul><h2 id="第三章-HTTP报文内的http信息"><a href="#第三章-HTTP报文内的http信息" class="headerlink" title="第三章 HTTP报文内的http信息"></a>第三章 HTTP报文内的http信息</h2><p>用于http协议交互的信息被称为http报文。请求端的称为请求报文，响应端称为响应报文。<br>http报文分为报文首部和报文主体，两者用空行（CR+LF）来划分。通常，并不一定要有报文主体。</p><h3 id="3-1-结构"><a href="#3-1-结构" class="headerlink" title="3.1 结构"></a>3.1 结构</h3><p>报文首部分为请求行/状态行 ，以及首部字段<br>首部字段有四种：通用首部，请求首部，响应首部，实体首部。</p><ol><li>通用首部：请求和响应报文两方都会使用的首部</li><li>请求首部： 请求方报文使用的首部，包括请求的附加内容，客户端信息，响应内容相关优先级等信息</li><li>响应首部：响应报文中的</li><li>实体首部：针对响应报文和请求报文中的实体部分使用的首部，与实体有关的信息<h3 id="3-2-编码"><a href="#3-2-编码" class="headerlink" title="3.2 编码"></a>3.2 编码</h3>在传输过程中通过编码提升速率。</li></ol><ul><li>报文：http通信的基本单位，由8位组字节流组成</li><li>实体：作为请求和响应的有效载荷数据被传输，由首部和主体组成<br>通常报文主体等于实体主体，只有当传输进行编码操作时，实体主体才会发生变化。</li></ul><h2 id="第四章-状态码"><a href="#第四章-状态码" class="headerlink" title="第四章 状态码"></a>第四章 状态码</h2><p>状态码告知服务器端返回的请求结果</p><h3 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h3><p>信息性状态码，指接受的请求正在处理，继续下一步</p><h3 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h3><p>表明请求被正常处理</p><ol><li>200 OK<br>客户端发来的请求已被正常处理了</li><li>204 NOT CONTENT<br>客户端发来的请求已被正常处理了，但返回的响应中不含实体的主体部分。</li><li>206 Partial Content<br>表明客户端进行了范围请求</li></ol><h3 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h3><p>表明浏览器需要进行特殊的处理以正确处理请求</p><ol><li>301 Moved Permanently<br>永久性重定向，表示请求资源已被永久分配到新的URI上了</li><li>302 Found<br>临时性重定向</li><li>303 See Other<br>表示请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源</li><li>304 Not Modeified<br>表明资源已找到，但发生请求未满足条件的情况，直接返回304,304虽然划分在3xx中，但跟重定向没关系。</li><li>307 Temporary Redirect<br>临时性重定向</li></ol><h3 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h3><p>表明客户端是发生错误的原因所在</p><ol><li>400 Bad Request<br>请求报文中发生语法错误</li><li>401 Unauthrorized<br>表明发送的请求需要http认证，当浏览器初次接受到401时，会弹出认证的对话窗口</li><li>403 Forbidden<br>表明请求的资源被服务器设置为拒绝访问</li><li>404 Not Found<br>服务器无法找到请求的资源</li></ol><h3 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h3><ol><li>500 Internal Server Error<br>服务器在执行请求时发生了故障</li><li>503 Service Unvailable<br>服务器处于超负荷和停机维护状态</li></ol><h2 id="第五章-Web服务器"><a href="#第五章-Web服务器" class="headerlink" title="第五章 Web服务器"></a>第五章 Web服务器</h2><p>一台http服务器可以搭建多个web站点，里用虚拟主机（virtua host，又称虚拟服务器）的功能。<br>但因为一台主机的ip地址是相同的，所有在发送http请求时，必须在host首部内完整指定主机名或域名的URI</p><h3 id="通信数据转发程序"><a href="#通信数据转发程序" class="headerlink" title="通信数据转发程序"></a>通信数据转发程序</h3><ol><li>代理<br>代理服务器的基本行为就接收客户端发送的请求然后传给服务器。<ul><li>缓存代理：缓存代理会预先将资源的副本保存在代理服务器上，当代理接收到相同资源的请求，会直接将缓存的副本串给客户端，而不去访问源服务器。缓存有时间期限，客户端也可以有缓存。</li><li>透明代理： 转发请求或响应时，会对报文进行加工</li></ul></li><li>网关<br>网关的工作机制和代理相似，但网关能使通信线路上的服务器提供非http协议服务。利用网关的加密特性能提高通信的安全性。</li><li>隧道<br>隧道通常在相隔甚远的服务器和客户端之间进行中转，他的目的是让他们之间进行安全的通信，使用SSL等加密手段。</li></ol><h2 id="补充-：HTTP与HTTTPS的区别与联系"><a href="#补充-：HTTP与HTTTPS的区别与联系" class="headerlink" title="补充 ：HTTP与HTTTPS的区别与联系"></a>补充 ：HTTP与HTTTPS的区别与联系</h2><p>HTTPS=SSL+HTTP，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li>HTTPS更加安全，需要到CA机构去申请证书</li><li>HTTPS是具有安全协议的ssl加密传输，而http是明文传输</li><li>http的端口为80，https为443<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3></li><li>客户端向服务端发送请求</li><li>服务端传回证书中的公钥（证书需要配置)，证书就是一对公钥和私钥,用于非对称加密</li><li>客户端检验证书，然后用公钥加密自己的私钥（一个随机码，用于对称加密）</li><li>服务端用自己的私钥解开，然后获得对称加密的私钥，然后用这个私钥加密自己要传输的信息</li><li>客户端再用自己的私钥解开</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合详解</title>
      <link href="/2019/08/11/java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/08/11/java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-集合是什么"><a href="#1-集合是什么" class="headerlink" title="1.集合是什么"></a>1.集合是什么</h2><a id="more"></a><p>java集合类存放于java.util包中，是用来存放对象的容器<br>注意:</p><ol><li>集合只能存放对象。比如你存一个 int 型数据 1放入集合中，其实它是自动转换成 Integer 类后存入的，Java中每一种基本类型都有对应的引用类型</li><li>集合存放的是多个对象的引用，对象本身还是在堆内存</li></ol><h2 id="2-集合框架图"><a href="#2-集合框架图" class="headerlink" title="2.集合框架图"></a>2.集合框架图</h2><img src="/2019/08/11/java集合详解/1.png"><p>迭代器（iterator）是一个对象， 它的工作时遍历并选择序列中的对象，它提供了一中访问容器对象中的各个元素，而又不必暴露该对象内部细节的方法。通过迭代器，开发人员不需要了解容器底层的结构，就可以实现对容器的遍历。由于创建迭代器的代价小，因此迭代器通常被称为轻量级的容器。</p><p>它的子接口listIterator在此基础上增加了三种方法，add，previous，hasPrevious，List集合实现的是这个接口，支持在迭代期间向List中添加或删除元素，并且可以在List中双向滚动。</p><p>还有一个特点就是抽象类的使用。如果要自己实现一个集合类，去实现那些抽象的接口会非常麻烦，工作量很大。这个时候就可以使用抽象类，这些抽象类中给我们提供了许多现成的实现</p><p>Iterator:迭代器，它是Java集合的顶层接口（不包括 map 系列的集合，Map接口 是 map 系列集合的顶层接口）<br>Collection:List和Set接口的父接口</p><h2 id="3-集合详解"><a href="#3-集合详解" class="headerlink" title="3.集合详解"></a>3.集合详解</h2><h3 id="3-1-Set的无序性问题"><a href="#3-1-Set的无序性问题" class="headerlink" title="3.1 Set的无序性问题"></a>3.1 Set的无序性问题</h3><p>顺序有两个概念：</p><ol><li>按照添加的顺序排列</li><li>按照自然循序a-z，1-无穷，</li></ol><p>Set中HashSet它不能保证自然顺序，也不能保证自然顺序，而set的其他实现类是可以实现这两种顺序的<br>1，LinkedHashset : 保证元素添加的顺序</p><p>2，TreeSet : 保证元素的自然顺序，treeset底层是红黑树</p><pre><code>import java.util.HashSet;import java.util.LinkedHashSet;import java.util.Set;import java.util.TreeSet;public class Prectice {    public static void main(String[] args) {        Set&lt;String&gt; set = new HashSet&lt;&gt;();        set.add(&quot;String1&quot;);        set.add(&quot;String4&quot;);        set.add(&quot;String3&quot;);        set.add(&quot;String2&quot;);        set.add(&quot;String5&quot;);        set.forEach(e-&gt; System.out.print(e+&quot; &quot;));        System.out.println();        //LinkedHashSet会保证元素的添加顺序        Set&lt;String&gt; set2 = new LinkedHashSet&lt;&gt;();        set2.add(&quot;String1&quot;);        set2.add(&quot;String5&quot;);        set2.add(&quot;String3&quot;);        set2.add(&quot;String4&quot;);        set2.add(&quot;String2&quot;);        set2.forEach(e-&gt; System.out.print(e+&quot; &quot;));        System.out.println();        //TreeSet保证元素自然顺序        Set&lt;String&gt; set3 = new TreeSet&lt;&gt;();        set3.add(&quot;String1&quot;);        set3.add(&quot;String5&quot;);        set3.add(&quot;String4&quot;);        set3.add(&quot;String2&quot;);        set3.add(&quot;String3&quot;);        set3.forEach(e-&gt; System.out.print(e+&quot; &quot;));    }}</code></pre><p>输出结果：</p><p>String5 String4 String3 String2 String1       HashSet元素乱序,这里因为他是<br>String1 String5 String3 String4 String2       LinkedHashSet保证元素添加顺序</p><p>String1 String2 String3 String4 String5       TreeSet元素按自然顺序排序</p><h3 id="3-2-Hashset中输出元素为什么是“有序的”？"><a href="#3-2-Hashset中输出元素为什么是“有序的”？" class="headerlink" title="3.2 Hashset中输出元素为什么是“有序的”？"></a>3.2 Hashset中输出元素为什么是“有序的”？</h3><p>JDK1.8中hashset的实现变了，又因为插入的是Integer，其hashcode返回就是其自身，所以在对象hashCode这一步引入了巧合的“按大小排序”。然后HashMap.hash(Object)获取了对象的hashCode()之后会尝试进一步混淆，JDK8版java.util.HashMap内的hash算法比JDK7版的混淆程度低；在[0, 2^32-1]范围内经过HashMap.hash()之后还是得到自己。</p><h3 id="3-3-HashMap详解"><a href="#3-3-HashMap详解" class="headerlink" title="3.3 HashMap详解"></a>3.3 HashMap详解</h3><ul><li>内存存储结构（JDK1.8以上）：数组+链表+红黑树</li><li>默认容量为16，默认装载因子0.75，扩容后是原来的两倍</li><li>key和value都要求是泛型</li><li>key可以为null，装到table[0]的位置，value可以为null</li><li>hashcode：计算键的hashcode作为存储信息的数组的下标，用于查找值对象的位置</li><li>equals：HashMap用equals方法判断两个键是否相等。</li><li>HashMap会先用hashcode找到位置，由于杂凑算法，两个不同地址的对象的hashcode可能相同，这时候就用equals再来判断他们的值是否相等。<h4 id="3-3-1-HashMap，Hashtable-LinkedHashMap-TreeMap"><a href="#3-3-1-HashMap，Hashtable-LinkedHashMap-TreeMap" class="headerlink" title="3.3.1 HashMap，Hashtable,LinkedHashMap,TreeMap"></a>3.3.1 HashMap，Hashtable,LinkedHashMap,TreeMap</h4></li><li>Hashtable是遗留类，功能与hashmap相似，key和value都不允许有null。但它是线程安全的，并发性不如concurrentHashMap（下面会讲）</li><li>LinkedHashMap：保留了记录的插入顺序，用iterator遍历时，会按照插入顺序。</li><li>TreeMap：对插入的记录按键进行了排序，默认升序。<h4 id="3-3-2-hash算法"><a href="#3-3-2-hash算法" class="headerlink" title="3.3.2 hash算法"></a>3.3.2 hash算法</h4><pre><code>方法一：static final int hash(Object key) {   //jdk1.8 &amp; jdk1.7   int h;   // h = key.hashCode() 为第一步 取hashCode值   // h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算   return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}方法二：static int indexFor(int h, int length) {  //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的   return h &amp; (length-1);  //第三步 取模运算}</code></pre>这里用&amp;代替%取模运算，加快效率，而第二步，防止高位参与不了取模运算，将自身与高位相异或。</li></ul><p>Q: 为什么一定扩容要是2的倍数：<br>A: 因为第三步取模运算如果length=15，那么length-1=1110，那么1111与1110与这个数相与就得到了一样的数，增加了碰撞的几率，造成了空间的浪费。</p><h4 id="3-3-3-hashtable与concurrentHashMap的线程安全比较"><a href="#3-3-3-hashtable与concurrentHashMap的线程安全比较" class="headerlink" title="3.3.3 hashtable与concurrentHashMap的线程安全比较"></a>3.3.3 hashtable与concurrentHashMap的线程安全比较</h4><p>hashmap不存在线程安全</p><ul><li>hashtable:使用synchronized，锁住整张表</li><li>concurrentHashmap ：使用锁分段技术，将map分为n的segment，每次进行写操作时，只锁住一个segement，也就是一个桶。再到jdk1.8以后，逐渐抛弃segment的概念，转而锁住桶的第一个节点。采用CAS和synchronized来保证并发安全。不允许键值出现null<h4 id="3-3-4-为什么重写了equals方法后必须重写hashcode方法"><a href="#3-3-4-为什么重写了equals方法后必须重写hashcode方法" class="headerlink" title="3.3.4 为什么重写了equals方法后必须重写hashcode方法"></a>3.3.4 为什么重写了equals方法后必须重写hashcode方法</h4><blockquote><p>hashcode的规定:<br>(1)当obj1.equals(obj2)为true时，obj1.hashCode() == obj2.hashCode()必须为true<br>(2)当obj1.hashCode() == obj2.hashCode()为false时，obj1.equals(obj2)必须为false</p></blockquote></li></ul><p>Object类的equals默认是比较两个对象的地址，hashcode也是根据对象地址生成一个数值，如果不重写，两个对象的equals是不可能相等的，重写了之后，如果在重写后，两个值一样的对象那么equals就等于true，然而他们的hashcode却不一样。自然违背额hashcode的规定。以hashset为例，当放入一个值时，先计算他的hashcode与set集合里面的值相比较，如果没有相同，则放进去，如果相同，再比较他们的equals方法是否相等。</p><h4 id="3-3-5-HashMap在高并发环境下会引发什么样的安全问题？"><a href="#3-3-5-HashMap在高并发环境下会引发什么样的安全问题？" class="headerlink" title="3.3.5 HashMap在高并发环境下会引发什么样的安全问题？"></a>3.3.5 HashMap在高并发环境下会引发什么样的安全问题？</h4><ol><li>死循环：jdk1.8以前在扩容时会将链表逆序处理，也就是扩容前的链表中节点的顺序与扩容后的节点顺序是相反的，假如两个线程同时检测到要扩容，然后进行tranfer循环，形成循环链表，导致get（）方法一直在链表中循环。<br>参考博客<a href="https://www.cnblogs.com/gxyandwmm/p/9537669.html" target="_blank" rel="noopener">https://www.cnblogs.com/gxyandwmm/p/9537669.html</a></li><li>数据丢失：两个线程同时在put元素，如果有产生哈希碰撞，因为两个线程得到同一份下标去存储，可能会导致覆盖的情况，从而数据丢失，参考博客<a href="https://www.cnblogs.com/binyue/p/3726403.html" target="_blank" rel="noopener">https://www.cnblogs.com/binyue/p/3726403.html</a></li></ol><p>三种解决方案</p><ol><li>改用hashtable，效率低</li><li>使用Collections.synchronized（）方法对hashmap进行同步</li><li>使用ConcurrentHashMap</li></ol><h3 id="3-4-list详解"><a href="#3-4-list详解" class="headerlink" title="3.4 list详解"></a>3.4 list详解</h3><p>Arraylist与Linkedlist</p><ol><li>两者都不是线程安全的</li><li>Arraylist底层是数组，linkedlist底层是双向链表</li><li>Arraylist支持高效的随机访问，而linkedlist不支持</li><li>Arraylist实现了RandomAccess接口，优先使用for循环，其次是foreach循环，而linkedlist未实现，优先使用iterator遍历（底层也是foreach循环），其次再用for循环</li></ol>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Collections </tag>
            
            <tag> 集合 </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer算法题</title>
      <link href="/2019/08/11/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98-%E4%BC%98%E5%8C%96%E6%95%88%E7%8E%87%E7%AF%87/"/>
      <url>/2019/08/11/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98-%E4%BC%98%E5%8C%96%E6%95%88%E7%8E%87%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="优化效率篇"><a href="#优化效率篇" class="headerlink" title="优化效率篇"></a>优化效率篇</h1><a id="more"></a><h2 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39.数组中出现次数超过一半的数字"></a>39.数组中出现次数超过一半的数字</h2><p>题目：输入一个数组，如果一个数字出现的次数超过一半，就输出它，没有则返回-1。</p><p>思路：可以考虑先将数组排序，然后取中位数，时间复杂度是O（nlogn）<br>下面介绍两种思路</p><p>####1. 基于partition函数的时间复杂度为O（n）的算法<br>我们只需要找中位数，那么它两边的数是否已排序不用管<br>用基于快速排序的partition函数，随机取数，然后划分，每次返回该数的下标，如果下标小于n/2，那么中位数应该位于它的右边，如果下标大于n/2，那么中位数应该位于它的左边<br>找到还要判断它的次数是否超过一半</p><pre><code>  public int moreThanHalfNum(int[] numbers) {        if(numbers==null||numbers.length==0){            return 0;        }        int length=numbers.length;        int mid=length&gt;&gt;1;        int start=0;        int end=length-1;        int index=partition(numbers,start,end);        while (index!=mid){            if(index&lt;mid){                start=index+1;                index=partition(numbers,start,end);            }else {                end=index-1;                index=partition(numbers,start,end);            }        }        if(!checkNum(numbers,length,numbers[index])) {            numbers[index]=0;        }        return numbers[index];    }    public int partition(int[] numbers,int start,int end){        if(start&gt;end){            return -1;        }        int i=start;        int j=end;        int pivot=numbers[start];        while (i&lt;j){            while (i&lt;j&amp;&amp;numbers[j]&gt;=pivot){                j--;            }            while (i&lt;j&amp;&amp;numbers[i]&lt;=pivot){                i++;            }            if(i&lt;j){                int temp=numbers[i];                numbers[i]=numbers[j];                numbers[j]=temp;            }        }        int temp=numbers[start];        numbers[start]=numbers[j];        numbers[j]=temp;            return j;    }    public boolean checkNum(int[] numbers,int length,int result){        int time=0;        for (int i = 0; i &lt;length ; i++) {            if(numbers[i]==result){                time++;            }        }//        System.out.println(time);        return time*2&gt;length;    }</code></pre><p>####2. 基于数组特点的时间复杂度为O（n）的算法<br>思路：这个数出现的次数比其他数字出现次数的总和还多，定义一个变量用来保存数，一个变量times用来计数，当下一个数与当前数不同，times–，相同就times++，当times等于0时，就把下一个数作为变量保存下来，那么最后的数一定是次数最多的那个（如果存在）。</p><pre><code> public int moreThanHalf(int[] numbers){        if(numbers==null||numbers.length&lt;=0){            return 0;        }        int length=numbers.length;        int time=0;        int result=0;        for (int i = 0; i &lt; length; i++) {            if(time==0){                result=numbers[i];                time=1;            }            else if(numbers[i]!=result) {                time--;            }else {                time++;            }        }        if(!checkNum(numbers,length,result)){            result=0;        }        return result;    }</code></pre><h2 id="40-最小的k个数"><a href="#40-最小的k个数" class="headerlink" title="40.最小的k个数"></a>40.最小的k个数</h2><p>题目：输入n个整数，找出其中最小的k个数，</p><pre><code>输入 [4,5,1,6,2,7,3,8]输入最小的4个数字：1,2,3,4</code></pre><p>思路：</p><p>####1. 基于partition函数的时间复杂度为O（n）的算法<br>仍然沿用上一题的parttition函数，当返回的index小于k-1时，那么第k个大的数就在右边，当返回的index大于k-1，那么第k个大的数就在左边</p><pre><code>public int[] getNumbers(int[] input, int k) {        if (input == null || input.length &lt;= 0 || k == 0 || input.length &lt; k) {            return null;        }        int length = input.length;        int[] result = new int[k];        int start = 0;        int end = length - 1;        int index = partition(input, start, end);        while (index != k - 1) {            if (index &gt; k - 1) {                end = index - 1;                index = partition(input, start, end);            } else {                start = index + 1;                index = partition(input, start, end);            }        }        for (int i = 0; i &lt; k; i++) {            result[i] = input[i];        }        return result;    }</code></pre><h4 id="2-基于Treeset集合的时间复杂度为O-nlogk-的算法（适合处理海量数据）"><a href="#2-基于Treeset集合的时间复杂度为O-nlogk-的算法（适合处理海量数据）" class="headerlink" title="2.基于Treeset集合的时间复杂度为O(nlogk)的算法（适合处理海量数据）"></a>2.基于Treeset集合的时间复杂度为O(nlogk)的算法（适合处理海量数据）</h4><p>我们先创建一个大小为k的数据容器，用来存储最小的k个数，依次遍历输入的数组，当容器没满时，就直接将数加入进去，当容器满了，就要比较当前的数与容器中最大的数，若小于就要容器中最大的数移出，并加入当前的数。<br>这个容器可以用红黑树，从而保证查找，删除和插入操作都只需要O（logk）的时间</p><pre><code>   public int[] getNumbersByTree(int[] input, int k) {        if (input == null || input.length &lt;= 0 || k == 0 || input.length &lt; k) {            return null;        }        int[] result = new int[k];        TreeSet&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;();        int length = input.length;        for (int i = 0; i &lt; length; i++) {            if (treeSet.size() &lt; k) {                treeSet.add(input[i]);            } else {                int max = treeSet.last();                if (max &gt; input[i]) {                    treeSet.remove(max);                    treeSet.add(input[i]);                }            }        }        int i=0;        for (int n:treeSet             ) {            result[i]=n;            i++;        }        return result;    }</code></pre><p>第一种解法会改变输入的数组，但速度快，第二解法不会改变原来的数组，虽然速度慢点，但适合处理海量数据，由于内存的大小有限，不可能把海量的数据一次载入内存，</p><h2 id="41-数据流的中位数"><a href="#41-数据流的中位数" class="headerlink" title="41.数据流的中位数"></a>41.数据流的中位数</h2><p>题目：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>思路：</p><img src="/2019/08/11/剑指offer算法题-优化效率篇/1.PNG"><p>AVL树的实现过于复杂，这里使用两个堆来解决<br>一个是最大堆（最大的元素在堆顶），一个是最小堆</p><ul><li><p>当堆中的数（总共的数）是偶数时，要插入一个新的数，先将数插入最大堆，然后将最大堆的最大的数插入最小堆，这时总数为奇数，取最小堆堆顶元素为中位数</p></li><li><p>当堆中的数为奇数时，要插入一个新的数，先将数插入最小堆，在将最小堆堆顶元素插入最大堆，这时总数为偶数，取最小堆和最大堆的堆顶元素的平均值。</p><pre><code>public class Solution {  private int count=0;  private PriorityQueue&lt;Integer&gt; minHeap=new PriorityQueue&lt;&gt;();  private PriorityQueue&lt;Integer&gt; maxHeap=new PriorityQueue&lt;&gt;(15, new Comparator&lt;Integer&gt;() {      @Override      public int compare(Integer o1, Integer o2) {          return o2-o1;      }//PriorityQueue默认是最小堆。  });  public void insert(int num){      if((count&amp;1)==0){          maxHeap.offer(num);          minHeap.offer(maxHeap.poll());      }      else {          minHeap.offer(num);          maxHeap.offer(minHeap.poll());      }      count++;  }  public Double getMedian(){      if((count&amp;1)==0){          return (double) (minHeap.peek() + maxHeap.peek()) /2;      }      else {          return (double)minHeap.peek();      }  }}</code></pre><h2 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42.连续子数组的最大和"></a>42.连续子数组的最大和</h2><p>题目：给定一个数组arr，数组中的元素有整数也有负数，数组中的一个或者连续多个数组成一个子数组。</p></li></ul><p>求所有子数组里面的最大和。例如现在有数组 {1 ， -2 ， 3 ， 10 ， -4 ， 7 ， 2 ， -5 }。<br>要求时间复杂度为O（n）<br>思路：暴力法不可行，</p><ul><li>动态规划  <img src="/2019/08/11/剑指offer算法题-优化效率篇/2.PNG">  当前面的数加起来等于负数，那么就抛弃前面的数的和，sum=当前的数，如果加起来的等于正，sum=sum+当前的数，</li></ul><pre><code>  public int findGreatestSumOfSubArray(int[] arr){        if(arr==null||arr.length&lt;0){            return 0;        }        int currentSum=0;        int nGreatestSum=0;        for (int i = 1; i &lt;arr.length; i++) {            if(currentSum&lt;=0){                currentSum=arr[i];            }else {                currentSum+=arr[i];            }            if(currentSum&gt;nGreatestSum){                nGreatestSum=currentSum;            }        }        return nGreatestSum;    }</code></pre><p><strong>下面两题偏向于找规律</strong></p><h2 id="43-1到n整数中1出现的个数"><a href="#43-1到n整数中1出现的个数" class="headerlink" title="43.1到n整数中1出现的个数"></a>43.1到n整数中1出现的个数</h2><p>题目:输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数。例如输入12，从1到12这些整数中包含1的数字有1，10，11和12，1一共出现了5次。</p><p>思路：这里书上说的晦涩难懂，参考一篇博客<br><a href="https://blog.csdn.net/yi_afly/article/details/52012593" target="_blank" rel="noopener">https://blog.csdn.net/yi_afly/article/details/52012593</a><br>从个位分析，找出每位1出现的规律</p><img src="/2019/08/11/剑指offer算法题-优化效率篇/3.PNG"><p>这里的former是指weight前面所有位的数，不单单指前面一个位</p><pre><code>public int timesOf1(int n){      int base=1;      int round=n;      int weight=0;      int former=0;      int sum=0;      while (round&gt;0){          weight=round%10;          round=round/10;          if(weight==0){              sum+=round*base;          }else if(weight==1){              sum+=round*base+former+1;          }else {              sum+=round*base+base;          }          base*=10;          former=n%base;      }      return sum;  }</code></pre><p>复杂度：O（logn）</p><h2 id="43-数字序列中某一位的数字"><a href="#43-数字序列中某一位的数字" class="headerlink" title="43.数字序列中某一位的数字"></a>43.数字序列中某一位的数字</h2><p>数字按照0123456789101112131415161718192021…的顺序排列。第5位（从0开始计数）为5，第13位为1，第19位为4…… 求任意第n位对应的数字。</p><p>思路：找规律，分三步找：</p><ol><li>找出该数是几位数，1位数有10个，2位数有90个所有当index大于10+90*2时，那么他的位数肯定大于2。</li><li>找出这个数的数值，可以从他位于n位数的第几个开始着手，比如输入218，219&gt;190，所以他是三位数，三位数从100开始，219-190=29,29=3*9+2，所以他为了三位数的第9个数，等于109（这里从100开始数，数到108后还有两位，所以是第9个数）</li><li>那么它就位于109的第二位（从高位数）</li></ol><pre><code>public int digitAtIndex(int index) {        if (index &lt; 0) {            return -1;        }        if (index &lt; 10) {            return index;        }        int length = lengthOfNum(index);//这个数的位数        int number = numberBeforeLength(length);//数的长度前面有多少个，比如输入3，前面有90*2+10=190个数字        int indexOfNum = (index - number) % length;//在这个数的第几个，        int countOfNumber = (index - number - indexOfNum) / length;//在n位数的中的第几位        int thisNum = (int) (Math.pow(10, length - 1) + countOfNumber);//index所对应的数字        int digit= digitAtIndexOfNum(thisNum,length-indexOfNum);//因为indexOfNum是从前面数的，要从低位数        return digit;    }    int digitAtIndexOfNum(int num,int indexOfThisNum){        int n=0;        int digit=0;        while (n&lt;=indexOfThisNum){            digit=num%10;            num/=10;            n++;        }        return digit;    }    public int lengthOfNum(int index) {        int n = 2;        int sum = 10;        int base = 10;        while (sum &lt; index) {            sum += n * base * 9;            n++;            base *= 10;        }        return n - 1;    }    public int numberBeforeLength(int length) {        int n = 2;        int base = 10;        int sum = 10;        while (n &lt; length) {            sum += n * base * 9;            n++;            base *= 10;        }        return sum;    }</code></pre><h2 id="45-把数组排成最小的数"><a href="#45-把数组排成最小的数" class="headerlink" title="45.把数组排成最小的数"></a>45.把数组排成最小的数</h2><p>题目：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><p>思路：引入一个新的排序规则，两个数n和m，如果nm&gt;mn，那么n&gt;m，这nm指的是字符串相加，如：1和2，那么nm=12.<br>现将所有数按照这种规则排列，排列后的顺序就是最小数字的排列顺序。</p><pre><code>  public String printMinNumber(int[] numbers){       if(numbers==null||numbers.length&lt;=0){           return null;       }       List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();       for (int n: numbers            ) {           list.add(n);       }       Collections.sort(list, new Comparator&lt;Integer&gt;() {           @Override           public int compare(Integer o1, Integer o2) {               String s1 = String.valueOf(o1);               String s2 = String.valueOf(o2);               String str1 = s1+s2;               String str2 = s2+s1;               return str1.compareTo(str2);           }       }) ;       StringBuilder str=new StringBuilder();       for (int n:list            ) {           str.append(n);       }       return str.toString();   }</code></pre><h2 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46.把数字翻译成字符串"></a>46.把数字翻译成字符串</h2><p>题目：给定一个数字，按照如下规则翻译成字符串：0翻译成“a”，1翻译成“b”…25翻译成“z”。一个数字有多种翻译可能，例如12258一共有5种，分别是bccfi，bwfi，bczi，mcfi，mzi。实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p>思路：自上而下，从最大的问题开始，递归 ：</p><pre><code>                     12258                   /       \              b+2258       m+258              /   \         /   \          bc+258 bw+58  mc+58  mz+8          /  \      \        \     \      bcc+58 bcz+8   bwf+8   mcf+8  mzi        /        \       \     \   bccf+8        bczi    bwfi   mcfi     / bccfi</code></pre><p>有很多子问题被多次计算，比如258被翻译成几种这个子问题就被计算了两次</p><ul><li><p>递归</p><pre><code>public int getTranslationCount(int number){   if(number&lt;0){       return 0;   }   String num=String.valueOf(number);   char[] numbers=num.toCharArray();   int length=numbers.length;   return getTranslationCountCore(numbers,length);}int getTranslationCountCore(char[] numbers,int length,int start,int count){   if(start&gt;=length-1){       return 1;   }   int digit1=numbers[start]-&#39;0&#39;;   int digit2=numbers[start+1]-&#39;0&#39;;   int converted=digit1*10+digit2;   if(converted&gt;=10&amp;&amp;converted&lt;=25){       count=getTranslationCountCore(numbers,length,start+2,count)               +getTranslationCountCore(numbers,length,start+1,count);   }   else {       count=getTranslationCountCore(numbers,length,start+1,count);   }   return count;}</code></pre></li><li><p>动态规划</p></li></ul><pre><code>public int getTranslationCount(int number){     if(number&lt;0){         return 0;     }     String num=String.valueOf(number);     char[] numbers=num.toCharArray();     int length=numbers.length;     return getTranslationCountCore(numbers,length); }  int getTranslationCountCore(char[] numbers,int length){     int[] counts=new int[length];     for (int i = length-1; i &gt;=0 ; i--) {         int count=0;         if(i&lt;length-1){             count=counts[i+1];         }else {             count=1;         }         if(i&lt;length-1){             int digit1=numbers[i]-&#39;0&#39;;             int digit2=numbers[i+1]-&#39;0&#39;;             int converted=digit1*10+digit2;             if(converted&gt;9&amp;&amp;converted&lt;26){                 if(i==length-2){                     count+=1;                 }else {                     count += counts[i + 2];                 }             }         }         counts[i]=count;     }     return counts[0]; }</code></pre><h2 id="47-礼物的最大价值"><a href="#47-礼物的最大价值" class="headerlink" title="47.礼物的最大价值"></a>47.礼物的最大价值</h2><p>题目：在一个m*n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向左或者向下移动一格，知道到达棋盘的右下角。给定一个棋盘及其上面的礼物，请计算你最多能拿多少价值的礼物？</p><p>思路：动态规划，f(i,j)=max(f(i-1,j),f(i,j-1))+gift(i,j),用循环来做，比递归效率高，需要借助一个辅助的二维数组</p><pre><code>public int getMaxValue(int[][] number) {     if(number==null||number.length&lt;=0){         return 0;     }     int col=number[0].length;     int row=number.length;     return getMaxValueCore1(number,row,col); } int getMaxValueCore(int[][] number,int row,int col){     int[][] maxVaule=new int[row][col];     for (int i = 0; i &lt;row ; i++) {         for (int j = 0; j &lt;col ; j++) {             int left=0;             int up=0;             if(i&gt;0){                 left=maxVaule[i-1][j];             }             if(j&gt;0){                 up=maxVaule[i][j-1];             }             maxVaule[i][j]=Math.max(left,up)+number[i][j];         }     }     return maxVaule[row-1][col-1]; }</code></pre><p><strong>优化空间</strong><br>遍历顺序是从左至右，从上到下<br>每次计算拿到的礼物最大值的时候，最大值的坐标只依赖(i-1,j)and(i,j-1)两个格子，<br>因此第i-2行及以上所有的格子礼物最大值没有必要保存下来，因此可以用一维数组代替二维数组，一维数组的长度为棋盘的列数，当我们计算坐标为(i,j)格子能够拿到礼物的最大价值f(i,j)的时候，数组钱j个数字分别是f(i,0),f(i,1)…,f(i,j-1)，数组从下标为j的数字开始到最后一个数字，分别为f(i-1,j),f(i-1,j+1),…,f(i-1,n-1)，也就是数组前面j个数字分别是当前第i行前面j个格子礼物的最大值，而后的数字分别保存前面第i-1行n-j个格子礼物的最大值。</p><pre><code>int getMaxValueCore1(int[][] number,int row,int col){        int[] maxVaule=new int[col];        for (int i = 0; i &lt;row ; i++) {            for (int j = 0; j &lt;col ; j++) {                int left=0;                int up=0;                if(i&gt;0){                    up=maxVaule[j];                }                if(j&gt;0){                    left=maxVaule[j-1];                }                maxVaule[j]=Math.max(left,up)+number[i][j];            }        }        return maxVaule[col-1];    }</code></pre><h2 id="48-最长不含重复字符的子字符串"><a href="#48-最长不含重复字符的子字符串" class="headerlink" title="48.最长不含重复字符的子字符串"></a>48.最长不含重复字符的子字符串</h2><p>最长不重复子串：一个字符串中最长的没有重复字符的子串。</p><p>思路：动态规划，当当前字符(i)与与前面的字符没有重复，那么f(i)=f(i-1)+1,如果重复，就计算重复字符之间的距离d与f(i-1)想比较，若d较大，那么f（i）=f(i-1)+1，否则f（i）=d;<br>怎么判断当前字符与前面的字符重复，可以用一个大小为26的int数组，初始化为-1，那么字符’a’的在数组的位置就是0，0对应的值就是上次他出现在字符串的下标</p><pre><code>public int longestSubString(String str) {     if(str==null||str.length()&lt;=0){         return -1;     }     char[] strs=str.toCharArray();     int[] position=new int[26];     for (int i = 0; i &lt;26; i++) {         position[i]=-1;     }     int curLength=0;     int maxLength=0;     int length=strs.length;     for (int i = 0; i &lt;length ; i++) {         int preIndex=position[strs[i]-&#39;a&#39;];         if(preIndex&lt;0||i-preIndex&gt;curLength){             curLength++;         }else {             if(curLength&gt;maxLength){                 maxLength=curLength;             }             curLength=i-preIndex;         }         position[strs[i]-&#39;a&#39;]=i;         if(curLength&gt;maxLength){             maxLength=curLength;         }     }     return maxLength; }</code></pre><h2 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49.丑数"></a>49.丑数</h2><p>编写一个程序，找出第 n 个丑数。</p><p>丑数就是只包含质因数 2, 3, 5 的正整数。</p><p>思路：创建一个大小为n的数组，用于储存丑数，按大小依次求出丑数，假设之前的丑数存起来了，那么下一个丑数就是用2，3,5分别乘某一个丑数（这个丑数必须大于之前丑数最大的），然后取三者最小的，作为下一个，有点抽象。</p><pre><code>public int getUglyNumber(int index) {        if (index &lt; 0)            return 0;        int[] uglyNumbers = new int[index];        uglyNumbers[0] = 1;        int nextUglyNumberIndex = 1;        int multiply2 = 0;        int multiply3 = 0;        int multiply5 = 0;        for (int i = 1; i &lt; index; i++) {            int min = min(uglyNumbers[multiply2] * 2, uglyNumbers[multiply3] * 3, uglyNumbers[multiply5] * 5);            uglyNumbers[nextUglyNumberIndex] = min;            while (uglyNumbers[multiply2] * 2 &lt;= min) {//必须是大于min时跳出循环                multiply2++;            }            while (uglyNumbers[multiply3] * 3 &lt;= min) {                multiply3++;            }            while (uglyNumbers[multiply5] * 5 &lt;= min) {                multiply5++;            }            nextUglyNumberIndex++;        }        return uglyNumbers[index - 1];    }    int min(int number1, int number2, int number3) {        int min = number1 &gt; number2 ? number2 : number1;        return min &lt; number3 ? min : number3;    }</code></pre><h2 id="50-第一个只出现一次的字符"><a href="#50-第一个只出现一次的字符" class="headerlink" title="50.第一个只出现一次的字符"></a>50.第一个只出现一次的字符</h2><p>题目：在字符串中找出第一个只出现一次的字符。如输入”abaccdeff”，则输出’b’.</p><p>思路: 这题用空间来换时间，用一个大小为256个字符的哈希表来存储字符出现的次数，然后在遍历一次字符串，找到第一个出现一次的字符，时间复杂度O(n),空间复杂度是常数所以是o(1)<br>应为char是1个字节的（8bit）最大只有256</p><pre><code>public Character findFirstNotRepeatChar(String str)  {        if(str==null||str.length()&lt;=0){            return  null;        }        HashMap&lt;Character,Integer&gt; table=new HashMap&lt;&gt;(256);        char[] strs=str.toCharArray();        int length=strs.length;        for (int i = 0; i &lt;length; i++) {            table.put(strs[i],table.getOrDefault(strs[i],0)+1);        }        for (int i = 0; i &lt;length ; i++) {            if(table.get(strs[i])==1) {                return strs[i];            }        }        return null;    }</code></pre><h2 id="51-数组中的逆序对"><a href="#51-数组中的逆序对" class="headerlink" title="51.数组中的逆序对"></a>51.数组中的逆序对</h2><p>题目：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。</p><pre><code>输入： 7,5,6，4输出： 5</code></pre><p>思路：基于归并排序，先将数组划分成一个一个的数，比较两个相邻数之间的大小，计算逆序的个数，然后排序，再比较两个相邻已排序的数组之间的逆序个数，</p><p>比较两个相邻已排序数组之间的逆序个数时，分别用两个指针指向两个数组的最大值，也就是最大的下标，如果第一个数组的指针的值大于第二个指针对应的值，那么第二个指针前面的所有值就是逆序的个数。</p><pre><code>public int inversePairs(int[] data){        if(data==null||data.length&lt;=0){            return 0;        }        int length=data.length;        int[] copy=new int[length];        return inversePairsCore(data,copy,0,length-1);    }    public int inversePairsCore(int[] data,int[] copyOfData,int start,int end){        if(start==end){            return 0;        }        int mid=(start+end)/2;        int left=inversePairsCore(data,copyOfData,start,mid);        int right=inversePairsCore(data,copyOfData,mid+1,end);        int i=mid;        int j=end;        int copyIndex=end;        int count=0;        while (i&gt;=start&amp;&amp;j&gt;=mid+1){            if(data[i]&gt;data[j]){                copyOfData[copyIndex--]=data[i--];                count+=j-mid;            }else {                copyOfData[copyIndex--]=data[j--];            }        }        for (;i&gt;=start;i--){            copyOfData[copyIndex--]=data[i--];        }        for (;j&gt;=mid+1;j--){            copyOfData[copyIndex--]=data[j--];        }        for (int k = start; k &lt;=end ; k++) {            data[k]=copyOfData[k];        }        return left+right+count;    }</code></pre><h2 id="52-两个链表的第一个公共节点"><a href="#52-两个链表的第一个公共节点" class="headerlink" title="52.两个链表的第一个公共节点"></a>52.两个链表的第一个公共节点</h2><p>题目：输入两个链表，找出它们的第一个公共结点。<br>思路：两个链表如果含有公共节点，那么就是一个Y字形，可以用两个辅助栈来保存链表节点，从栈顶也就链表尾节点，来比较，空间复杂度和时间复杂度都是O(M+N)。<br>另一种思路是：求出两个链表的长度，然后用两个指针指向两个链表的头节点，让较长链表的指针先走x步（x为两个链表长度之差）<br>，然后两个指针再同时走，走到相同节点为止。</p><pre><code>public ListNode getFirstCommonNode(ListNode pHead1,ListNode pHead2){        if(pHead1==null||pHead2==null){            return null;        }        int length1=getListLength(pHead1);        int length2=getListLength(pHead2);        int minusOfLength;        ListNode pListHeadLong=pHead2;        ListNode pListHeadShort=pHead1;        minusOfLength=length2-length1;        if(length1&gt;length2) {            pListHeadLong=pHead1;            pListHeadShort=pHead2;            minusOfLength=length1-length2;        }        for (int i = 0; i &lt;minusOfLength; i++) {            pListHeadLong=pListHeadLong.next;        }        while (pListHeadLong!=null&amp;&amp;pListHeadShort!=null&amp;&amp;pListHeadLong!=pListHeadShort){            pListHeadLong=pListHeadLong.next;            pListHeadShort=pListHeadShort.next;        }        return pListHeadLong;    }    public int getListLength(ListNode listHead){        int count=0;        ListNode pNode=listHead;        while (pNode!=null){            pNode=pNode.next;            count++;        }        return count;    }</code></pre><h2 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h2><p>相比空间复杂度，面试官更加看重时间复杂度，<br>降低时间复杂度的第一种办法是采用更高效的算法，比如用动态规划循环代替递归。<br>第二种办法是用空间换时间</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂谈</title>
      <link href="/2019/08/07/%E6%9D%82%E8%B0%88/"/>
      <url>/2019/08/07/%E6%9D%82%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="记录一下平时略有感触的杂文"><a href="#记录一下平时略有感触的杂文" class="headerlink" title="记录一下平时略有感触的杂文"></a>记录一下平时略有感触的杂文</h1><a id="more"></a><ul><li>技术好不代表着就要持才自傲，不要把别人对你的尊重和宽容当成是自己争得的荣耀，不要习惯否认他人，不要好为人师，不要因为工作上的事情伤害他人自尊</li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer算法题</title>
      <link href="/2019/08/05/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E7%AF%87/"/>
      <url>/2019/08/05/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="解题思路篇"><a href="#解题思路篇" class="headerlink" title="解题思路篇"></a>解题思路篇</h1><a id="more"></a><p><strong>下面三题主要考察用画图来讲解自己的思路</strong></p><h2 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27.二叉树的镜像"></a>27.二叉树的镜像</h2><p>题目:请完成一个函数，输入一棵二叉树，该函数输出他的镜像。</p><img src="/2019/08/05/剑指offer算法题-解题思路篇/2.PNG"><p>思路：自顶向下，利用前序遍历，先访问根节点，然后对根节点的左右子树进行翻转</p><pre><code> public TreeNode invertTree(TreeNode root) {         if (root == null) return null;            // 保存右子树            TreeNode rightTree = root.right;            // 交换左右子树的位置            root.right = invertTree(root.left);            root.left = invertTree(rightTree);            return root;    }</code></pre><h2 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28.对称的二叉树"></a>28.对称的二叉树</h2><p>题目:给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><pre><code>    1   / \  2   2 / \ / \3  4 4  3</code></pre><p>思路：前序遍历：先遍历根节点，再左子节点，再右子节点。<br>那么针对前序遍历的对称的遍历算法：先遍历根节点，再右子节点，再左子节点<br>如果一棵树是对称的，则它的前序遍历与前序遍历的对称遍历时一样的。</p><pre><code>public boolean isSymmetrical(TreeNode root){        return isSymmetrical(root,root);    }boolean isSymmetrical(TreeNode root1,TreeNode root2){        if(root1==null&amp;&amp;root2==null){            return true;        }        if(root1==null||root2==null){            return false;        }        if(root1.value!=root2.value){            return false;        }        return isSymmetrical(root1.left,root2.rigth)&amp;&amp;isSymmetrical(root1.rigth,root2.left);    }</code></pre><h2 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29.顺时针打印矩阵"></a>29.顺时针打印矩阵</h2><p>题目：给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。<br>示例 1:</p><pre><code>输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,3,6,9,8,7,4,5]</code></pre><p>思路：先考虑循环中止条件，把打印看成一圈一圈的打印，每次打印矩阵的一圈，圈的起始点有规律，都是（n，n），n表示1,2,3。。。row是矩阵的行数，col是矩阵的列数，当</p><pre><code>n*2&gt;col&amp;&amp;n*2&gt;row</code></pre><p>时循环终止。<br>接下来在考虑怎么打印一圈，外圈都好打印，当打印到最内圈时，他有3种可能性</p>{% asset_img 1.PNG %}<pre><code>public List&lt;Integer&gt; spiralOrder(int[][] numbers) {        if(numbers==null||numbers.length&lt;=0||numbers[0].length&lt;=0){            return new ArrayList&lt;&gt;();        }        int row=numbers.length;        int col=numbers[0].length;        int start=0;        List&lt;Integer&gt; lists=new ArrayList&lt;&gt;();        while (start*2&lt;col&amp;&amp;start*2&lt;row){            lists.addAll(printMatrixInCircle(numbers,col,row,start));            ++start;        }        return lists;    }    public List&lt;Integer&gt; printMatrixInCircle(int[][] numbers, int col, int row, int start){        int endX=col-1-start;        int endY=row-1-start;        List&lt;Integer&gt; list=new ArrayList&lt;&gt;();        for (int i = start; i &lt;=endX ; i++) {            list.add(numbers[start][i]);        }        if(start&lt;endY){            for (int i = start+1; i &lt;=endY ; i++) {                list.add(numbers[i][endX]);            }        }        if(start&lt;endX&amp;&amp;start&lt;endY){            for (int i = endX-1; i &gt;=start ; i--) {                list.add(numbers[endY][i]);            }        }        if(endY-start&gt;1&amp;&amp;start&lt;endX){            for (int i = endY-1; i &gt;start ; i--) {                list.add(numbers[i][start]);            }        }        return list;    }</code></pre><p>注意行列值的区别，别与坐标系搞混了，emmmmm，这块是个problem。</p><p><strong>下面是用举例来解释思路</strong></p><h2 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30.包含min函数的栈"></a>30.包含min函数的栈</h2><p>题目：<br>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min、push及pop的时间复杂度都是O（1）。</p><p>思路：首先想到每次push进来一个数，就对栈中元素排序，但这样会破坏栈先进后出的结构。<br><strong>用辅助栈：</strong><br>用一个额外的栈来存储最小值，每次push进来一个数，就与辅助栈的栈顶元素相比较，如果这个数更下，就push进辅助栈，如果大，就将辅助栈的栈顶元素再次push辅助栈。</p><img src="/2019/08/05/剑指offer算法题-解题思路篇/3.PNG"><pre><code>public class StackWithMin {    Stack&lt;Integer&gt; data=new Stack&lt;&gt;();    Stack&lt;Integer&gt; min=new Stack&lt;&gt;();    public void stackWithMinPush(int value){        data.push(value);        if(min.size()==0||min.peek()&gt;value){            min.push(value);        }else {            min.push(min.peek());        }    }    public void stackWithMinPop(){        if(data.size()&gt;0&amp;&amp;min.size()&gt;0){            data.pop();            min.pop();        }    }    public int stackWithMinMin(){        if(data.size()&gt;0&amp;&amp;min.size()&gt;0){            return min.peek();        }else {            return -1;        }    }}</code></pre><h2 id="31-栈的压入，弹出序列"><a href="#31-栈的压入，弹出序列" class="headerlink" title="31.栈的压入，弹出序列"></a>31.栈的压入，弹出序列</h2><p>题目: 给定 pushed 和 popped 两个序列，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。<br>示例 1：</p><pre><code>输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]输出：true解释：我们可以按以下顺序执行：push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</code></pre><p>示例 2：</p><pre><code>输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]输出：false解释：1 不能在 2 之前弹出。</code></pre><p>思路：贪心算法,将pushed中元素依次进栈，每次检查栈顶元素是否与popped下一个元素相同，若相同，将栈顶元素出栈同时将popped元素移到下一位进行检查</p><pre><code>public boolean validateStackSequences(int[] pushed, int[] popped) {          if(pushed==null||popped==null||pushed.length!=popped.length){            return false;        }        Stack&lt;Integer&gt; stack=new Stack&lt;&gt;();        int popIndex=0;        for (int i = 0; i &lt;pushed.length ; i++) {            stack.push(pushed[i]);            while (!stack.empty()&amp;&amp;popped[popIndex]==stack.peek())//这里要检查栈是否为空，不然会空指针错误{                popIndex++;                stack.pop();            }        }        return stack.empty();    }</code></pre><h2 id="32-从上往下打印出二叉树"><a href="#32-从上往下打印出二叉树" class="headerlink" title="32.从上往下打印出二叉树"></a>32.从上往下打印出二叉树</h2><h3 id="题目一-从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印"><a href="#题目一-从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印" class="headerlink" title="题目一:从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印"></a>题目一:从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印</h3><p>思路：广度优先遍历，有队列来完成，从队列中取出一个节点遍历他们左右子节点然后放入队列中</p><pre><code> public List&lt;Integer&gt; printFromTopToBottom(TreeNode root) {        if (root == null) {            return new ArrayList&lt;&gt;();        }        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        queue.offer(root);        while (!queue.isEmpty()) {            TreeNode treeNode = queue.poll();            list.add(treeNode.value);            if (treeNode.left != null) {                queue.offer(treeNode.left);            }            if (treeNode.right != null) {                queue.offer(treeNode.right);            }        }        return list;    }</code></pre><p>//注意队列的使用，offer方法以及poll方法。</p><h3 id="题目二：分行从上到下打印二叉树"><a href="#题目二：分行从上到下打印二叉树" class="headerlink" title="题目二：分行从上到下打印二叉树"></a>题目二：分行从上到下打印二叉树</h3><pre><code>    1   / \  2   2 / \ / \3  4 4  3输出：12 23 4 4 3</code></pre><p>思路：在前面题的举出上添加两个变量，一个变量用来保存下一个层有多少个节点，另一个用来保存这一层还有多少个节点没打印。</p><pre><code> public void printFromTopToBottom(TreeNode root) {        if (root == null) {            return;        }        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        queue.offer(root);        int nextLevel=0;        int toBePrint=1;        while (!queue.isEmpty()) {            TreeNode treeNode = queue.poll();            System.out.print(treeNode.value+&quot; &quot;);            if (treeNode.left != null) {                queue.offer(treeNode.left);                nextLevel++;            }            if (treeNode.right != null) {                queue.offer(treeNode.right);                nextLevel++;            }            --toBePrint;            if(toBePrint==0){//这一层打印完，开始一下层                toBePrint=nextLevel;                nextLevel=0;                System.out.print(&quot;\n&quot;);            }        }    }</code></pre><h3 id="题目三：之字形打印二叉树"><a href="#题目三：之字形打印二叉树" class="headerlink" title="题目三：之字形打印二叉树"></a>题目三：之字形打印二叉树</h3><pre><code>    1   / \  2   3 / \ / \4  5 6  7输出：1 3 2 4 5 6 7</code></pre><p>思路：这里需要用来两个栈，当层数为奇数层时（root为第一层），先遍历右节点入栈2，在遍历左节点入栈2，当层数为偶数时，先遍历左节点入栈1，在遍历右节点入栈1。</p><pre><code>public void printFromTopToBottom(TreeNode root) {        if (root == null) {            return;        }        Stack&lt;TreeNode&gt;[] stacks=new Stack[2];        stacks[0]=new Stack&lt;&gt;();        stacks[1]=new Stack&lt;&gt;();//栈的数组需要分别初始化才能使用        int current=1;        stacks[current].push(root);        while (!stacks[1].isEmpty()||!stacks[0].isEmpty()) {            TreeNode treeNode = stacks[current].pop();            System.out.print(treeNode.value+&quot; &quot;);            if(current==1) {                if(treeNode.left!=null){                    stacks[0].push(treeNode.left);                }                if(treeNode.right!=null){                    stacks[0].push(treeNode.right);                }            }            if(current==0){                if(treeNode.right!=null){                    stacks[1].push(treeNode.right);                }                if(treeNode.left!=null){                    stacks[1].push(treeNode.left);                }            }            if(stacks[current].isEmpty()){                current=1-current;            }        }    }</code></pre><h2 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33.二叉搜索树的后序遍历序列"></a>33.二叉搜索树的后序遍历序列</h2><p>题目：输入一个整数数组，判断其是不是一个二叉搜索树的后序遍历序列</p><pre><code>    1   / \  2   3 / \ / \4  5 6  7后序遍历：4,5,2，6,7,3,1</code></pre><p>思路：后序遍历：先遍历左子节点再遍历右子节点，最后遍历根节点<br>整数数组中，最后一个为根节点，先从头遍历数组，当某个数大于根节点时，break，那么后边的数就是树的右子树，前边就是左子树，如果右子树中有比根节点更小的数，那么这棵树就不是二叉搜索树。</p><pre><code>public boolean verifySquenceOfBst(int[] nums,int start,int end){        if(nums==null||nums.length&lt;0){            return false;        }        int i=start;        for(;i&lt;end;i++){            if(nums[i]&gt;nums[end]){                break;            }        }        int j=i;        for (;j&lt;end;j++){            if(nums[j]&lt;nums[end]){                return false;            }        }        boolean left=true;        if(i&gt;start){            left=verifySquenceOfBst(nums,start,i-1) ;        }        boolean right=true;        if(i&lt;end){            right=verifySquenceOfBst(nums,i,end-1);        }        return left&amp;&amp;right;    }</code></pre><h2 id="34-二叉树中和为某一值的路径（难度偏高）"><a href="#34-二叉树中和为某一值的路径（难度偏高）" class="headerlink" title="34.二叉树中和为某一值的路径（难度偏高）"></a>34.二叉树中和为某一值的路径（难度偏高）</h2><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p><pre><code>输入：    1   / \  3   2 / \ / \4  5 6  7        7输出：[1,3,5][1,2,6]</code></pre><p>思路：深度优先搜索，遍历每条到叶节点的路径，跟前序遍历相似，前序遍历本身就是深度搜索，这里没有用到栈，因为树的节点数确定，只需按照左右节点遍历下去就行</p><pre><code>public List&lt;List&lt;Integer&gt;&gt; findPath(TreeNode root, int expectedSum) {        List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();        List&lt;Integer&gt; path = new ArrayList&lt;&gt;();        if(root == null)            return lists;        hasPathSum(root,expectedSum,path,lists);        return lists;    }    public void hasPathSum(TreeNode root, int expectedSum,List&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; lists){        if(root==null){            return;        }        path.add(root.value);        int target=expectedSum-root.value;        boolean isLeaf=(root.left==null&amp;&amp;root.right==null);        if(isLeaf&amp;&amp;target==0){            List&lt;Integer&gt; p=new ArrayList&lt;&gt;(path);//复制path            lists.add(p);        }        if(root.left!=null){            hasPathSum(root.left,target,path,lists);            path.remove(path.size()-1);//每次遍历一个节点后，需要将它删除，才能回到上一个节点        }        if (root.right != null) {            hasPathSum(root.right,target,path,lists);            path.remove(path.size()-1);        }    }</code></pre><p>当到达目标值时，需要复制整条路径，而不是将原来的路径加入lists，因为path时引用变量，接下来path的改变会导致lists中path的改变。</p><p><strong>下面主要考察分而治之的思想</strong></p><h2 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35.复杂链表的复制"></a>35.复杂链表的复制</h2><p>题目：实现一个函数复制一个复杂链表，在复杂链表中，除了有一个next指针指向下一个节点，还有一个指针指向随机的一个节点</p><p>思路：如果按常规，复制所有的节点，并把节点的next指向下一个，那么那个随机指针就需要重新遍历节点找到是第几个 O(n2），因为你不知道复制的节点和原来的节点的对应关系，你也可以用哈希表来存储他们之间的映射关系O(n)，用空间换时间。</p><p>最好的方法：</p><ol><li>先复制每一个节点，并按若下图排列,即每个节点后面跟着他的复制节点<img src="/2019/08/05/剑指offer算法题-解题思路篇/4.PNG"></li><li>接下来设置复制的节点的随机指针，即原来的节点的随机指针的下一个<img src="/2019/08/05/剑指offer算法题-解题思路篇/5.PNG"></li><li>最好拆分两个链表，奇数为原始的，偶数为复制后的<img src="/2019/08/05/剑指offer算法题-解题思路篇/6.PNG"></li></ol><pre><code> public ListNode clone(ListNode pHead){        cloneNode(pHead);        connectingSiblingNode(pHead);        return reConnectNodes(pHead);    }    public void cloneNode(ListNode pHead){        ListNode pNode=pHead;        while (pNode!=null){            ListNode pCloned=new ListNode(0);            pCloned.value=pNode.value;            pCloned.next=pNode.next;            pCloned.pSibling=null;            pNode.next=pCloned;            pNode=pCloned.next;        }    }    void connectingSiblingNode(ListNode pHead){        ListNode pNode=pHead;        while (pNode!=null){            ListNode pCloned=pNode.next;            if(pNode.pSibling!=null){                pCloned.pSibling=pNode.pSibling.next;            }            pNode=pCloned.next;        }    }    ListNode reConnectNodes(ListNode pHead){        ListNode pNode=pHead;        ListNode pClonedHead=pHead.next;        while (pNode!=null){            ListNode pCloned=pNode.next;            if(pCloned.next!=null){                pNode.next=pCloned.next;                pCloned.next=pNode.next.next;            }           else {               pNode.next=null;               pCloned.next=null;            }            pNode=pNode.next;        }        return pClonedHead;    }</code></pre><p>三个函数的循环差不多，只是拆分是要注意末尾的处理</p><h2 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36.二叉搜索树与双向链表"></a>36.二叉搜索树与双向链表</h2><p>题目：将一个二叉搜索树转换成一个排序的双向链表,即二叉树的left等于链表的previous，right等于链表中的right</p><img src="/2019/08/05/剑指offer算法题-解题思路篇/7.PNG"><p>思路：用中序遍历，同时设置一个指向上一个遍历的节点的指针，lastNodeInList，遍历当前节点时，将上一个节点的right指向当前节点，并将当前节点的left指向上一个节点，同时lastNodeInList指针指向当前节点</p><pre><code>  public TreeNode convert(TreeNode root){        TreeNode lastNodeInList=null;        lastNodeInList=convertNode(root,lastNodeInList);        TreeNode headNodeInList=lastNodeInList;        while (headNodeInList!=null&amp;&amp;headNodeInList.left!=null){            headNodeInList=headNodeInList.left;        }        return headNodeInList;    }    public TreeNode convertNode(TreeNode root, TreeNode lastNodeInList){        if(root==null){            return null;        }        TreeNode pNode=root;        if(pNode.left!=null){            lastNodeInList= convertNode(pNode.left,lastNodeInList);        }        pNode.left=lastNodeInList;        if(lastNodeInList!=null){            lastNodeInList.right=pNode;        }        lastNodeInList=pNode;        if (pNode.right != null) {            lastNodeInList=convertNode(pNode.right,lastNodeInList);        }        return lastNodeInList;    }</code></pre><h2 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h2><p>这里要补充参数调用时出现的问题，我在写第二个函数时，没有设返回值，以为lastNodeInlist指针改变后不需要返回就可以调用，但其实不是。</p><ol><li>在方法体内对参数进行运算，不会影响原有变量的值（基本类型不会改变值，引用类型不会改变引用地址）。</li><li>在方法体内对参数的属性进行操作，将改变原有变量的属性值（如集合、数组中的元素）</li></ol><p>原因是方法在执行的时候有栈帧的概念，入栈的时候只是压栈方法参数是传入参数的副本。</p><img src="/2019/08/05/剑指offer算法题-解题思路篇/8.PNG"><p>此时区分数据类型：基本类型和引用类型</p><ul><li><p>基本类型：值存放在局部变量表中，无论如何修改只会修改当前栈帧的值，方法执行结束对方法外不会做任何改变；此时需要改变外层的变量，必须返回主动赋值。</p></li><li><p>引用数据类型：指针存放在局部变量表中，调用方法的时候，副本引用压栈，赋值仅改变副本的引用。但是如果直接改变副本引用的值，修改了引用地址的对象，此时方法以外的引用此地址对象当然被修改。（两个引用，同一个地址，任何修改行为2个引用同时生效）</p></li></ul><p>关于String，本质是final类型char数组，不可修改，只能赋值，在做参数传入方法修改时，其实是新建对象，必须返回重新对外面的变量赋值才会对外面的String引用生效。String不是引用传递</p><p>String源码</p><pre><code> public String replace(char oldChar, char newChar) {        if (oldChar != newChar) {            int len = value.length;            int i = -1;            char[] val = value; /* avoid getfield opcode */            while (++i &lt; len) {                if (val[i] == oldChar) {                    break;                }            }            if (i &lt; len) {                char buf[] = new char[len];                for (int j = 0; j &lt; i; j++) {                    buf[j] = val[j];                }                while (i &lt; len) {                    char c = val[i];                    buf[i] = (c == oldChar) ? newChar : c;                    i++;                }                //String的value 是final char[]，一旦创建不能改变                return new String(buf, true);            }        }        return this;</code></pre><h2 id="37-序列化二叉树"><a href="#37-序列化二叉树" class="headerlink" title="37.序列化二叉树"></a>37.序列化二叉树</h2><p>题目：实现两个函数，分别用来序列化和反序列化二叉树</p><ul><li><p>二叉树序列化（持久化）<br>  二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。<br>  序列化可以基于 先序、中序、后序、按层 的二叉树遍历方式来进行修改。原理都是一样的（即遍历顺序不同而已，对每个结点的处理都是一样的），序列化的结果是一个字符串，序列化时通过  某种符号表示空节点（$），以, 表示一个结点值的结束（value!）。</p></li><li><p>二叉树的反序列化</p><p>  二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树</p></li></ul><p>思路：都才用前序遍历，并用StringBuilder保存序列化结果</p><pre><code> public String serialize(TreeNode root) {        StringBuilder str = new StringBuilder();        serializeCore(root, str);        return str.toString();    }    public void serializeCore(TreeNode root, StringBuilder str) {        if (root == null) {            str.append(&quot;$,&quot;);        } else {            str.append(root.value + &quot;,&quot;);            serializeCore(root.left, str);            serializeCore(root.right, str);        }    }    public TreeNode deSerialize(String str) {        if (str == null &amp;&amp; str.length() &lt;= 0) {            return null;        }        String[] strs = str.split(&quot;,&quot;);        return deSerializeCore(strs);    }    int index = 0;//用于递归调用中strs下标的变化    TreeNode deSerializeCore(String[] strs) {        if (&quot;$&quot;.equals(strs[index])) {            index++;            return null;        }        TreeNode root = new TreeNode(Integer.valueOf(strs[index]));        index++;        root.left = deSerializeCore(strs);        root.right = deSerializeCore(strs);        return root;    }</code></pre><h2 id="38-字符串的排列与组合"><a href="#38-字符串的排列与组合" class="headerlink" title="38.字符串的排列与组合"></a>38.字符串的排列与组合</h2><h3 id="题目一：输入一个字符串，打印出该字符串的所有排列。"><a href="#题目一：输入一个字符串，打印出该字符串的所有排列。" class="headerlink" title="题目一：输入一个字符串，打印出该字符串的所有排列。"></a>题目一：输入一个字符串，打印出该字符串的所有排列。</h3><pre><code>输入 &quot;abc&quot;输出 abc acb bac bca cab cba</code></pre><p>思路：每次从中取一个字符，与第一个字符交换，然后把字符串分为两部分，一部分是第一个字符，另一部分是后面的字符，然后后面的字符进行排列，依次递归。</p><pre><code> public void permutation(char[] str) {        if (str == null || str.length == 0) {            return;        }        permutationCore(str, 0);    }    public void permutationCore(char[] str, int begin) {        if (begin == str.length-1) {//当begin等于最后一个数时才能输出，即一次排列进行到了最后一个数            System.out.println(str);        } else {            for (int i = begin; i &lt; str.length; i++) {                swap(str, begin, i);                permutationCore(str, begin + 1);                swap(str, i, begin);//因为是在原字符串上操作，所有一次排列完成后，必须恢复原样，才能进行下一次排列            }        }    }    public void swap(char[] str, int index1, int index2) {        char temp = str[index1];        str[index1] = str[index2];        str[index2] = temp;    }</code></pre><h3 id="题目二：输入一个字符串，打印该字符的所有组合"><a href="#题目二：输入一个字符串，打印该字符的所有组合" class="headerlink" title="题目二：输入一个字符串，打印该字符的所有组合"></a>题目二：输入一个字符串，打印该字符的所有组合</h3><pre><code>输入 &quot;abc&quot;输出 abc ab ac bc a b c</code></pre><p>思路：输入n个字符，如果要从中取m个数，我们把这n个字符分成两部分，一部分是第一个字符，另一部分是后面的字符，如果取第一个字符，接下来就从n-1个字符中取m-1个，如果不去第一个字符，接下来就从n-1个字符中取m个字符。依次递归</p><pre><code>public void combine(char[] str) {        if (str == null || str.length == 0) {            return;        }        List&lt;Character&gt; result=new ArrayList&lt;&gt;();        for (int n = 1; n &lt;=str.length ; n++) {            combineCore(str, 0,n,result);        }    }    public void combineCore(char[] str,int begin, int n,List&lt;Character&gt; result) {        if(n==0){            System.out.println(result.toString());            return;//当n=0时才能输出        }        if(begin==str.length){            return;//n！=0然而begin到末尾了，这时舍弃result        }else {            result.add(str[begin]);//选第一个数            combineCore(str, begin + 1, n - 1, result);            result.remove(result.size() - 1);//不选第一个数            combineCore(str, begin + 1, n, result);        }    }</code></pre><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>解决复杂问题的三种办法：<strong>画图，举例，分解</strong></p><ul><li>图形能使抽象的问题形象化，针对链表和二叉树有很好的效果</li><li>举例能使问题具体化，很多算法问题都很抽象，使用举例来寻找他们之间的规律</li><li>复杂问题分解成许多小问题，分治法，动态规划，贪心等方法都应用了这种思路</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM</title>
      <link href="/2019/08/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/"/>
      <url>/2019/08/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/</url>
      
        <content type="html"><![CDATA[<h1 id="《深入理解java虚拟机》精华总结"><a href="#《深入理解java虚拟机》精华总结" class="headerlink" title="《深入理解java虚拟机》精华总结"></a>《深入理解java虚拟机》精华总结</h1><a id="more"></a><h2 id="1-java虚拟机运行时数据区域"><a href="#1-java虚拟机运行时数据区域" class="headerlink" title="1.java虚拟机运行时数据区域"></a>1.java虚拟机运行时数据区域</h2><p>java虚拟就在执行java程序时会将他所管理的内存划分为若干个不同的数据区域</p><img src="/2019/08/02/深入理解JVM/1.jpg" title="[]"><p>方法区和堆时线程共享的数据区，其他的不是</p><p>heap区：Eden Space，survivor Space：幸存者区 Tenured Gen：老年代<br>非heap区： Perm Gen:永久代，也就是方法区</p><h3 id="1-1-程序计数器："><a href="#1-1-程序计数器：" class="headerlink" title="1.1 程序计数器："></a>1.1 程序计数器：</h3><p>&#160; &#160;一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器，在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选择下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都依赖它来实现。每个线程都有独立的程序计数器，如果线程执行的是java方法，则计数器记录的是字节码指令的地址，如果是Native方法，则为空，此内存是唯一没有规定任何OutOfMemoryError情况的区域</p><h3 id="1-2-Java虚拟机栈"><a href="#1-2-Java虚拟机栈" class="headerlink" title="1.2 Java虚拟机栈"></a>1.2 Java虚拟机栈</h3><p>&emsp;虚拟机栈描述的是java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口灯信息。每个方法从执行到结束，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。<br>&#8195;经常有人把java内存分为栈内存和堆内存（不知道是否正确），栈内存就指的是虚拟机栈，或者说是虚拟机栈中局部变量表的部分，堆内存后面会讲。<br>&emsp;局部变量表存放了编译期所知的基本数据类型，对象引用类型和returnAddress（指向一条字节码指令的地址）其中64位的double和float占据两个局部变量空间，其余的数据类型占据一个。</p><p>这个区域规定了两个异常状况：</p><ol><li>StackOverflowError：当线程所申请的栈深度大于虚拟机所允许的深度</li><li>OutOfMemoryError：如果虚假机栈可以动态扩展，扩展时无法申请到足够的内存        </li></ol><h3 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3 本地方法栈"></a>1.3 本地方法栈</h3><p>与java虚拟机栈类似，只不过是java虚拟机栈为虚拟机执行java方法（也就是字节码服务），而本地方法栈则为虚拟机执行Native方法，也会存在虚拟机栈出现的两种异常状况</p><h3 id="1-4-Java堆"><a href="#1-4-Java堆" class="headerlink" title="1.4 Java堆"></a>1.4 Java堆</h3><p>&emsp;Java堆时java虚拟机所管理的内存最大的一块，此区域的唯一目的就是存放对象实例。<br>&emsp;Java堆时垃圾收集器管理的主要区域，（GC堆），现在收集器基本都用分带收集算法，所以java堆可以细分为新生代和老年带，划分的目的都是为了更好的回收内存或者更快的分配内存。如果堆中没有内存完成对象实例分配，并且对也无法扩展，会抛出OutOfMemory异常。</p><h3 id="1-5-方法区"><a href="#1-5-方法区" class="headerlink" title="1.5 方法区"></a>1.5 方法区</h3><p>&emsp;用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译期编译后的代码等数据，他是堆的逻辑部分，也被人称为永久代。<br>&emsp;除了Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载<br>&emsp;当方法区无法满足内存分配需求时，将抛出OutOfMemoryErroy异常<br>log</p><h3 id="1-6-运行时常量池"><a href="#1-6-运行时常量池" class="headerlink" title="1.6 运行时常量池"></a>1.6 运行时常量池</h3><p>&emsp;是方法区的一部分。class文件中除了包含类的版本，字段，方法，接口等描述信息，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。<br>&emsp;运行时常量池对于class文件常量池最重要的特是具备动态性，java并不要求常量一定只有编译期才能产生，运行时也可能将新的常量放入池中。String的intern（）方法。<br>&emsp;也会产生OutOfMemoryError异常</p><h3 id="1-7-直接内存"><a href="#1-7-直接内存" class="headerlink" title="1.7 直接内存"></a>1.7 直接内存</h3><p>此区域并不是虚拟机运行时数据区的一部分，但是这部分区域也被频繁使用，也存在OutOfMemory异常，显然，本机直接内存的分配不会受到java对大小的限制，但会受到本机总内存大小以及处理器寻址空间的限制。</p><h2 id="2-HotSpot虚拟机对象探秘"><a href="#2-HotSpot虚拟机对象探秘" class="headerlink" title="2.HotSpot虚拟机对象探秘"></a>2.HotSpot虚拟机对象探秘</h2><h3 id="2-1对象的创建"><a href="#2-1对象的创建" class="headerlink" title="2.1对象的创建"></a>2.1对象的创建</h3><ol><li><p>检查<br>在语言层面上，创建对象仅仅是用new关键字，当虚拟机遇到new指令时，首先将去常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否被加载，解析和初始化过。如果没有，将执行类加载过程（后面会讲）</p></li><li><p>分配内存<br>把一块确定大小的内存从java堆中划分出来，有两种内存分配方式</p><ul><li><p>指针碰撞：<br>假设java堆中内存是绝对规整的，用过的内存在一边，闲置的在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅把那个指针向空闲内存方向移动与对象大小相同的距离。</p></li><li><p>空闲列表：<br>如果java堆中的内存不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法进行简单的指针碰撞，虚拟机就必须维护一个列表，记录上哪些内存是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象，并更新列表</p><p>选择哪种方式由java堆是否规整决定，java堆是否规整又取决于所采用的垃圾收集器是否带有压缩整理功能决定</p></li></ul></li><li><p>init<br>内存分配完成后，虚拟机将分配到的内存空间都初始化为零值，执行new指令后接着执行(init)方法,把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来</p></li></ol><h3 id="2-2对象的内存布局"><a href="#2-2对象的内存布局" class="headerlink" title="2.2对象的内存布局"></a>2.2对象的内存布局</h3><p>分为三个区域：对象头header，实例数据instance data，对齐填充 Padding</p><h4 id="对象头："><a href="#对象头：" class="headerlink" title="对象头："></a>对象头：</h4><p>包括两部分信息</p><ul><li>第一部分用于储存对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程id，偏向时间戳等。</li><li>另一部分用时类型指针，即对象指向他的类元数据的指针，虚拟机通过这个指针来确定他是哪个对象的实例</li></ul><h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>是对象真正存储的有效信息，是在程序代码中所定义的各种类型的字段内容。</p><h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><p>没有特别的含义，仅仅起到占位符的作用，Hotspot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍</p><h3 id="2-3对象的访问定位"><a href="#2-3对象的访问定位" class="headerlink" title="2.3对象的访问定位"></a>2.3对象的访问定位</h3><p>建立对象是为了使用对象，java程序需要通过java虚拟机栈的引用数据（reference）来操作堆上的及具体对象，堆上的具体对象又要到方法区找到对象的类型数据。有两个方法定义这个引用通过何种方式去定位</p><ul><li>句柄访问<br>从java堆中划分一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址</li><li>使用直接指针访问<img src="/2019/08/02/深入理解JVM/2.png" title="[]"></li></ul><p>两种方法各有优势：<br>使用句柄的优势在于当对象被移动时，（垃圾收集时会频繁的移动对象），只会改变句柄中的实例数据指针，而reference不需要改变<br>使用直接指针，最大好处就是速度快，节省了时间开销，Hotspot就是用的这种方式</p><h3 id="3-OutOfMemory异常"><a href="#3-OutOfMemory异常" class="headerlink" title="3.OutOfMemory异常"></a>3.OutOfMemory异常</h3><h4 id="3-1-Java堆溢出"><a href="#3-1-Java堆溢出" class="headerlink" title="3.1 Java堆溢出"></a>3.1 Java堆溢出</h4><p>Java堆用于存储对象实例，只要不断的创建对象，并且保证GCRoots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在数量到达最大堆的容量限制后就会产生内存溢出异常</p><p>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置</p><p>如果不存在泄露，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗</p><h4 id="3-2-虚拟机栈和本地方法栈溢出"><a href="#3-2-虚拟机栈和本地方法栈溢出" class="headerlink" title="3.2 虚拟机栈和本地方法栈溢出"></a>3.2 虚拟机栈和本地方法栈溢出</h4><p>Hotspot不区分虚拟机栈和本地方法栈，对于HotSpot来说，虽然-Xoss参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由-Xss参数设定。关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：</p><p>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError</p><p>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常</p><p>在单线程下，无论由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常</p><p>如果是多线程导致的内存溢出，与栈空间是否足够大并不存在任何联系，这个时候每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。解决的时候是在不能减少线程数或更换64为的虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程</p><h4 id="3-3-方法区和运行时常量池溢出"><a href="#3-3-方法区和运行时常量池溢出" class="headerlink" title="3.3 方法区和运行时常量池溢出"></a>3.3 方法区和运行时常量池溢出</h4><p>方法区的大小通过-PermSize和-MaxPermSize控制。<br>String.intern()是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用</p><p>由于常量池分配在永久代中，可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小，从而间接限制其中常量池的容量。</p><ul><li><p>Intern():</p><p> JDK1.6 intern方法：如果常量池中已经包含了此string对象的字符串，则返回它，否则，则将此string对象包含的字符串添加到常量池中</p></li></ul><h2 id="4-垃圾收集"><a href="#4-垃圾收集" class="headerlink" title="4.垃圾收集"></a>4.垃圾收集</h2><p>虚拟机栈，本地方法栈，程序计数器随线程而生，随线程而灭，这几个区域内就不需要过多考虑回收问题</p><h3 id="4-1如何确定对象的“存活”"><a href="#4-1如何确定对象的“存活”" class="headerlink" title="4.1如何确定对象的“存活”"></a>4.1如何确定对象的“存活”</h3><ol><li>引用计数算法<br>给对象添加一个引用计数器，如果它被引用，就+1，引用失效就-1，任何时候计数器为0就是不可能再被使用.<br>然而假设有两个对象相互被引用（即循环），用引用计数器算法无法通知GC收集器回收他们，实际上这两个对象已经不可能被访问了，这也从侧面说明了java虚拟机并不是靠这种算法来判断对象是否存活。</li><li>可达性分析算法<br>通过一系列的成为”GC ROOT”的对象作为起始点，从这些节点开始向下搜索，搜索通过的路径成为引用链（reference chain），当一个对象没有任何引用链相连，那么它就是不可用的。<br>什么可以称之为GC root<ol><li>虚拟机栈中的局部变量表</li><li>方法区中的静态成员</li><li>方法区中的常量引用的对象</li><li>本地方法栈中JNI引用的对象</li></ol></li></ol><h3 id="4-2-引用"><a href="#4-2-引用" class="headerlink" title="4.2 引用"></a>4.2 引用</h3><p>JDK1.2 之前，引用定义为如果reference类型的数据中存储的数值代表另外一块内存的起始地址，则代表引用。这种定义很纯粹，太过狭隘。<br>JDK1.2之后，将引用分为四种，4中引用强度依次减弱</p><ol><li>强引用<br>类似<em>Object obj=new Object()</em>,只要强引用一直在，垃圾收集器永远不会回收掉被引用的对象。</li><li>软引用<br>用于描述一些还有用但非必需的对象，在系统将要发生内存溢出异常之前，将会把这些对象列为回收范围之中进行第二次回收，如果回收之后内存还是不够，才会抛出内存溢出异常。</li><li>弱引用<br>用于描述非必需对象，当垃圾收集器开始工作时，无论内存是否溢出，都会回收这类对象</li><li>虚引用<br>唯一目的就是这个对象在被垃圾收集器回收时会收到一个通知。</li></ol><h3 id="4-3-finalize方法"><a href="#4-3-finalize方法" class="headerlink" title="4.3 finalize方法"></a>4.3 finalize方法</h3><p>即便是在可达性分析算法中不可达的对象，也并非”非死不可”，真正宣告一个对象的死亡，需要经过两次标记过程。</p><ul><li>第一次标记：对象进行可达性分析后，没有与GC root的引用链相连的对象，将会被第一次标记并进行一次筛选，来判断他是否有必要执行finalize方法<br>筛选条件：如果对象没有覆盖finalize方法或者虚拟机已经调用了它的finalize方法，它就没必要执行下一步。</li><li>第二次标记：这时对象被判定为需要执行finalize方法，并被放置在一个叫 F-Queue的队列中，finalize方法是对象逃脱死亡的最好一次方法，稍后Gc会对队列中的对象进行第二次标记，如果对象此时重新与GC引用链连接上，那么它就会被移出“即将回收”的集合。</li></ul><h3 id="4-4-回收方法区"><a href="#4-4-回收方法区" class="headerlink" title="4.4 回收方法区"></a>4.4 回收方法区</h3><p>方法区（HotSpot虚拟机中的永久代），java虚拟机规范并不要去在方法区中实现垃圾收集，因为性价比很低，。<br>主要回收两部分内容：</p><ul><li>常量：与java对象非常类似，如果它没有被引用，就会被回收</li><li>无用的类：判断一个类是否无用比较复杂：<ol><li>该类的所有实例已被回收</li><li>加载该类的classloder已经被回收</li><li>该类对应的java.lang.class没有在任何地方被引用，无法在任何地方通过反射来访问该类的方法。</li></ol></li></ul><h3 id="4-4-垃圾收集算法"><a href="#4-4-垃圾收集算法" class="headerlink" title="4.4 垃圾收集算法"></a>4.4 垃圾收集算法</h3><ol><li><p>标记-清除算法：<br>算法分为标记和清除两个阶段:首先标记所有需要回收的对象，在标记 完成后统一回收所有对象<br>主要不足有两个：</p><ul><li>效率低：标记和清除两个效率都不高</li><li>空间问题：标记清除后产生大量不连续的内存碎片，导致在分配较大对象时，无法找到足够连续内存而引起又一次的垃圾收集</li></ul></li><li><p>复制算法<br>为了解决标记清除算法的效率问题，他将可用内存按照容量划分为大小相等的两块，每次只使用其中的一块。当这块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可<br>不足：</p><ul><li>将内存缩小为了原来的一半<br>实际中我们并不需要按照1:1比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor<br>当另一个Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代</li></ul></li><li><p>标记-整理算法<br>复制收集算法在对象存活率较高时效率较低，还需要额外的空间进行分配担保。<br>标记整理算法的过程仍然和标记清除算法一样，只是在标记完成后，现将对象往一端移动，然后直接清理掉边界以外的内存</p></li><li><p>分代收集算法<br>新生代就用复制算法，因为他们“朝生夕死”，老年代就用标记整理或者标记清除算法。</p></li></ol><h3 id="4-5-垃圾收集器"><a href="#4-5-垃圾收集器" class="headerlink" title="4.5 垃圾收集器"></a>4.5 垃圾收集器</h3><p>收集算法是对内存回收的方法论，垃圾收集器就是内存回收的具体实现</p><img src="/2019/08/02/深入理解JVM/3.PNG"><ol><li><p>Serial收集器<br>单线程收集器，不仅仅使用一个cpu和一个线程去完成垃圾收集工作，更重要的是他会暂停所有用户线程，知道它收集完成。</p></li><li><p>Parnew收集器<br>serial收集器的多线程版本，除了使用多线程进行垃圾收集，其它的和serial收集器一样</p></li><li><p>Paraller Scavenge收集器<br>它也是使用复制算法的收集器，，又是并行的多线程处理器，它与parnew收集器的关注点不同，CMS等收集器的关注点是尽可能的缩短垃圾收集时用户线程的停顿时间，而paraller scavenge目的是达到一个可控的吞吐量（throughput)</p><ul><li>吞吐量=（运行用户代码时间）/（运行用户代码时间+垃圾收集时间）</li></ul></li><li><p>Serial Old收集器<br>serial收集器的老年代版本，同样是一个单线程收集器，使用标记-整理算法，</p></li><li><p>paraller old收集器<br>paraller scavenge收集器的老年代版本，使用多线程和标记-整理算法，</p></li><li><p>CMS收集器<br>是一种以获取最短回收停顿时间为目标的收集器，基于标记-清除算法实现的，它分为四个步骤：</p><ol><li>初始标记：标记一下GC root能关联到的对象</li><li>并发标记： GC root tracing的过程</li><li>重新标记： 修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</li><li>并发清理</li></ol><p>优点:并发收集，低停顿<br>缺点：</p><ol><li>CMS收集器对CPU资源非常敏感，CMS默认启动的回收线程数是（CPU数量+3）/4，</li><li>CMS收集器无法处理浮动垃圾，可能出现Failure失败而导致一次Full GC的产生</li><li>CMS是基于标记清除算法实现的</li></ol></li><li><p>G1收集器<br>面向服务器应用的垃圾收集器</p><ol><li>并行与并发：使用多个cpu来缩短stop-the-world停顿的时间</li><li>分代收集</li><li>空间整合，不会产生内存碎片</li><li>可预测的停顿：能让使用者明确指定在一个长度为M毫秒的时间片段上，消耗在垃圾收集上的时间不得超过n毫秒</li></ol><p>运行方式：初始标记，并发标记，最终标记，筛选标记</p></li></ol><h3 id="4-6-jvm中的新生代Eden和survivor区"><a href="#4-6-jvm中的新生代Eden和survivor区" class="headerlink" title="4.6 jvm中的新生代Eden和survivor区"></a>4.6 jvm中的新生代Eden和survivor区</h3><img src="/2019/08/02/深入理解JVM/9.PNG"><p>jvm将年轻代中的分为了三个部分：Eden和两个survivor区域（分为称为from和to），默认比例为8:1，新创建的对象会被分配到eden区域，经过一次GC后，如果还会存活，将会被移动到from区域，to区域是空的，而在from区域，会根据他们的年龄判断他们的走向，年龄达到阈值的进入老年代，没有达到的将会进入to区域，这时from和eden区域就都是空的了，然后from和to交换角色，来保证to区域永远是空的，直到to区域全部被填满，那么其中所有的对象都会进入老年代</p><img src="/2019/08/02/深入理解JVM/4.png"><h2 id="5-内存分配与回收策略"><a href="#5-内存分配与回收策略" class="headerlink" title="5.内存分配与回收策略"></a>5.内存分配与回收策略</h2><ul><li><strong>对象优先在eden区中分配，当eden可用区域不充足时，会发生minorGC</strong></li><li>大对象直接进入老年代，所谓大对象就是指大量连续内存空间的java对象，</li><li>长期存活的对象进入老年代，每个对象有一个年龄计数器，没熬过一个minorGC 就会涨一岁，当达到阈值就会进入老年代</li><li>动态对象年龄判断：并不要求对象年龄达到阈值，而是当survivor空间中相同年龄所有对象的个数大于survivor空间的一半，那么年龄大于或等于该年龄的就会直接进入老年代</li><li>空间分配担保：<ol><li>发生minorGC前，会检查老年代可用空间是否大于新生代总空间。成立，minor gc安全。</li><li>不成立，会查看HandlePromotionFailure设置是否允许担保失败。<strong>如果不允许，将会进行full gc</strong></li><li>如果允许，那么继续检查老年代可用空间是否大于历次晋升到老年代对象的平均大小。</li><li><strong>如果大于，那么尝试进行有风险的minor gc，因为如果这次对象较多，survivor区域无法容纳，就需要老年代进行担保，如果老年代也无法容纳就会在失败后发生full gc</strong></li></ol></li></ul><h2 id="6-0虚拟机类加载机制"><a href="#6-0虚拟机类加载机制" class="headerlink" title="6.0虚拟机类加载机制"></a>6.0虚拟机类加载机制</h2><p>虚拟机把描述类的class文件加载到内存，然后经过校验，解析和初始化转换为虚拟机可用的java类型，就是类加载机制。</p><img src="/2019/08/02/深入理解JVM/5.PNG"><p>类型的加载，连接和初始化都是在程序运行时完成的</p><h3 id="6-1-什么时候开始进行类加载"><a href="#6-1-什么时候开始进行类加载" class="headerlink" title="6.1 什么时候开始进行类加载"></a>6.1 什么时候开始进行类加载</h3><ol><li>new:遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候</li><li>反射:使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始</li><li>用到父类：当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</li><li>main方法：当虚拟机启动时候，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类</li><li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化</li></ol><p>上述五种称为主动引用，下面三种被动引用，不会触发类的初始化</p><ol><li>子类引用父类的静态字段</li><li>通过数组来定义类：SuperClass[] sca =new SuperClass[10]</li><li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</li></ol><p>接口与类的加载不同：当类初始化时，要求父类都已初始化了，当接口初始化时，只有用到父类的地方（如接口中的常量）才会进行初始化。</p><h3 id="6-2-类加载的过程"><a href="#6-2-类加载的过程" class="headerlink" title="6.2 类加载的过程"></a>6.2 类加载的过程</h3><ol><li>加载：加载是类加载的一个阶段，在加载阶段，需要完成以下三个事情<ul><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换成方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.class对象，作为方法区这个类的各种数据入口</li></ul></li><li>验证：验证是连接阶段的第一步，这一阶段的目的是为了确保class文件的字节流符合当前虚拟机的要求<ul><li>文件格式验证</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ul></li><li>准备：正式为类变量分配内存并设置初始值的阶段，初始值一般是0，但当变量是final类型是，将直接设置为用户自定义变量</li><li>解析：虚拟机将常量池中的符号引用转换为直接引用<ul><li>符号引用：用一组符号来描述所引用的目标，字面量</li><li>直接引用：直接指向目标的指针，相对偏移量，或是一个能直接定位到目标的句柄</li></ul></li><li>初始化：根据程序员的主观计划去初始化类变量和其他资源，如定义变量的值，因为初始值是0。初始化是执行类构造器<clinit>()方法的过程。<ul><li><clinit>方法是由编译期自动收集类中的复制动作和静态语句块而产生的。</clinit></li></ul></clinit></li></ol><h3 id="6-4-类加载器"><a href="#6-4-类加载器" class="headerlink" title="6.4 类加载器"></a>6.4 类加载器</h3><p>根据指定名称将class文件加载到jvm内存，转换为class对象，这就是类加载器的职责。分为两种：</p><ul><li>启动类加载器：由C++语言实现（针对HotSpot）,负责将存放在<java_home>\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中。</java_home></li><li>其他类加载器：有java语言实现，继承自抽象类classloader<ul><li>扩展类加载器（Extension ClassLoader）：负责加载<java_home>\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库。</java_home></li><li>应用程序类加载器（Application ClassLoader）：负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。<h4 id="6-4-1-类与类加载器"><a href="#6-4-1-类与类加载器" class="headerlink" title="6.4.1 类与类加载器"></a>6.4.1 类与类加载器</h4>判断两个类是否来源于同一class文件，是根据加载他们的类加载器来的，即使一个class文件被不同类加载器加载，生成的class对象是不同的。这里的相同包括代表类对象的equals方法，isAssignableFrom方法，isInstance方法。<h4 id="6-4-2-双亲委派模型"><a href="#6-4-2-双亲委派模型" class="headerlink" title="6.4.2 双亲委派模型"></a>6.4.2 双亲委派模型</h4><img src="/2019/08/02/深入理解JVM/6.PNG"></li></ul></li><li>层次关系：要求除了顶层类加载器，其它类加载器都要有自己的父加载器，这种父子关系并不是通过继承去实现的，而是通过组合去实现的。</li><li>工作机制：当一个类加载器收到加载类的请求，它首先不会自己去加载，而是将这个请求委派给父加载器，每一层次都是如此，因此所有请求都会最终到达顶层的启动类加载器，只有父加载器反馈自己不能加载时，子类才会尝试自己去加载。</li><li>好处：java类随着他们的类加载器一起具备了一种层级关系。<img src="/2019/08/02/深入理解JVM/7.PNG"><h4 id="6-4-3-破坏双亲委派模型"><a href="#6-4-3-破坏双亲委派模型" class="headerlink" title="6.4.3 破坏双亲委派模型"></a>6.4.3 破坏双亲委派模型</h4>双亲委派模型并不是一种强制性约束，而是一种推荐的类加载器的实现方式。</li></ul><ol><li>自定义类加载器，重写loadClass方法；</li><li>使用线程上下文类加载器；</li></ol><h2 id="7-0-java内存模型"><a href="#7-0-java内存模型" class="headerlink" title="7.0 java内存模型"></a>7.0 java内存模型</h2><p>java内存模型用来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的内存访问效果。</p><ul><li>主要目标:定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出这样的底层细节。这里的变量包括静态字段，实例字段和构成数组对象的元素，但不包括局部变量和方法参数（线程私有）。</li></ul><img src="/2019/08/02/深入理解JVM/8.PNG"><p>java内存模型规定了所有变量都存储在主内存中，而线程的工作内存保存了被该线程所用到的变量的主内存副本拷贝。线程间变量值的传递均需要通过主内存来完成。</p><h3 id="7-1-内存间的相互操作"><a href="#7-1-内存间的相互操作" class="headerlink" title="7.1 内存间的相互操作"></a>7.1 内存间的相互操作</h3><p>关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：</p><p>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</p><p>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p><p>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</p><p>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</p><p>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</p><p>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p><p>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</p><p>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</p><p>Java内存模型还规定了在执行上述八种基本操作时，还定义了一些规则，这里不再阐述。</p><h3 id="7-2-volatile型变量"><a href="#7-2-volatile型变量" class="headerlink" title="7.2 volatile型变量"></a>7.2 volatile型变量</h3><blockquote><p>重排序： 在执行程序时，编译期和处理器为了提高程序性能，经常会对指令进行重排序。重排序分为三种</p><ul><li>编译器优化的重排序，在不改变单线程语义的情况下重新安排语句的执行顺序</li><li>指令级并行的顺序，现代处理器采用指令级并行技术来将多条指令重叠执行。如果不在数据依赖性，就可以改变指令执行的顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读写缓冲区，这看起来加载和存储操作像是在乱序执行。<br>为了保证内存的可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。Java内存模型把内存屏障分为LoadLoad、LoadStore、StoreLoad和StoreStore四种。</li></ul></blockquote><p>当一个变量被定义为valatile型时，他具有以下两种特性</p><ol><li>保证他对所有线程的可见性，这里的可见性是指当一条线程改变了这个变量的值，那么对于其他线程来说是可以立即得知的。<br>由于volatile只能保证可见性，在不符合以下两个场景时，仍然需要加锁来保证原子性：<ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li><li>变量不需要与其他的状态变量共同参与不变约束</li></ul></li><li>禁止指令重排序：普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中执行顺序一致，这个就是所谓的线程内表现为串行的语义</li></ol><h3 id="7-3-对于long和double型变量的特殊规则"><a href="#7-3-对于long和double型变量的特殊规则" class="headerlink" title="7.3 对于long和double型变量的特殊规则"></a>7.3 对于long和double型变量的特殊规则</h3><p>java内存模型要求对于8个操作都要具有原子性，但对于64位的：允许虚拟机将没有被volatile修饰的64位数据的读写操作分为32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这4个操作的原子性。</p><h3 id="7-4-java内存模型的特性"><a href="#7-4-java内存模型的特性" class="headerlink" title="7.4 java内存模型的特性"></a>7.4 java内存模型的特性</h3><ol><li>原子性：一组操作要么全部成功，要么全部失败。由java内存模型保证的原子性变量操作有：read ，load，assign，use，store，write。如果需要更大范围的原子性操作，就可以用lock与unlock操作，反应到java代码中就是同步代码块-synchronized。</li><li>可见性：当一个线程修改了变量的值，其他线程能够立即的得知这个修改。java内存模型是通过在变量修改后将新值同步到主内存中，在变量读取前刷新变量值来这种依赖主内存做传播媒介的方式来实现可见性的。除volatile之外，还有两个关键字能实现可见性：synchronized和final。final的可见性是指：被final修饰的字段在构造器中一旦初始化完成，那么无需同步就可以被其他线程正确访问。</li><li>有序性：两个方面：volatile禁止指令重排序，synchronized保证持有同一个锁的两个同步代码块只能串行进入。</li></ol><h3 id="7-5-先行发生原则"><a href="#7-5-先行发生原则" class="headerlink" title="7.5 先行发生原则"></a>7.5 先行发生原则</h3><p>这些先行原则无需同步就已经存在了，如果不在这些原则中就不能保证顺序性，虚拟机就可以对他们进行重排序了</p><ol><li><p>程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确的说，应该是控制顺序而不是程序代码顺序，因为要考虑分支。循环等结构</p></li><li><p>管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而后面的是指时间上的先后顺序</p></li><li><p>Volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的后面同样是指时间上的先后顺序</p></li><li><p>线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作</p></li><li><p>线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、ThradisAlive()的返回值等手段检测到线程已经终止执行</p></li><li><p>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断时间的发生，可以通过Thread.interrupted()方法检测到是否有中断发生</p></li><li><p>对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始</p></li><li><p>传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论</p></li></ol><h2 id="8-0-线程"><a href="#8-0-线程" class="headerlink" title="8.0 线程"></a>8.0 线程</h2><p>并发并不一定依赖多线程。</p><h3 id="8-1-线程的实现"><a href="#8-1-线程的实现" class="headerlink" title="8.1 线程的实现"></a>8.1 线程的实现</h3><p>线程是比进程更轻量级的单位，线程的引入，可以将进程的资源分配和执行调度分开。</p><ol><li>使用内核线程实现：程序一般不会直接去使用内核线程，而是使用内核线程的一种高级接口——轻量级进程，也就是线程。局限性：各种线程操作需要系统调用，系统调用的代价相对较高，需要再用户态和内核态来回切换，其次线程会消耗掉一定的内存资源。</li><li>使用用户线程实现：</li><li>使用前面两种混合实现</li></ol><h3 id="8-2-线程的调度"><a href="#8-2-线程的调度" class="headerlink" title="8.2 线程的调度"></a>8.2 线程的调度</h3><p>主要的调度方式有两种：协同式和抢占式</p><ul><li><p>协同式调度：线程的执行时间由线程本身控制</p></li><li><p>抢占式调度：线程的执行时间由系统来分配<br>java使用的是抢占式。<br>java有十个优先级，</p></li></ul><h3 id="8-3-线程的状态转换"><a href="#8-3-线程的状态转换" class="headerlink" title="8.3 线程的状态转换"></a>8.3 线程的状态转换</h3><ul><li><p>新建</p></li><li><p>运行：可能正在执行。可能正在等待CPU为它分配执行时间</p></li><li><p>无限期等待：不会被分配CUP执行时间，它们要等待被其他线程显式唤醒</p></li><li><p>限期等待：不会被分配CUP执行时间，它们无须等待被其他线程显式唤醒，一定时间会由系统自动唤醒</p></li><li><p>阻塞：阻塞状态在等待这获取到一个排他锁，这个时间将在另一个线程放弃这个锁的时候发生；等待状态就是在等待一段时间，或者唤醒动作的发生</p></li><li><p>结束：已终止线程的线程状态，线程已经结束执行</p><img src="/2019/08/02/深入理解JVM/10.png"><h2 id="9-0-线程安全"><a href="#9-0-线程安全" class="headerlink" title="9.0 线程安全"></a>9.0 线程安全</h2><p>当多个线程访问同一个对象，如果不用考虑他们在运行环境下的调度和交替执行，也不需要额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。</p><h3 id="9-1-线程安全的分类"><a href="#9-1-线程安全的分类" class="headerlink" title="9.1 线程安全的分类"></a>9.1 线程安全的分类</h3><p>按照“线程安全”的安全程度由强至弱</p></li></ul><ol><li>不可变对象：例如由final定义的对象是不可变的，String对象是一个典型的不可变对象，我们调用它的subString和replace方法时并不是在原来的对象基础上修改，而是返回一个新构造的对象。常用的还有枚举类，Long，Double等数值的包装类型</li><li>绝对线程安全：瞒住线程安全的定义、不需要额外的同步措施即可达到线程安全。在javaApi中，大多数标注自己是线程安全的类，大多不是绝对的线程安全，而是相对线程安全，例如Vector，hashtable。</li><li>相对线程安全：就是通常意义上的线程安全，单独操作时他是线程安全的，但某些操作下，需要额外的同步措施才能保证他的线程安全。</li><li>线程兼容：指对象本身不是线程安全的，但通过在调用端使用同步手段来使对象在并发环境下可以安全使用，例如Arraylist和HashMap。</li><li>线程对立：对象本身不是线程安全，也无法通过同步手段达到。例如Thread的suspend和resume方法。</li></ol><h3 id="9-2-线程安全的实现手段"><a href="#9-2-线程安全的实现手段" class="headerlink" title="9.2 线程安全的实现手段"></a>9.2 线程安全的实现手段</h3><ol><li><p>互斥：例如临界区，信号量，互斥量都是主要的互斥实现手段。在java中，最常见的就是synchronized关键字，有两点要注意：</p><ul><li>第一，synchronized同步块对于同一线程来说是可重入的（可重入性：如果当前线程已经获得了某个监视器对象所持有的锁，那么该线程在该方法中调用另外一个同步方法也同样持有该锁），不会出现自己锁死自己的情况。</li><li>第二，唤醒或阻塞一个线程都需要操作系统来完成，从用户太转换成内核态，需要耗费处理器时间，所以synchronized是一个重量级的操作，可通过阻塞线程自旋来优化。</li></ul><p>除了synchronized以外，还有一种可重入锁（reentrantlock），他增加了三种特性：等待可中断（正在等待的线程可以放弃等待，去处理其他事情)，公平锁(按序拿锁），锁可以绑定多个条件。JDK1.6以后，synchronized已经优化到和Reentrantlock一样的效率。</p></li><li><p>非阻塞同步：前面的都称为阻塞同步。互斥同步算是一种悲观的并发策略，总是认为不去做正确的同步措施，就是发生问题。随着硬件指令集发展，出现一种乐观的策略：先进行操作，如果没有其他线程争用共享数据那操作就成功了，否则就再采取补偿措施，，这些乐观的并发策略不会将线程挂起，因此叫非阻塞同步，关于硬件指令集的发展，这里不再具体介绍。这类方法有AtomicInteger的incrementandget方法。</p></li><li><p>无同步方案：如果一个方法本身不涉及到共享数据，那么就无需同步措施。</p><ul><li>可重入代码：代码执行后可中断然后再回来调用它是不会出现问题的，可重入代码都是线程安全的，反之则不然。特性：<br>不依赖堆上的数据和公共资源，用到的状态量都由参数传入，不调用不可重入方法</li><li>线程本地存储： 共享数据在一个线程里被执行，那么就是线程安全的。</li></ul></li></ol><p>也有另一种说法：实现三个基本特性</p><ol><li>实现原子性:用锁和同步</li><li>实现可见性: volatile </li><li>实现顺序性：volatile，synchronized和锁来保证，除了应用层来保证顺序性，jvm还通过happens-before原则隐式保证顺序性<h2 id="10-0-锁优化"><a href="#10-0-锁优化" class="headerlink" title="10.0 锁优化"></a>10.0 锁优化</h2>单纯的synchronized使用的锁太重量，在某些场景下有更好的解决方案<h3 id="10-1-自旋锁与自适应自旋"><a href="#10-1-自旋锁与自适应自旋" class="headerlink" title="10.1 自旋锁与自适应自旋"></a>10.1 自旋锁与自适应自旋</h3>互斥同步时会引起阻塞，影响性能，因为挂起线程和恢复线程都需要转入内核态，如果锁状态只会持续很短一段时间然后就释放了，那么这段时间去挂起和恢复线程就不值得，这时候可以让线程执行一个忙循环，这就是所谓的自旋锁。<h3 id="10-2-锁消除"><a href="#10-2-锁消除" class="headerlink" title="10.2 锁消除"></a>10.2 锁消除</h3>虚拟机即时编译期在运行时，会对一些代码进行同步，但是被检测到不可能存在共享数据竞争的锁进行消除。主要判定依据是逃逸分析检测。<h3 id="10-3-锁粗化"><a href="#10-3-锁粗化" class="headerlink" title="10.3 锁粗化"></a>10.3 锁粗化</h3>如果一系列连续操作都要对同一个对象反复加锁和解锁，那即使没有线程竞争，也会导致不必要的消耗。<br>如果虚拟机探测到有这样一串零碎的操作都对同一个对象进行加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。<h3 id="10-4-轻量级锁"><a href="#10-4-轻量级锁" class="headerlink" title="10.4 轻量级锁"></a>10.4 轻量级锁</h3>对于绝大部分的锁，在整个同步周期内都是不存在竞争的，如果没有竞争，轻量级锁就是CAS（比较和交换）来代替互斥量，如果存在锁竞争，除了互斥量的消耗，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁比重量级还慢。<h3 id="10-5-偏向锁"><a href="#10-5-偏向锁" class="headerlink" title="10.5 偏向锁"></a>10.5 偏向锁</h3>如果说轻量级锁是在无竞争的情况下使用CAS代替互斥量，那么偏向锁就是在无竞争的情况下把整个同步消除掉。第一个获得锁对象的线程如果以后没有另外一个线程来或者锁对象那么第一个线程下一次进入锁对象就不要任何同步操作。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer算法题</title>
      <link href="/2019/07/26/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98-%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81%E7%AF%87%E2%80%9C/"/>
      <url>/2019/07/26/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98-%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81%E7%AF%87%E2%80%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="高质量代码篇"><a href="#高质量代码篇" class="headerlink" title="高质量代码篇"></a>高质量代码篇</h1><a id="more"></a><h2 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16.数值的整数次方"></a>16.数值的整数次方</h2><p>题目：<br>实现函数double Power(double base,int exponent),求base的exponent次方。不得使用库函数，同时不需要考虑大数问题</p><p>思路：需要考虑特殊值的问题：</p><ul><li>1、底数为0，指数为负数的情况，无意义</li><li>2、指数为0，返回1</li><li>3、指数为负数，返回1.0/base,-exponent</li><li>4、指数正数，base,exponent，<br>还有效率问题，如果使用连乘效率太低，整数的n次方公式<img src="/2019/07/26/剑指offer算法题-高质量代码篇“/1.jpg" title="[]"></li></ul><pre><code>double pow(double base,int exponent) throws Exception {        if(equal(base,0.0)&amp;&amp;exponent&lt;0){            throw new Exception(&quot;invalid parameters&quot;);        }        if(equal(exponent,0.0)){            return 1;        }        int absExponent=exponent;        if(exponent&lt;0){            absExponent=-exponent;        }        double result=powerWithUnsignedExponent(base,absExponent);        if (exponent&lt;0){            result=1/result;        }        return result;    }    double powerWithUnsignedExponent(double base,int exponent){        if(exponent==0){            return 1;        }        if(exponent==1){            return base;        }        double result=powerWithUnsignedExponent(base,exponent&gt;&gt;1);//用右移代替除法        result*=result;        if((exponent&amp;1) ==1){//这里当指数为奇数时，需要再乘以base                result*=base;        }        return result;    }    boolean equal(double a,double b){        if(a-b&lt;0.0000001&amp;&amp;a-b&gt;-0.0000001){            return true;        }        return false;    }</code></pre><p>由于计算机表示小数（包括float和double型小数）都会有误差，我们不能直接用等号（==）判断两个小数是否相等。如果两个小数的差的绝对值很小，比如小于0.0000001，就可以认为他们相等。</p><h2 id="17-打印从1到最大的n位数"><a href="#17-打印从1到最大的n位数" class="headerlink" title="17.打印从1到最大的n位数"></a>17.打印从1到最大的n位数</h2><p>题目：输入数字n，按顺序打印出从1到最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数999。</p><h3 id="思路1-考虑到int和long只能表示32或64位的二进制数，这里用字符串表示就不会出现溢出问题，首先创造一个字符数组（全部初始化为0），然后对它的最低位，也就n-1的下标位进行加1，其中要考虑进位问题以及到达循环结束，也就是到达最大的n位数，打印时也要对开始的0位进行剔除。"><a href="#思路1-考虑到int和long只能表示32或64位的二进制数，这里用字符串表示就不会出现溢出问题，首先创造一个字符数组（全部初始化为0），然后对它的最低位，也就n-1的下标位进行加1，其中要考虑进位问题以及到达循环结束，也就是到达最大的n位数，打印时也要对开始的0位进行剔除。" class="headerlink" title="思路1: 考虑到int和long只能表示32或64位的二进制数，这里用字符串表示就不会出现溢出问题，首先创造一个字符数组（全部初始化为0），然后对它的最低位，也就n-1的下标位进行加1，其中要考虑进位问题以及到达循环结束，也就是到达最大的n位数，打印时也要对开始的0位进行剔除。"></a>思路1: 考虑到int和long只能表示32或64位的二进制数，这里用字符串表示就不会出现溢出问题，首先创造一个字符数组（全部初始化为0），然后对它的最低位，也就n-1的下标位进行加1，其中要考虑进位问题以及到达循环结束，也就是到达最大的n位数，打印时也要对开始的0位进行剔除。</h3><pre><code>public void printToMaxOfNDigits(int n) {        if (n &lt;= 0) {            return;        }        char[] number = new char[n];        for (int i = 0; i &lt; n; i++) {            number[i] = &#39;0&#39;;        }        while (!increment(number)) {            printNumber(number);        }    }    public boolean increment(char[] number) {        boolean isOverflow = false;        int carryFlag = 0;        int length = number.length;        for (int i = length - 1; i &gt;= 0; i--) {            int sum = number[i] - &#39;0&#39; + carryFlag;//注意ascall码的转换            if (i == length - 1) {//每次都从最低位加1                sum++;            }            if (sum &gt;= 10) {                if (i == 0) {                    isOverflow = true;                    break;                } else {                    sum -= 10;                    carryFlag = 1;                    number[i] = (char) (&#39;0&#39; + sum);                }            } else {                number[i] = (char) (&#39;0&#39; + sum);                break;            }        }        return isOverflow;    }    public void printNumber(char[] number) {//如果单纯的剔除0位，会导致后面为0的位也会被剔除。        boolean isBeginning0 = true;        for (int i = 0; i &lt; number.length; i++) {            if (number[i] != &#39;0&#39;) {                isBeginning0 = false;            }            if (!isBeginning0) {                System.out.print(number[i]);            }        }        System.out.print(&quot;\n&quot;);    }</code></pre><h3 id="思路2：其实就是n个从0到9的全排列-用递归法求"><a href="#思路2：其实就是n个从0到9的全排列-用递归法求" class="headerlink" title="思路2：其实就是n个从0到9的全排列,用递归法求"></a>思路2：其实就是n个从0到9的全排列,用递归法求</h3><pre><code>public void printToMaxOfNDigits(int n) {        if (n &lt;= 0) {            return;        }        char[] number = new char[n];        for (int i = 0; i &lt;10 ; i++) {            number[0]= (char) (i+&#39;0&#39;);            printToMaxOfNDigitsRecruisively(number,n,0);        }    }public void printToMaxOfNDigitsRecruisively(char[] number,int n,int index){        if(index==n-1){//递归终止条件，注意index的变化            printNumber(number);            return;        }        for (int i = 0; i &lt;10 ; i++) {            number[index+1]= (char) (i+&#39;0&#39;);            printToMaxOfNDigitsRecruisively(number,n,index+1);        }    }</code></pre><h2 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18.删除链表的节点"></a>18.删除链表的节点</h2><h3 id="题目1："><a href="#题目1：" class="headerlink" title="题目1："></a>题目1：</h3><p>给定单向链表的头节点和一个节点，定义一个函数在O（1）时间内删除该节点，该节点定义如下：</p><pre><code>public class ListNode {    int value;    ListNode next;    public ListNode(int value){        this.value=value;    }}</code></pre><p>思路： 肯定不能用传统方法，用被删除节点的下一个节点的内容覆盖被删除节点，并把该节点的next指向该节点下一个节点的next。但要分三种情况</p><img src="/2019/07/26/剑指offer算法题-高质量代码篇“/2.PNG" title="[]"><pre><code>public static void deleteNode(ListNode firstNode,ListNode toBeDeleted){        if(firstNode==null||toBeDeleted==null){            return;        }        if(toBeDeleted.next!=null){//有后续节点            ListNode nextNode=toBeDeleted.next;            toBeDeleted.value=nextNode.value;            toBeDeleted.next=nextNode.next;        }        else if(firstNode==toBeDeleted){//无后续节点，并且总共只有一个节点            firstNode=null;        }else {//被删节点是最后一个节点            ListNode currentNode=firstNode;            while(currentNode.next!=toBeDeleted){                currentNode=currentNode.next;            }            currentNode.next=null;        }    }</code></pre><p>注意当被删节点时最后一个节点时，不能单纯的将它赋值为null，要找到他的上一个节点，否则它虽然是null，但还是会被引用。</p><h3 id="题目二："><a href="#题目二：" class="headerlink" title="题目二："></a>题目二：</h3><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><p>思路：首先new一个新的节点，新的节点的next就是链表的头结点，用于处理头节点要被删除的情况，然后用两个指针，preNode和pNode。pNode用来寻找到重复元素的最后一个，preNode指向重复结点第一个的前一个，所以preNode永远在pNode的前面，然后preNode.next=pNode.next来删除节点、</p><pre><code>public static ListNode deleteDuolication(ListNode firstNode) {        if (firstNode == null || firstNode.next == null) {            return firstNode;        }        ListNode headNode=new ListNode(0);//新建节点        headNode.next=firstNode;        ListNode preNode=headNode;        ListNode pNode=headNode.next;        while (pNode!=null){            if(pNode.next!=null&amp;&amp;pNode.value==pNode.next.value){//注意递归的循环。pNext                while (pNode.next!=null&amp;&amp;pNode.next.value==pNode.value){//这两个条件是一样的                    pNode=pNode.next;                }                preNode.next=pNode.next;                pNode=pNode.next;            }            else {                preNode=preNode.next;                pNode=pNode.next;            }        }        return headNode.next;//返回的是head节点的后面一个节点    }</code></pre><h2 id="19-正则表达式的匹配"><a href="#19-正则表达式的匹配" class="headerlink" title="19.正则表达式的匹配"></a>19.正则表达式的匹配</h2><p>题目：请实现一个函数用来匹配包括’.’和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’*‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab*ac*a”匹配，但是与”aa.a”和”ab*a”均不匹配</p><p>思路：<br>当模式中当前字符的后面一个字符不是’*‘时：<br>直接判断他们是否相等，或模式中是否是’.’</p><p>当模式中当前字符的后面一个字符是’*‘时：有两种情况<br>1：字符串字符与模式中的字符相等，他有两种选择：</p><ul><li>忽略当前模式的* 即模式下标+2（因为<em>可以匹配0个字符），比如abc与ab\</em>bc</li><li>字符串下标+1，</li></ul><p>2：不相等，只有一种选择：</p><ul><li>忽略当前模式的* 即模式下标+2（因为*可以匹配0个字符）</li></ul><pre><code>public static boolean match(char[] str,char[] pattern){        if(str==null||pattern==null){            return false;        }        int strIndex=0;        int patternIndex=0;        return  matchCore(str,pattern,strIndex,patternIndex);    }    public static boolean matchCore(char[] str,char[] pattern,int strIndex,int patternIndex){        //有效性检验，两个同时到达尾部，匹配成功        if(strIndex==str.length&amp;&amp;patternIndex==pattern.length){            return true;        }        //pattern先到，匹配失败        if(str.length!=strIndex&amp;&amp;patternIndex==pattern.length){            return false;        }        //模式第二个是*        if(patternIndex+1&lt;pattern.length&amp;&amp;pattern[patternIndex+1]==&#39;*&#39;){            if((strIndex!=str.length&amp;&amp;str[strIndex]==pattern[patternIndex])                    ||strIndex!=str.length&amp;&amp;pattern[patternIndex]==&#39;.&#39;){                return matchCore(str,pattern,strIndex,patternIndex+2)                        ||matchCore(str,pattern,strIndex+1,patternIndex);            }            else {                return matchCore(str,pattern,strIndex,patternIndex+2);            }        }        //模式第二个不是*        if((strIndex!=str.length&amp;&amp;str[strIndex]==pattern[patternIndex])                ||strIndex!=str.length&amp;&amp;pattern[patternIndex]==&#39;.&#39;){            return matchCore(str,pattern,strIndex+1,patternIndex+1);        }        return false;    }</code></pre><p>为什么下标pattern比str先到就匹配失败：<br>比如 abb与ab*<br>str下标比pattern先到，但还是匹配成功</p><h2 id="20-表示数值的字符串"><a href="#20-表示数值的字符串" class="headerlink" title="20.表示数值的字符串"></a>20.表示数值的字符串</h2><p>题目：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p><p>本题考查对字符串的编程能力，我们需要从不同类型的数值中分析规律，要全面考虑数值整数，小数，指数部分的特点以及正负号出现的位置等等。</p><p>思路：</p><p>对字符串的每个字符进行判别分析，</p><ol><li>小数点和e/E都只能出现一次，并且e后面不能出现小数点，e是整数</li><li>对于+号和-号，只能出现在第一个数字以及e的后一位</li></ol><pre><code>public boolean isNumber(char[] str) {        if (str.length == 0 || str == null) {            return false;        }        int index = 0;        while (index &lt; str.length &amp;&amp; str[index] != &#39;.&#39; &amp;&amp; str[index] != &#39;e&#39; &amp;&amp; str[index] != &#39;E&#39;) {//首先要判断index是否越界，不然会出现outofbound错误            if (scanInteger(str, index)) {                index++;            } else {                return false;            }        }        if (str[index] == &#39;.&#39;) {            index++;//+1越过小数点            while (index &lt; str.length &amp;&amp; str[index] != &#39;e&#39; &amp;&amp; str[index] != &#39;E&#39;) {                if (scanUnsignedInteger(str, index)) {                    index++;                } else {                    return false;                }            }        }        if (str[index] == &#39;e&#39; || str[index] == &#39;E&#39;) {            index++;//+1越过e            while (index &lt; str.length) {                if (scanInteger(str, index)) {                    index++;                } else {                    return false;                }            }        }        if (index == str.length) {            return true;        } else {            return false;        }    }    //无符号数判断    public boolean scanUnsignedInteger(char[] str, int index) {        if (str[index] &gt;= &#39;0&#39; &amp;&amp; str[index] &lt;= &#39;9&#39;) {            return true;        }        return false;    }    public boolean scanInteger(char[] str, int index) {        if (str[index] == &#39;+&#39; || str[index] == &#39;-&#39;) {//若出现符号，+1越过后判断无符号数            index++;            if (index == str.length) {                return false;            }        }        return scanUnsignedInteger(str, index);    }</code></pre><h2 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21.调整数组顺序使奇数位于偶数前面"></a>21.调整数组顺序使奇数位于偶数前面</h2><p>题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><p>思路：类似于快排，此题主要考察对扩展性的理解，将一个单独的函数解耦，一部分是判断数组位于哪里的标准，另一部分是拆分数组的操作。</p><pre><code>      public void reOrder(int[] nums){            if (nums.length &lt; 2 || nums == null) {                return;            }            int beginIndex=0;            int endIndex=nums.length-1;            while (beginIndex&lt;endIndex){                while (beginIndex&lt;endIndex&amp;&amp;isEven(nums[endIndex])){                    endIndex--;                }                while (beginIndex&lt;endIndex&amp;&amp;!isEven(nums[beginIndex])){                    beginIndex++;                }                if(beginIndex&lt;endIndex){                    int temp=nums[beginIndex];                    nums[beginIndex]=nums[endIndex];                    nums[endIndex]=temp;                }            }        }        public boolean isEven(int n){            return (n&amp;1)==0;        }</code></pre><h2 id="鲁棒性"><a href="#鲁棒性" class="headerlink" title="鲁棒性"></a>鲁棒性</h2><p>鲁棒是英文Robust的音译。有时也成为健壮性。所谓的鲁棒性是指程序能够判断输入是否合乎要求，并对不合乎要求的输入予以正确的处理</p><h2 id="22-链表的倒数第k个节点"><a href="#22-链表的倒数第k个节点" class="headerlink" title="22.链表的倒数第k个节点"></a>22.链表的倒数第k个节点</h2><p>题目:输入一个链表，输出该链表中倒数第k个结点,单向链表，从1开始计数</p><p>思路：用两个指针，第一个指针指向头结点，开始向后遍历，遍历k-1步后，第二个指针指向头结点，然后两个指针一起向后遍历，这里第一个指针和第二指针之间就永远相差k-1个节点。当第一个指针到达最后的节点，那么第二个指针就是所求，</p><pre><code>public ListNode findKthToTail(ListNode firstNode,int k){           if(firstNode==null||k==0){               return null;           }           ListNode pAhead=firstNode;           ListNode pBehind=null;           for (int i = 0; i &lt;k-1 ; i++) {               if(pAhead.next!=null){                   pAhead=pAhead.next;               }else {                   return null;               }           }           pBehind=firstNode;           while (pAhead.next!=null){               pAhead=pAhead.next;               pBehind=pBehind.next;           }           return pBehind;       }</code></pre><p><strong>程序的鲁棒性要注意三点：</strong><br>输入的firstNode是否为null，链表是否有k个节点<br>如果是在c++中，还要注意k是否为无符号整数，因为k=0，k-1就变成了0xFFFFFFFF,在java中不存在无符号整数。</p><h2 id="23-链表中环的入口节点"><a href="#23-链表中环的入口节点" class="headerlink" title="23.链表中环的入口节点"></a>23.链表中环的入口节点</h2><p>题目：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><img src="/2019/07/26/剑指offer算法题-高质量代码篇“/3.PNG"><p>图中所示链表应返回2.</p><p>思路：</p><ol><li>首先要判断链表是否有环，用两个指针，一个指针一次走一步，另一个指针一次走两步，当他们相遇时就有环，不相遇则无环。</li><li>接下来要求出环中的节点数（n个），因为当定义两个指针指向头结点，一个指针先走n步，然后两个指针再同时走，当他们再次相遇时就是入口节点。</li><li>求节点数就是用1中相遇时的节点，因为这个节点必然在环中，从它开始遍历，当它回到它自身时，计算出节点数。</li></ol><pre><code> public ListNode findEntryNodeOfLoop(ListNode pHead) {        ListNode meetingNode = findMeetingNode(pHead);        if (meetingNode == null) {            return null;        }        int nodesInLoop = 1;        ListNode pNode = meetingNode;        while (pNode.next != meetingNode) {            pNode = pNode.next;            nodesInLoop++;        }        ListNode pNode1 = pHead;        ListNode pNode2 = pHead;        for (int i = 0; i &lt; nodesInLoop; i++) {            pNode1 = pNode1.next;        }        while (pNode1 != pNode2) {            pNode1 = pNode1.next;            pNode2 = pNode2.next;        }        return pNode1;    }    public ListNode findMeetingNode(ListNode pHead) {        if (pHead == null) {            return null;        }        ListNode pSlow = pHead;        ListNode pFast = pHead;        while (pSlow != null &amp;&amp; pFast != null) {            pSlow = pSlow.next;            pFast = pFast.next;            if (pFast!= null) {//不能一次走两步，要判断第一步是否是空，才能走第二步                pFast = pFast.next;            }            if (pSlow == pFast) {                return pFast;            }        }        return null;    }</code></pre><h2 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24.反转链表"></a>24.反转链表</h2><p>题目：反转一个单链表。</p><p>思路：反转时要定义三个指针，一个指针指向当前节点，另一个指针指向下一个节点，因为反转时会造成链表的断裂，无法遍历到下一个节点，最后一个指针用来指向反转后的头节点，即尾部节点</p><pre><code>public ListNode reverseList(ListNode pHead) {       if(pHead==null){           return null;       }       if(pHead.next==null){           return pHead;       }       ListNode pReversedHead=null;       ListNode pNode=pHead;       ListNode pPrev=null;       while (pNode!=null){           ListNode pNext=pNode.next;           if(pNext==null){               pReversedHead=pNode;           }           pNode.next=pPrev;           pPrev=pNode;           pNode=pNext;       }       return pReversedHead;   }</code></pre><h2 id="25-合并两个有序链表"><a href="#25-合并两个有序链表" class="headerlink" title="25.合并两个有序链表"></a>25.合并两个有序链表</h2><p>题目：输入两个递增排序的链表，合并两个链表并使新链表中的节点依然是递增排序的。</p><p>思路：如图：</p><img src="/2019/07/26/剑指offer算法题-高质量代码篇“/4.PNG"><pre><code>public ListNode mergeLists(ListNode pHead1, ListNode pHead2) {        if (pHead1 == null) {            return pHead2;        } else if (pHead2 == null) {            return pHead1;        }        ListNode pHead3 = null;        if (pHead1.value &gt; pHead2.value) {            pHead3 = pHead2;            pHead3.next = mergeLists(pHead1, pHead2.next);        } else {            pHead3 = pHead1;            pHead3.next = mergeLists(pHead1.next, pHead2);        }        return pHead3;    }</code></pre><h2 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26.树的子结构"></a>26.树的子结构</h2><p>题目：给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p><pre><code> 给定的树 s：     3    / \   4   5  / \ 1   2    /   0给定的树 t：   4  / \ 1   2返回 false。</code></pre><p>思路：用递归，从根节点开始，分别判断左右节点的值是否相同</p><pre><code> public boolean isSubtree(TreeNode root1, TreeNode root2) {        boolean result=false;        if(root1!=null&amp;&amp;root2!=null){            if(root1.val==root2.val){                result=doesTree1HasTree2(root1,root2);            }            if(!result){               result=isSubtree(root1.left,root2);            }            if(!result){                result=isSubtree(root1.right,root2);            }        }        return result;    }    public boolean doesTree1HasTree2(TreeNode root1,TreeNode root2){        if(root2==null&amp;&amp;root1==null){            return true;        }        if(root1==null||root2==null){            return false;        }        if(root1.val!=root2.val){            return false;        }        return doesTree1HasTree2(root1.left,root2.left)&amp;&amp;doesTree1HasTree2(root1.right,root2.right);}</code></pre><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>高质量的代码具有规范性，完整性，鲁棒性。</p><img src="/2019/07/26/剑指offer算法题-高质量代码篇“/5.PNG">]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客部署时遇到的问题</title>
      <link href="/2019/07/25/hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2019/07/25/hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="部署博客时遇到的错误"><a href="#部署博客时遇到的错误" class="headerlink" title="部署博客时遇到的错误:"></a>部署博客时遇到的错误:</h2><a id="more"></a><p>用hexo g 生成时<br>遇到</p><pre><code>YAMLException: end of the stream or a document separator is expected at line 19, column 1:</code></pre><p>并不是文件格式出问题，而是是因为我直接拷贝之前的md文件，缺少了_config.yml文件自动在hexo n 生成出来的md文件中的部分内容所导致的。<br>解决方案：<br>重新新建一个md文件：</p><pre><code>hexo new &quot;fileName&quot;</code></pre><p>然后转移文章内容。</p><h2 id="图片无法显示"><a href="#图片无法显示" class="headerlink" title="图片无法显示"></a>图片无法显示</h2><p>hexo-asset-image插件不能用的问题<br>这个插件我猜是没有更新及时支持新版的hexo，我的是3.9.0 （可以通过 hexo -version 命令查看版本）</p><p>安装hexo-asset-image的时候就不太正常，如下图</p><img src="/2019/07/25/hexo博客部署时遇到的问题/1.jpg" title="[]"><p>之前根据网上的教程找的hexo文章插入图片的教程大多都是让装hexo-asset-image这个插件， 可是我装好以后发现有问题，生成的html图片路径是”/.com/xxx.jpg”这样的，明显不能访问于是去官网看了下文档，官网显示新版的hexo已经加入了图片标签的支持，如下图：</p><p>post_asset_folder:true 这个参数设置为true后(_config.yml文件中)，每次new命令创建文章的时候就会生成同名的资源文件夹，部署的时候就会把资源文件同步上传到文章目录下在发布文章时，先把我们要用到的图片放到文章目录下面的同名目录 ，比如我 hexo new test这样就会在_post目录下面生成test.md文件和test目录，test目录就是这篇文章的资源目录</p><h3 id="使用官方提供的标签（老版本的好像没有）"><a href="#使用官方提供的标签（老版本的好像没有）" class="headerlink" title="使用官方提供的标签（老版本的好像没有）"></a>使用官方提供的标签（老版本的好像没有）</h3><p>假如我们要插入一张a.jpg的图片，就先复制图片到test目录下面，然后在需要插入图片的地方插入标签 </p><blockquote></blockquote><p>发布的时候就能正常显示了</p><h3 id="使用markdown方式插入图片"><a href="#使用markdown方式插入图片" class="headerlink" title="使用markdown方式插入图片"></a>使用markdown方式插入图片</h3><p>后来又发现可以直接使用传统的md规范的方式来插入图片，如：</p><pre><code>![图片描述](a.jpg) </code></pre><p>注意这里跟使用hexo-asset-image插件的方式去区别是更简化了，都不需要写相对目录了，只写文件名就行，hexo会从默认的文章目录下面同名目录下找到资源文件</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java反射机制</title>
      <link href="/2019/07/24/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/07/24/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-反射的概述："><a href="#1-反射的概述：" class="headerlink" title="1.反射的概述："></a>1.反射的概述：</h2><a id="more"></a><p>java反射机制是在运行状态中，对于任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。要想剖解一个类，必须先获取到该类的字节码文件对象。</p><p><strong>反射就是把java类中的各种成分映射到一个个的java对象</strong></p><p>例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。<br>     （其实：一个类中这些成员方法、构造方法、在加入类中都有一个类来描述）<br>如图是类的正常加载过程：反射的原理在与class对象。<br>熟悉一下加载的时候：Class对象的由来是将class文件读入内存，并为之创建一个Class对象。</p><img src="/2019/07/24/java反射机制/3.png" title="[类加载过程]"><h2 id="2-反射的使用"><a href="#2-反射的使用" class="headerlink" title="2.反射的使用"></a>2.反射的使用</h2><h3 id="获取class对象的三种方式："><a href="#获取class对象的三种方式：" class="headerlink" title="获取class对象的三种方式："></a>获取class对象的三种方式：</h3><ul><li><ol><li>Object——》getClass（）</li></ol></li><li><ol start="2"><li>任何数据类型（包括基本数据类型）都有一个静态的classs属性</li></ol></li><li><ol start="3"><li>通过class类的静态方法： forName（String className）<br>```<br>package fanshe;<br>/**</li></ol><ul><li><p>获取Class对象的三种方式</p></li><li><p>1 Object ——&gt; getClass();</p></li><li><p>2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性</p></li><li><p>3 通过Class类的静态方法：forName（String  className）(常用)</p></li><li></li><li><p>/<br>public class Fanshe {<br> public static void main(String[] args) {</p><pre><code> //第一种方式获取Class对象   Student stu1 = new Student();//这一new 产生一个Student对象，一个Class对象。 Class stuClass = stu1.getClass();//获取Class对象 System.out.println(stuClass.getName()); //第二种方式获取Class对象 Class stuClass2 = Student.class; System.out.println(stuClass == stuClass2);//判断第一种方式获取的Class对象和第二种方式获取的是否是同一个 //第三种方式获取Class对象 try {     Class stuClass3 = Class.forName(&quot;fanshe.Student&quot;);//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名     System.out.println(stuClass3 == stuClass2);//判断三种方式是否获取的是同一个Class对象 } catch (ClassNotFoundException e) {     e.printStackTrace(); }</code></pre><p> }<br>}<br>```</p></li></ul></li><li><p><em>注意：在运行期间，一个类，只有一个Class对象产生*</em><br>三种方式常用第三种，第一种对象都有了还要反射干什么。第二种需要导入类的包，依赖太强，不导包就抛编译错误。一般都第三种，一个字符串可以传入也可写在配置文件中等多种方法。</p></li></ul><p>通过反射还可以获取构造方法，成员方法等，反射在实际开发中使用的不多，像c++，pascal等语言没有提供这样的特性。由于反射机制能够实现在运行时对类进行装载，因此能够增加程序的灵活性，但是不恰当的使用反射机制，也会严重影响系统的性能。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>数据库注册驱动时；AOP动态代理中的JDK代理<br>若想深入了解反射特性，可参考这篇博客:<br><a href="https://blog.csdn.net/sinat_38259539/article/details/71799078" target="_blank" rel="noopener">https://blog.csdn.net/sinat_38259539/article/details/71799078</a></p><p>利用反射还可以修改String不可变的对象</p><pre><code>// 创建字符串&quot;Hello World&quot;， 并赋给引用s        String s = &quot;Hello World&quot;;        System.out.println(&quot;s = &quot; + s); // Hello World        // 获取String类中的value字段        Field valueFieldOfString = String.class.getDeclaredField(&quot;value&quot;);        // 改变value属性的访问权限        valueFieldOfString.setAccessible(true);        // 获取s对象上的value属性的值        char[] value = (char[]) valueFieldOfString.get(s);        // 改变value所引用的数组中的第5个字符        value[5] = &#39;_&#39;;        System.out.println(&quot;s = &quot; + s); // Hello_World</code></pre><p>利用反射获取私有成员，通过value改变字符数组的值。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer算法题</title>
      <link href="/2019/07/18/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/"/>
      <url>/2019/07/18/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识篇"><a href="#基础知识篇" class="headerlink" title="基础知识篇"></a>基础知识篇</h1><a id="more"></a><h2 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2.单例模式"></a>2.单例模式</h2><h3 id="单线程式"><a href="#单线程式" class="headerlink" title="单线程式"></a>单线程式</h3><pre><code>public class Singleton {    private Singleton(){    }    private Singleton instance=null;    public Singleton getInstance(){        if(instance==null){            instance=new Singleton();        }        return instance;    }}</code></pre><h3 id="多线程式-懒汉式"><a href="#多线程式-懒汉式" class="headerlink" title="多线程式(懒汉式)"></a>多线程式(懒汉式)</h3><pre><code>public class Singleton {    private Singleton(){    }    private Singleton instance=null;    public synchronized Singleton  getInstance(){        if(instance==null){            instance=new Singleton();        }        return instance;    }}</code></pre><p>可在多线程环境下，但每次访问这个方法都需要去获得锁，花销大</p><h3 id="加同步锁，前后两次判断是否为空"><a href="#加同步锁，前后两次判断是否为空" class="headerlink" title="加同步锁，前后两次判断是否为空"></a>加同步锁，前后两次判断是否为空</h3><pre><code>public class Singleton {    private Singleton(){    }    private Singleton instance=null;    public  Singleton  getInstance(){        if(instance==null){            synchronized (Singleton.class){                if(instance==null){                    instance=new Singleton();                }            }        }        return instance;    }}</code></pre><p>缺点：两个判断，复杂容易出错。</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><pre><code>public class Singleton {    private Singleton(){    }    private static  Singleton instance=new Singleton();    public  Singleton  getInstance(){        return instance;    }}</code></pre><p>缺点：在一开始就创建，降低了内存使用率</p><h3 id="静态内部类（建议使用0"><a href="#静态内部类（建议使用0" class="headerlink" title="静态内部类（建议使用0"></a>静态内部类（建议使用0</h3><pre><code>public class Singleton {    private Singleton(){    }    private static class SingletonHolder{        private final static Singleton instance=new Singleton();    }    public  Singleton  getInstance(){        return SingletonHolder.instance;    }}</code></pre><p>创建一个静态内部类，只有静态的内部类才能有静态变量，然后调用方法按需创建。</p><h2 id="3-二维数组中查找目标值"><a href="#3-二维数组中查找目标值" class="headerlink" title="3.二维数组中查找目标值"></a>3.二维数组中查找目标值</h2><p>题目描述：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每<br>一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二<br>维数组和一个整数，判断数组中是否含有该整数。</p><p>思路：从右上角或左下角开始找，逐行删除，或者用二分法查找</p><pre><code>boolean find(int[][] array,int target){        if (array.length == 0) {            return false;        }        int row = 0;        int column = array[0].length-1;        while (row &lt; array.length &amp;&amp; column &gt;= 0) {            if(array[row][column] == target) {                return true;            }            if(array[row][column] &gt; target) {                column--;            } else {                row++;            }        }        return false;    }</code></pre><p>这里 array.length 返回的是列的长度</p><h2 id="4-替换字符串中的空格"><a href="#4-替换字符串中的空格" class="headerlink" title="4. 替换字符串中的空格"></a>4. 替换字符串中的空格</h2><p>题目描述：将一个字符串中的空格替换成“%20”<br>例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<br>一般是要求在原来的字符串上进行替换</p><p>思路：先遍历一次字符串，计算出替换后字符串的长度，然后从后向前复制,复杂度为O(n)</p><pre><code>String replaceSpace(StringBuffer str){        if(str==null)            return null;        int spaceNum=0;        for (int i = 0; i &lt;str.length() ; i++) {            if(str.charAt(i)==&#39; &#39;)                spaceNum++;        }        int length=str.length();        str.setLength(str.length()+spaceNum*2);        int index=str.length()-1;        for (int i=length-1;i&gt;0;i--){            if(&#39; &#39;== str.charAt(i)) {                str.setCharAt(index--, &#39;0&#39;);                str.setCharAt(index--, &#39;2&#39;);                str.setCharAt(index--, &#39;%&#39;);            }            else                str.setCharAt(index--,str.charAt(i));        }            return String.valueOf(str);    }</code></pre><p>字符串的比较要用equals，基本类型用==</p><h2 id="7-根据前序和中序遍历重建二叉树"><a href="#7-根据前序和中序遍历重建二叉树" class="headerlink" title="7.根据前序和中序遍历重建二叉树"></a>7.根据前序和中序遍历重建二叉树</h2><p>题目描述：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p>思路：先找出根节点，然后利用递归方法构造二叉树<br>前序遍历的第一个节点就是根节点，然后找到中序遍历中根节点的位置，根节点左边的就是左子树，右边就是右子树，然后再到前序遍历中找到左子树的个数，和右子树的个数，然后递归方法</p><pre><code>public TreeNode buildTree(int[] pre, int[] in) {        return makeTree(pre,in,0,pre.length-1,0,in.length-1);    } TreeNode makeTree(int[] pre,int[] in,int preStart,int preEnd,int inStart,int inEnd){        if (preStart&gt;preEnd){            return null;        }        TreeNode root=new TreeNode(pre[preStart]);        for (int i = inStart; i &lt;inEnd ; i++) {//这里是遍历中序，从起点开始            if(pre[preStart]==in[i]){                root.left=makeTree(pre,in,preStart+1,preStart+i-inStart,inStart,i-1);                root.right=makeTree(pre,in,preStart+i-inStart +1,preEnd,i+1,inEnd);                break;            }        }        return root;    }</code></pre><p>尤其注意前序遍历中的左子树的end（prestart+1-instart）</p><h2 id="8-二叉树的下一个节点"><a href="#8-二叉树的下一个节点" class="headerlink" title="8.二叉树的下一个节点"></a>8.二叉树的下一个节点</h2><p>题目描述：给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><p>思路：若节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点；若节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果</p><pre><code>public TreeNode getNext(TreeNode pNode) {        if(pNode==null){            return null;        }        TreeNode pNext=null;        if(pNode.right!=null){            pNext=pNode.right;            while (pNext.left!=null){                pNext=pNext.left;            }        }else if (pNode.parent!=null){            TreeNode current=pNode;            TreeNode pParent=current.parent;            while (pParent!=null&amp;&amp;pParent.right==current){                current=current.parent;                pParent=current.parent;            }            pNext=pParent;        }            return pNext;    }</code></pre><p>注意pNode.parent!=null时，循环条件中的内容，current和pparent的迭代。</p><h2 id="9-用两个栈实现队列"><a href="#9-用两个栈实现队列" class="headerlink" title="9. 用两个栈实现队列"></a>9. 用两个栈实现队列</h2><p>题目描述：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><p>思路：（push）第一个栈用来压入元素，（pop）然后当第二个栈为空时，栈1的全部元素出栈到第二个栈，第二个栈最后一个元素直接出栈。</p><pre><code>class Queue {    private Stack stack1;    private Stack stack2;    /** Initialize your data structure here. */    public Queue() {    }    /** Push element x to the back of queue. */    public void push(int x) {            stack1.push(x);    }    /** Removes the element from in front of queue and returns that element. */    public int pop() throws Exception {        if(stack1.isEmpty()&amp;&amp;stack2.isEmpty()){            throw new Exception(&quot;empty&quot;);//因为返回值是int，用exception来表示栈为空的情况        }        if(stack2.isEmpty()){            while (!stack1.isEmpty()) {//这里要讲栈1所有的元素压入栈2                stack2.push(stack1.pop());            }        }        return (int) stack2.pop();    }</code></pre><h2 id="10-斐波那契数列的应用"><a href="#10-斐波那契数列的应用" class="headerlink" title="10. 斐波那契数列的应用"></a>10. 斐波那契数列的应用</h2><h3 id="10-1-输出斐波那契数列的第n项"><a href="#10-1-输出斐波那契数列的第n项" class="headerlink" title="10.1 输出斐波那契数列的第n项"></a>10.1 输出斐波那契数列的第n项</h3><p>题目描述：现在要求输入一个整数n，请你输出斐波那契数列的第n项。<br>斐波那契数列：</p><img src="/2019/07/18/剑指offer算法题-基础知识篇/1.PNG" title="[斐波那契数列函数]"><p>思路：递归的效率低，使用循环方式。</p><pre><code>public static long Fibonacci(long x){        if(x==0){            return 0;        }        if(x==1){            return 1;        }        long fibNMinusOne=1;        long fibNMinusTwo=0;        long fibN=0;        for (int i = 2; i &lt;=x ; ++i) {            fibN=fibNMinusOne+fibNMinusTwo;            fibNMinusTwo=fibNMinusOne;            fibNMinusOne=fibN;//这里注意先赋值给fibNMiusTwo，再赋值给fibNMinusOne        }        return fibN;    }</code></pre><h3 id="10-2-青蛙跳台阶-1或2级"><a href="#10-2-青蛙跳台阶-1或2级" class="headerlink" title="10.2. 青蛙跳台阶(1或2级)"></a>10.2. 青蛙跳台阶(1或2级)</h3><p>题目描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p>思路：斐波那契数列思想：当只有一级台阶时，只有一种跳法，两级台阶有两种跳法，当有n级台阶时，小青蛙第一步跳1级，那么剩下的就是n-1级台阶，第一步跳两级，就是n-2级台阶，依次求。</p><p>算法与上一题一样，只是起点与输入的数字不同。</p><h3 id="10-3-小矩形无重叠覆盖大矩形"><a href="#10-3-小矩形无重叠覆盖大矩形" class="headerlink" title="10.3 小矩形无重叠覆盖大矩形"></a>10.3 小矩形无重叠覆盖大矩形</h3><p>题目描述：我们可以用2x1的小矩形横着或者竖着去覆盖更大的矩形。请问用<br>n个2x1的小矩形无重叠地覆盖一个2xn的大矩形，总共有多少种方法？</p><p>思路：斐波那契数列思想</p><img src="/2019/07/18/剑指offer算法题-基础知识篇/2.PNG" title="[如图]"><p>第一次竖着放，那么后边有2x（n-1)的区域；第一次横着放，那么底下就必须横着放，后边就有2x（n-2）的区域</p><h3 id="10-4-青蛙跳台阶-n级"><a href="#10-4-青蛙跳台阶-n级" class="headerlink" title="10.4. 青蛙跳台阶(n级)"></a>10.4. 青蛙跳台阶(n级)</h3><p>题目描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳<br>上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br>思路：2^(n-1)</p><h2 id="对几万名员工的年龄排序"><a href="#对几万名员工的年龄排序" class="headerlink" title="对几万名员工的年龄排序"></a>对几万名员工的年龄排序</h2><p>题目描述：</p><p>面试官： 请实现一个排序算法，要求时间复杂度为O（N）<br>应聘者：请问对什么数字进行排序，共有多少数字？<br>面试官：我们想对公司所有员工按年龄排序，我们公司共有几万名员工；<br>应聘者：也就是说数字的大小在一个较小的范围之内，对吗？<br>面试官：是的<br>应聘者：可以使用辅助空间吗？<br>面试官：看你用多少内存，只允许使用常量大小的辅助空间，不得超过O(N);<br>应聘者：好的，我知道了；</p><p>思路：用额外的空间来存储每个年龄出现的次数，得到一个类似直方图的分布，然后对原来的数组重新排序。</p><pre><code> public static int[] sort(int[] ages) throws Exception {        if(ages.length&lt;=1||ages==null){            return ages;        }        int oldestAge=99;        int[] timeOfAge=new int[oldestAge+1];        for (int i = 0; i &lt;oldestAge+1 ; ++i) {//这题大多数以++i的形式赋值，只会影响初始值和结束值，不会影响循环次数。            timeOfAge[i]=0;        }        for (int i = 0; i &lt;ages.length ; ++i) {            int age=ages[i];            if(age&lt;0||age&gt;oldestAge){                throw new Exception(&quot;age out of bound&quot;);            }            timeOfAge[age]+=1;        }        int index=0;        for (int i = 0; i &lt;oldestAge ; ++i) {            for (int j = 0; j &lt;timeOfAge[i] ; ++j) {                ages[index]=i;//这里直接抛弃原来的数组，直接赋值                index++;            }        }        return ages;    }</code></pre><p>这里用100的整数空间换来了O（n）的时间效率；</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="最简单的快排："><a href="#最简单的快排：" class="headerlink" title="最简单的快排："></a>最简单的快排：</h3><pre><code>public static void quickSort(int[] A ,int left ,int right){        if(left&gt;=right){            return;        }else {            int i=left;            int j=right;            int t=A[left];            while (i&lt;j){                while (j&gt;i&amp;&amp;A[j]&gt;=t){                    j--;                }                while (i&lt;j&amp;&amp;A[i]&lt;=t){                    i++;                }                if(i&lt;j){                    int temp=A[i];                    A[i]=A[j];                    A[j]=temp;                }            }            A[left]=A[i];            A[i]=t;            quickSort(A,left,i-1);            quickSort(A,i+1,right);        }    }</code></pre><p> 注意：去左边的值为中枢，遍历时应先从后往前寻找比中枢小的值，而不是从前往后寻找比中枢大的值，因为最终是left与i交换值，i如果从前往后没有找到比中枢大的值，那么此时left不需要交换位置，然而i的位置已经变了，交换后就会出错。<br> 还有当两边都划分完了，此时i和j应该值是一样的</p><h2 id="11-旋转数组的最小数字："><a href="#11-旋转数组的最小数字：" class="headerlink" title="11.旋转数组的最小数字："></a>11.旋转数组的最小数字：</h2><p>题目描述：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数<br>组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元<br>素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。</p><p>思路：用二分法，当mid&gt;=index1 时，最小数则在mid的右边，当mid&lt;=index时，最小数在mid的左边，有两个特例，1：当旋转数组是他本身时，即未旋转，直接返回第一个数；2：若左中右三值相等，按序来查找。</p><pre><code>public int Min(int[] nums,int length) throws Exception {        if(nums==null||length&lt;=0){            throw new Exception(&quot;invalid parameters&quot;);        }        int index1=0;        int index2=length-1;        int midIndex=index1;//在这里考虑了当第一个数小于最后一个数，即未旋转时，直接返回index1        while (nums[index1]&gt;=nums[index2]){            if(index2-index1==1){                midIndex=index2;                break;            }            midIndex=(index1+index2)/2 ;            if(nums[midIndex]==nums[index1]&amp;&amp;nums[midIndex]==nums[index2]){//前后中三数相等，按序                return minInOrder(nums,index1,index2);            }           else if(nums[midIndex]&gt;=nums[index1]){                index1=midIndex;            }else if(nums[midIndex]&lt;=nums[index2]){                index2=midIndex;            }        }        return nums[midIndex];    }    public int minInOrder(int[] nums,int index1,int index2){        int result=nums[index1];        for (int i = index1+1; i &lt;index2 ; i++) {            if(nums[i]&lt;result){                result=nums[i];            }        }        return result;    }</code></pre><p><strong>补充一个小知识点</strong>：<br>在for循环中 i++与++i的效果是相等的</p><p>for(表达式1；表达式2；表达式3) 语句<br>它的执行过程如下： </p><p>1) 先求解表达式1。<br>2) 求解表达式2，若其值为真（非0），则执行for语句中指定的内嵌语句，然后执行下面第3）步；若其值为假（0），则结束循环，转到第5）步。<br> 3) 求解表达式3。<br>4) 转回上面第2）步继续执行。<br> 5) 循环结束，执行for语句下面的一个语句</p><p> 但他们的运行时间有差别，在java中，i++需要一个临时变量来存储自增前的值，而++i不需要，建议大家以后在写for循环且不影响逻辑的情况下多使用++i，少使用i++     </p><h2 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12.矩阵中的路径"></a>12.矩阵中的路径</h2><p> 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p><p>思路：回溯法：回溯法可以看成是蛮力法的升级版<br>这个一个走路径的问题，需要判断这个矩阵中的每一个结点是否可以走一条路径，在走的过程中，设置一个和矩阵大小相同的整型数组表示是否已经访问，如果某个结点访问了，那么该结点的是否访问则为1。每次遍历一个结点的时候，递归的方式分别向左、向右、向上、向下。  </p><pre><code>public boolean hasPath(char[] matrix, int rows, int cols, char[] str) {        if(matrix==null||rows&lt;1||cols&lt;1||str.length&lt;0){            return false;        }        int[] flag=new int[matrix.length];        for (int i = 0; i &lt;rows ; i++) {            for (int j = 0; j &lt; cols; j++) {                if(hasPathCore(matrix,flag,rows,cols,i,j,str,0)){                    return true;                }            }        }        return false;    }    public boolean hasPathCore(char[] matrix,int[] flag, int rows, int cols,int i,int j, char[] str,int k){        int index=i*cols+j;        if(i&lt;0||j&lt;0||i&gt;=rows||j&gt;=cols||matrix[index]!=str[k]||flag[index]==1){            return false;        }        if(k+1==str.length){//最终结束条件            return true;        }        flag[index]=1;//标识已走过        if(hasPathCore(matrix,flag,rows,cols,i+1,j,str,k+1)        ||hasPathCore(matrix,flag,rows,cols,i,j+1,str,k+1)        ||hasPathCore(matrix,flag,rows,cols,i-1,j,str,k+1)        ||hasPathCore(matrix,flag,rows,cols,i,j-1,str,k+1)){            return true;        }        flag[index]=0;//这个路径是死路，将其重置。        return false;    }</code></pre><p><strong>补充：递归，回溯和DFS的区别</strong><br>递归是一种算法结构，回溯是一种算法思想<br>一个递归就是在函数中调用函数本身来解决问题<br>回溯就是通过不同的尝试来生成问题的解，有点类似于穷举，但是和穷举不同的是回溯会“剪枝”，意思就是对已经知道错误的结果没必要再枚举接下来的答案了，比如一个有序数列1,2,3,4,5，我要找和为5的所有集合，从前往后搜索我选了1，然后2，然后选3 的时候发现和已经大于预期，那么4,5肯定也不行，这就是一种对搜索过程的优化</p><p>回溯搜索是深度优先搜索（DFS）的一种<br>对于某一个搜索树来说（搜索树是起记录路径和状态判断的作用），回溯和DFS，其主要的区别是，回溯法在求解过程中不保留完整的树结构，而深度优先搜索则记下完整的搜索树。</p><p>为了减少存储空间，在深度优先搜索中，用标志的方法记录访问过的状态，这种处理方法使得深度优先搜索法与回溯法没什么区别了。</p><h2 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13.机器人的运动范围"></a>13.机器人的运动范围</h2><p>题目描述：地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><p>思路：回溯法，与上题类似，</p><pre><code>public int movingCount(int threshold,int rows,int cols){        if(threshold&lt;0||rows&lt;0||cols&lt;0){            return 0;        }        boolean[] visited=new boolean[rows*cols];        for (int i = 0; i &lt;visited.length ; i++) {            visited[i]=false;        }        int count=movingCountCore(threshold,rows,cols,0,0,visited);        return count;    }    int movingCountCore(int threshold,int rows,int cols,int row,int col,boolean[] visited){        int count=0;        if(check(threshold,rows,cols,row,col,visited)){            visited[row*cols+col]=true;            count=1+movingCountCore(threshold,rows,cols,row+1,col,visited)                    +movingCountCore(threshold,rows,cols,row,col+1,visited)                    +movingCountCore(threshold,rows,cols,row-1,col,visited)                    +movingCountCore(threshold,rows,cols,row,col-1,visited);        }        return count;    }    boolean check(int threshold,int rows,int cols,int row,int col,boolean[] visited){        if(row&lt;0||row&gt;=rows||col&lt;0||col&gt;=cols||visited[row*cols+col]                ||getDigitSum(row)+getDigitSum(col)&gt;threshold){            return false;        }        return true;    }    int getDigitSum(int num){        int sum=0;        while (num&gt;0){            sum+=num%10;            num/=10;        }        return sum;    }</code></pre><h2 id="14-剪绳子"><a href="#14-剪绳子" class="headerlink" title="14.剪绳子"></a>14.剪绳子</h2><p>题目描述：<br>给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m≥1）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]<em>k[1]</em>…*k[m]可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。</p><h3 id="第一种思路：动态规划："><a href="#第一种思路：动态规划：" class="headerlink" title="第一种思路：动态规划："></a>第一种思路：动态规划：</h3><p>把大问题化成小问题，对小问题求最优解，再将小问题的最优解组合起来能否是整个问题的最优解。将绳子从第i处剪，长度分为i与l-i，然后分别求i和l-i的最优解，但0,1，2,3的最优解已经知晓，从4到length（绳子的长度）依次求最优解，</p><pre><code>    public int maxProductAfterCutting(int length){        if(length&lt;2){            return 0;        }        if(length==2){            return 1;        }        if(length==3){            return 2;        }        int[] product=new int[length+1];        product[0]=0;        product[1]=1;        product[2]=2;        product[3]=3;//这里指的是绳子长度&gt;4的绳子切成3，2，1时的最优解        for (int i = 4; i &lt;=length ; i++) {            int max=0;            for (int j = 1; j &lt;=i/2 ; j++) {//只需计算到i的一半                 product[i]=product[j]*product[i-j];                    if(max&lt;product[i]){                        max=product[i];                    }            }            product[i]=max;        }        int max=product[length];        return max;    }</code></pre><h3 id="第二种思路-贪婪"><a href="#第二种思路-贪婪" class="headerlink" title="第二种思路:贪婪"></a>第二种思路:贪婪</h3><p>从问题的某一个初始解出发逐步逼近给定的目标，以尽快求得更好的解。当算法达到某一步不能前进时，停止算法</p><p>当n&gt;=5n&gt;=5时，3(n−3)&gt;=2(n−2)3(n−3)&gt;=2(n−2)且只在n取5时取等号，且它们都大于nn，所以应把绳子剪成尽量多的3，让剩下的都是2这样的组合。</p><p>书上言尽于此，我想了下如果剪成其它大小的会不会更好。如果剪成4，那么4=2×2=2+24=2×2=2+2就还是和剪成两个2一样，如果剪成5，那么5还能继续剪剪成3和2，往后也是一样。试想更大的数，比如15，得到一段15以后不剪是不可能的，因为前面说了这时候3(n−3)&gt;2(n−2)&gt;n3(n−3)&gt;2(n−2)&gt;n，那么剪成更小的段，只要不小于5就一定满足这个就要继续减，如果比5小，从1~4的情况都想过了，4是不用管的或者剪成两个2，3就保留，2也保留，1不要出现。</p><pre><code>  public int greedyCutting(int length){        if(length&lt;2){            return 0;        }        if(length==2){            return 1;        }        if(length==3){            return 2;        }        int timesOf3=length/3;        if(length-timesOf3*3==1){            timesOf3-=1;//余数为1，即含数字4，此时剪成两个2更大        }        int timeOf2=(length-timesOf3*3)/2;        return  ((int) Math.pow(3,timesOf3)*(int)Math.pow(2,timeOf2));//pow函数返回double类型    }</code></pre><h2 id="动态规划与贪心算法的区别："><a href="#动态规划与贪心算法的区别：" class="headerlink" title="动态规划与贪心算法的区别："></a>动态规划与贪心算法的区别：</h2><ul><li>贪心：<br>基本思想：贪心算法并不从整体最优上加以考虑，它所做的选择只是在某种意             &emsp;&emsp;&emsp;&emsp;&emsp;义上的局部最优解。<br>基本要素：最优子结构性质和贪心选择性质。</li></ul><table><thead><tr><th>最优子结构性质</th><th align="center">贪心选择性质</th></tr></thead><tbody><tr><td>问题的整体最优解中包含子问题的最优解</td><td align="center">整体的最优解可通过一系列局部最优解达到，每次的选择可依赖以前作出的选择，但不依赖后续选择</td></tr></tbody></table><ul><li>动态规划<br>基本思想：将待求解的问题分解成若干个子问题，先求解子问题，然后从<br>&emsp;&emsp;&emsp;&emsp;&emsp;这些子问题的解得到原问题的解。<br>基本要素：最优子结构性质和重叠子问题性质</li></ul><p><strong>共同点</strong>:<br>两者都具有最优子结构性质<br><strong>不同点</strong>：</p><ol><li>动态规划算法中，每步所做的选择往往依赖于相关子问题的解，因而只有在解出相关子问题时才能做出选择。而贪心算法，仅在当前状态下做出最好选择，即局部最优选择，然后再去解做出这个选择后产生的相应的子问题。</li><li>动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常自顶向下的方式进行</li></ol><h2 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15.二进制中1的个数"></a>15.二进制中1的个数</h2><p>题目描述：任意给定一个32位有符号整数n，求n的二进制表示中1的个数，比如n = 5（0101）时，返回2，n = 15（1111）时，返回4</p><p>思路：<br>最原始的思路，不断对n进行右移，判断最后一个数是否为1（与1相与），但n如果是负数，则会陷入死循环，因为负数右移第一个数增加的是1，（补充：除法的效率比移位运算低的多）。<br>另一种思路：<br>不断对1进行左移，在与原整数相与，32位整数需要循环32次<br>最好的解法：<br>一个整数减去1，则第一个1后面的0全部变为1，第一个1变为0，得到的数与原来的相与，再重复以上操作，有多少个1重复多少次</p><pre><code>int timesOf1(int num){        int count=0;        while (num!=0){            int temp=num-1;            num=num&amp;temp;            count++;        }        return count;    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown-语法</title>
      <link href="/2019/07/17/MarkDown-%E8%AF%AD%E6%B3%95-1/"/>
      <url>/2019/07/17/MarkDown-%E8%AF%AD%E6%B3%95-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown-语法"><a href="#Markdown-语法" class="headerlink" title="Markdown 语法"></a>Markdown 语法</h1><a id="more"></a><h2 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h2><p>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p><p>注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。</p><p>示例：</p><pre><code># 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题</code></pre><h2 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h2><ul><li><p>加粗<br>要加粗的文字左右分别用两个*号包起来</p></li><li><p>斜体<br>要倾斜的文字左右分别用一个*号包起来</p></li><li><p>斜体加粗<br>要倾斜和加粗的文字左右分别用三个*号包起来</p></li><li><p>删除线<br>要加删除线的文字左右分别用两个~~号包起来</p></li></ul><h2 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h2><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;<br>示例：</p><blockquote><p> i am iron man</p></blockquote><h2 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h2><p>三个或者三个以上的 - 或者 * 都可以。<br>示例：</p><hr><hr><hr><hr><h2 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h2><p>语法：</p><pre><code>![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</code></pre><p>示例:</p><img src="/2019/07/17/MarkDown-语法-1/dragon.jpg" title="[斐波那契数列函数]"><h2 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h2><p>语法：</p><pre><code>[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加</code></pre><p>示例：</p><pre><code>[简书](http://jianshu.com)[百度](http://baidu.com)</code></pre><p>效果如下：</p><p><a href="http://jianshu.com" target="_blank" rel="noopener">简书</a><br><a href="http://baidu.com" target="_blank" rel="noopener">百度</a></p><h2 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h2><ul><li>无序列表</li></ul><p>语法：<br>无序列表用 - + * 任何一种都可以</p><pre><code>- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格</code></pre><ul><li>有序列表</li></ul><p>语法：<br>数字加点</p><pre><code>1.列表内容2.列表内容3.列表内容</code></pre><p>注意：序号跟内容之间要有空格</p><ul><li>列表嵌套</li></ul><p>上一级和下一级之间敲三个空格即可</p><h2 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h2><p>语法：</p><pre><code>表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略</code></pre><p>示例：</p><pre><code>姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟</code></pre><table><thead><tr><th>姓名</th><th align="center">技能</th><th align="right">排行</th></tr></thead><tbody><tr><td>刘备</td><td align="center">哭</td><td align="right">大哥</td></tr><tr><td>关羽</td><td align="center">打</td><td align="right">二哥</td></tr><tr><td>张飞</td><td align="center">骂</td><td align="right">三弟</td></tr></tbody></table><h2 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h2><p>语法：</p><ul><li>单行代码：代码之间分别用一个反引号包起来<pre><code>`代码neir`</code></pre><code>代码neir</code></li><li>代码块：代码之间分别用三个反引号，且两边的反引号单独占一行</li></ul><pre><code>  代码...  代码...  代码...</code></pre><h2 id="十丶缩进"><a href="#十丶缩进" class="headerlink" title="十丶缩进"></a>十丶缩进</h2><p>在语句前面加</p><ul><li>&amp;ensp； 代表一个空格</li><li>&amp;emsp； 代表两个空格</li><li>&amp;#160； 代表一个空格</li><li>&amp;#8194；一个空格</li><li>&amp;#8195； 两个</li></ul><p>注意上方后面的分号也要加进去</p><h2 id="十一丶转义字符"><a href="#十一丶转义字符" class="headerlink" title="十一丶转义字符"></a>十一丶转义字符</h2><p>当想输入特殊字符是 可以在特殊字符前面加上/来表示</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 常用命令（待补充）</title>
      <link href="/2019/07/17/Ubuntu-Command/"/>
      <url>/2019/07/17/Ubuntu-Command/</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu-常用命令"><a href="#Ubuntu-常用命令" class="headerlink" title="Ubuntu 常用命令"></a>Ubuntu 常用命令</h1><a id="more"></a><h2 id="linux文件权限"><a href="#linux文件权限" class="headerlink" title="linux文件权限"></a>linux文件权限</h2><p>权限分为三个组：[用户][用户组][其他人]<br>每一个组占三个符号</p><pre><code>-rwxr-xr-x 1 root root   207 9月  23 16:44 sh04.sh*//rwx代表用户可以读，写，执行，r-x代表用户组可以读，执行，r-x代表其他人可以读，执行，如果第一个字符为d那么表明他是一个目录</code></pre><h2 id="1-0-shell命令"><a href="#1-0-shell命令" class="headerlink" title="1.0 shell命令"></a>1.0 shell命令</h2><p>shell：鸡蛋外壳，因为shell命令位于最外层，提供用户操作系统的接口。它有不同的版本，在/bin目录上，一般使用的/bin/bash，</p><ul><li>tab<br>[tab]用于补全，用于最后字母后面，则为命令补全，用与最后一个字母加个空格再按tab就为文件补全。</li></ul><p>变量的定义用反引号`，波浪号对应的那么反引号</p><ul><li>?：代表上一个值的传回值，数字0代表没有，127代表错误<br>?代表<h3 id="1-1-文件，目录操作命令"><a href="#1-1-文件，目录操作命令" class="headerlink" title="1.1 文件，目录操作命令"></a>1.1 文件，目录操作命令</h3><blockquote><p>mkdir -p /u01/app/oracle<br>mkdir 是linux的建立目录命令。如果是级联建立要用-p选项。<br>比如要建立/u01/app/oracle目录<br>要这样写mkdir -p /u01/app/oracle<br>要是没有-p 会出错</p></blockquote></li></ul><h3 id="1-2-shell-重定向："><a href="#1-2-shell-重定向：" class="headerlink" title="1.2 shell 重定向："></a>1.2 shell 重定向：</h3><p>linux的io输入输出有三种：</p><ol><li>Standard Input 代码 0</li><li>Standard Output 代码 1</li><li>Standard Error 代码 2<pre><code># ls test.sh test1.sh 1&gt;success.txt 2&gt;&amp;1将错误信息2与标准输出1一起输出到success.txt中如果是这样# command 1&gt;file 2&gt;file 2和1会互相覆盖内容# command 1&gt;file 2&gt;$1 这样就不会覆盖</code></pre></li></ol><p>&lt; 代表输入重定向</p><blockquote><p>输出重定向</p><blockquote><p>代表追加到文件尾，不覆盖</p></blockquote></blockquote><p>command &gt;/dev/null 2&gt;&amp;1 与command  2&gt;&amp;1 &gt;/dev/null</p><p>前者先将标准输出输出到/dev/null中,再将错误输出重定向到标准输出,所以都输出到/dev/null</p><p>后者先将错误输出重定向到标准输出也就是输出到屏幕上,再将标准输出到/dev/null,只是把原来的标准输出输出到/de/null中,错误输出重定向到标准输出会显示在屏幕上;</p><p>标准输出与错误输出同时输出:command  2&gt;file 1&gt;file 会因抢占file文件的管道二出现乱码/确实/覆盖等现象(即两个输出流操作一个文件的写入),所以要用2&gt;&amp;1 进行重定向到一个输出流才可以全部输出到一个文件</p><pre><code>### 1.2 变量的设置规则1. 两边不能直接空格，要用“或者‘2. 变量不能以数字开头3. 用$表示这是个变量,$本身也是一个变量，表示线程代号4. \表示转义字符5. 可以用`反引号或者$(命令)表示这是另一个命令。注意反引号和单引号的区别6. 为变量增加新的内容：PATH=${PATH}:/home/bin7. export将变量设置为环境变量8. unset 用于取消变量Q: 双引号和单引号的区别？A: 变量的设置中，双引号中可以有变量，而单引号会直接输出语句，不会输出变量，单引号称为强引用，双引号称为弱引用### 1.3 read，array，declare</code></pre><h1 id="read-atest"><a href="#read-atest" class="headerlink" title="read atest"></a>read atest</h1><h1 id="echo-atest-从键盘读取并输出"><a href="#echo-atest-从键盘读取并输出" class="headerlink" title="echo $atest//从键盘读取并输出"></a>echo $atest//从键盘读取并输出</h1><h1 id="read-p-“please-input-your-name”-t-30-named"><a href="#read-p-“please-input-your-name”-t-30-named" class="headerlink" title="read -p “please input your name” -t 30 named"></a>read -p “please input your name” -t 30 named</h1><h1 id="echo-named-有提示符，并最多显示30秒"><a href="#echo-named-有提示符，并最多显示30秒" class="headerlink" title="echo $named//有提示符，并最多显示30秒"></a>echo $named//有提示符，并最多显示30秒</h1><h2 id="declare-aixr-variable"><a href="#declare-aixr-variable" class="headerlink" title="declare [-aixr] variable"></a>declare [-aixr] variable</h2><p>-a 声明为数组<br>-i 声明为数字<br>-x export，声明为环境变量<br>-r 只读</p><h2 id="var-1-”string”"><a href="#var-1-”string”" class="headerlink" title="var[1]=”string”"></a>var[1]=”string”</h2><h2 id="echo-var-1-数组的输出用"><a href="#echo-var-1-数组的输出用" class="headerlink" title="echo ${var[1]}//数组的输出用${}"></a>echo ${var[1]}//数组的输出用${}</h2><p>数值的加法要用 sum=$(($x+$y))这种格式</p><pre><code>### 1.4 与文件系统和程序的限制关系：ulimit</code></pre><h1 id="ulimit-SHacdfltu"><a href="#ulimit-SHacdfltu" class="headerlink" title="ulimit [-SHacdfltu]"></a>ulimit [-SHacdfltu]</h1><pre><code>可以用来限制文件的大小等参数### 1.5 变量内容的删除替代与替换</code></pre><p>${变量#关键字} //从头开始第一个关键字，最短匹配<br>${变量##关键字} //从头开始第一个关键字，最长匹配<br>${变量%关键字} //从尾开始第一个关键字，最短匹配<br>${变量%%关键字} //从尾开始第一个关键字，最长匹配<br>${变量/旧字符串/新字符串} //替换第一个关键字<br>${变量//旧字符串/新字符串} //替换所有关键字</p><pre><code>### 1.6 命名别名与历史命令</code></pre><h1 id="alias-lm-’ls-l-more’-设置命令的别名"><a href="#alias-lm-’ls-l-more’-设置命令的别名" class="headerlink" title="alias lm=’ls -l |more’ //设置命令的别名"></a>alias lm=’ls -l |more’ //设置命令的别名</h1><h1 id="history-查看历史命令"><a href="#history-查看历史命令" class="headerlink" title="history //查看历史命令"></a>history //查看历史命令</h1><h1 id="执行上一次的命令"><a href="#执行上一次的命令" class="headerlink" title="!! //执行上一次的命令"></a>!! //执行上一次的命令</h1><h1 id="n-执行第n个命令"><a href="#n-执行第n个命令" class="headerlink" title="!n //执行第n个命令"></a>!n //执行第n个命令</h1><pre><code>### 1.7 通配符符号|意义---|:--:* |代表0到无穷多个任意字符？|代表一个字符，任意的一个[]|代表括号内的一个字符，[abcd]代表abcd中任意一个[-]|代表括号中编码顺序内的所有字符，[0-9][^]|代表反向选择，[^abc]代表任意一个字符，只要不是abc中的就行### 1.8 命令执行的判断依据 ；|| &amp;&amp;上一条命令如果执行成功的话$?就会返回01. &amp;&amp;与||：</code></pre><h1 id="cmd1-amp-amp-cmd2-命令1执行成功那么就执行命令2，失败就不执行命令2"><a href="#cmd1-amp-amp-cmd2-命令1执行成功那么就执行命令2，失败就不执行命令2" class="headerlink" title="cmd1 &amp;&amp; cmd2 //命令1执行成功那么就执行命令2，失败就不执行命令2"></a>cmd1 &amp;&amp; cmd2 //命令1执行成功那么就执行命令2，失败就不执行命令2</h1><h1 id="cmd2-cmd2-命令1执行不成功就执行命令2，成功就不执行命令2"><a href="#cmd2-cmd2-命令1执行不成功就执行命令2，成功就不执行命令2" class="headerlink" title="cmd2 || cmd2 //命令1执行不成功就执行命令2，成功就不执行命令2"></a>cmd2 || cmd2 //命令1执行不成功就执行命令2，成功就不执行命令2</h1><p>要注意&amp;&amp;与||连用时，不同的顺序可能导致不同的结果</p><pre><code>2. ; :分号代表两个命令无联系，### 1.9 管道命令使用|对前面的命令获取的结果进行处理</code></pre><h1 id="ll-etc-less-只显示少部分的etc下面的文件"><a href="#ll-etc-less-只显示少部分的etc下面的文件" class="headerlink" title="ll /etc | less //只显示少部分的etc下面的文件"></a>ll /etc | less //只显示少部分的etc下面的文件</h1><pre><code>#### 1.9.1 选取命令 cut</code></pre><h1 id="echo-PATH-cut-d-‘-’-f-3-5-将path中的路径以-分割，输出第三个位置和第五个位置的字符串"><a href="#echo-PATH-cut-d-‘-’-f-3-5-将path中的路径以-分割，输出第三个位置和第五个位置的字符串" class="headerlink" title="echo $PATH | cut -d ‘;’ -f 3,5 //将path中的路径以;分割，输出第三个位置和第五个位置的字符串"></a>echo $PATH | cut -d ‘;’ -f 3,5 //将path中的路径以;分割，输出第三个位置和第五个位置的字符串</h1><h1 id="echo-PATH-cut-c-12-输出path路径中从低13个字符以后的字符"><a href="#echo-PATH-cut-c-12-输出path路径中从低13个字符以后的字符" class="headerlink" title="echo $PATH | cut -c 12- //输出path路径中从低13个字符以后的字符"></a>echo $PATH | cut -c 12- //输出path路径中从低13个字符以后的字符</h1><h1 id="last-输出用户的登录记录"><a href="#last-输出用户的登录记录" class="headerlink" title="last 输出用户的登录记录"></a>last 输出用户的登录记录</h1><h1 id="last-cut-d-‘-‘-f-1-输出第一列的数据"><a href="#last-cut-d-‘-‘-f-1-输出第一列的数据" class="headerlink" title="last | cut -d ‘ ‘ -f 1 //输出第一列的数据"></a>last | cut -d ‘ ‘ -f 1 //输出第一列的数据</h1><pre><code>#### 1.9.2 选取命令 grepcut 是对找到的字符串进行裁剪，而grep是根据字符串去查找相应的记录</code></pre><h1 id="grep-acinv-–color-auto-‘目标字符串’-filename"><a href="#grep-acinv-–color-auto-‘目标字符串’-filename" class="headerlink" title="grep [-acinv] [–color=auto] ‘目标字符串’ filename"></a>grep [-acinv] [–color=auto] ‘目标字符串’ filename</h1><p>-v 反向选择<br>-i 忽略大小写<br>–color=auto 对目标字符串显示特殊颜色</p><pre><code>#### 1.9.3排序命令：sort wc uniq</code></pre><h1 id="sort-fbmnrtuk-file-or-stdin-默认按文字类型排序"><a href="#sort-fbmnrtuk-file-or-stdin-默认按文字类型排序" class="headerlink" title="sort [-fbmnrtuk] [file or stdin] 默认按文字类型排序"></a>sort [-fbmnrtuk] [file or stdin] 默认按文字类型排序</h1><h1 id="uniq-ic-删除重复的数据，仅列出一个显示"><a href="#uniq-ic-删除重复的数据，仅列出一个显示" class="headerlink" title="uniq [-ic]  //删除重复的数据，仅列出一个显示"></a>uniq [-ic]  //删除重复的数据，仅列出一个显示</h1><p>-i 忽略大小写<br>-c 统计次数</p><h1 id="wc-lwm-对文件中行，字数，字符数进行统计"><a href="#wc-lwm-对文件中行，字数，字符数进行统计" class="headerlink" title="wc [-lwm] //对文件中行，字数，字符数进行统计"></a>wc [-lwm] //对文件中行，字数，字符数进行统计</h1><p>-l 只统计行<br>-w 字（英文单字）<br>-m 字符</p><pre><code>#### 1.9.4 双向重定向：tee</code></pre><h1 id="tee-a-file-将获取到的数据输入到文件中"><a href="#tee-a-file-将获取到的数据输入到文件中" class="headerlink" title="tee [-a] file //将获取到的数据输入到文件中"></a>tee [-a] file //将获取到的数据输入到文件中</h1><p>-a 以累加（append）方式</p><h1 id="last-tee-last-list-将last获取到的数据写入last-list中，并且输出到屏幕上"><a href="#last-tee-last-list-将last获取到的数据写入last-list中，并且输出到屏幕上" class="headerlink" title="last| tee last.list 将last获取到的数据写入last.list中，并且输出到屏幕上"></a>last| tee last.list 将last获取到的数据写入last.list中，并且输出到屏幕上</h1><pre><code>#### 1.9.5 字符转换命令：tr col join paste expand</code></pre><p>tr ‘[a-z]’ ‘[A-Z]’ 用大写替换全部小写<br>tr -d ‘:’ 删除：号</p><pre><code>* col将tab键换成空格键* join处理两个文件的数据* paste也是处理两个文件间的数据* expand将tab键转换成空格#### 1.9.6 切割命令： split</code></pre><p>split [-bl] file PREFIX<br>-b 单位，切成的文件大小<br>-l 以行数来添加</p><h1 id="split-b-300k-etc-termcap-termcap"><a href="#split-b-300k-etc-termcap-termcap" class="headerlink" title="split -b 300k /etc/termcap termcap"></a>split -b 300k /etc/termcap termcap</h1><h1 id="cat-termcap-gt-gt-termcap-合并前缀为termcap的文件"><a href="#cat-termcap-gt-gt-termcap-合并前缀为termcap的文件" class="headerlink" title="cat termcap* &gt;&gt; termcap 合并前缀为termcap的文件"></a>cat termcap* &gt;&gt; termcap 合并前缀为termcap的文件</h1><pre><code>#### 1.9.7 -减号- 代表上一次命令的输出作为这一次命令的输入</code></pre><h1 id="tar-cvf-home-tar-xvf"><a href="#tar-cvf-home-tar-xvf" class="headerlink" title="tar -cvf - /home | tar -xvf -"></a>tar -cvf - /home | tar -xvf -</h1><pre><code>#### 1.9.8 参数代换： xargs很多命令不支持管道命令，那么就用xargs代替该命令</code></pre><h1 id="find-sbin-perm-7000-ls-l"><a href="#find-sbin-perm-7000-ls-l" class="headerlink" title="find /sbin -perm +7000 |ls -l"></a>find /sbin -perm +7000 |ls -l</h1><p>ls -l不是管道命令，所以就无法执行</p><h1 id="find-sbin-perm-7000-xargs-ls-l"><a href="#find-sbin-perm-7000-xargs-ls-l" class="headerlink" title="find /sbin -perm +7000 |xargs ls -l"></a>find /sbin -perm +7000 |xargs ls -l</h1><pre><code>## 2.0 正则表达式的使用### 2.1 特殊正则式[:alnym:] 代表英文字母大小写和数字，即0-9，A-Z，a-z[:alpha:] 代表任何英文字母大小写，即a-z，A-Z[:digit:] 代表数字，即0-9### 2.2 高级Grep用法</code></pre><h1 id="grep-A-B-n-‘String’-filename-查找String"><a href="#grep-A-B-n-‘String’-filename-查找String" class="headerlink" title="grep [-A] [-B] [-n] ‘String’ filename //查找String"></a>grep [-A] [-B] [-n] ‘String’ filename //查找String</h1><p>-A后可接数字，代表after，后续的行<br>-B后可接数字，代表before，前面的行<br>-n表示开启行数显示</p><h1 id="grep-n-‘the’-1-txt-查询包含the的行"><a href="#grep-n-‘the’-1-txt-查询包含the的行" class="headerlink" title="grep -n ‘the’ 1.txt // 查询包含the的行"></a>grep -n ‘the’ 1.txt // 查询包含the的行</h1><h1 id="grep-vn-‘the’-1-txt-查询不包含the的行"><a href="#grep-vn-‘the’-1-txt-查询不包含the的行" class="headerlink" title="grep -vn ‘the’ 1.txt //查询不包含the的行"></a>grep -vn ‘the’ 1.txt //查询不包含the的行</h1><h1 id="grep-in-‘the’-1-txt-查询the的行，部分大小写"><a href="#grep-in-‘the’-1-txt-查询the的行，部分大小写" class="headerlink" title="grep -in ‘the’ 1.txt //查询the的行，部分大小写"></a>grep -in ‘the’ 1.txt //查询the的行，部分大小写</h1><pre><code>正则表示式|代表的意思:-|:-:|t[ae]st|代表tast，test[^g]00|代表不已g开头的oo字符串^the|代表the开头的行\.$|代表以.结束的行^$|代表空行g..d|代表以g和d中间有两个任意字符g\*g|代表\*前面的g有0到无穷多个go\\{2,4\\}g|代表o有2到4个### 2.3 sed用法sed以行为单位进行处理，通常用于编辑文件sed本身也是一个管道命令，对行进行操作</code></pre><h1 id="cat-etc-passwd-sed-‘2-5d’-删除2到5行"><a href="#cat-etc-passwd-sed-‘2-5d’-删除2到5行" class="headerlink" title="cat /etc/passwd | sed ‘2,5d’ //删除2到5行"></a>cat /etc/passwd | sed ‘2,5d’ //删除2到5行</h1><h1 id="cat-etc-passwd-sed-n-‘5-7p’-只展示5到7行，一定要加-n"><a href="#cat-etc-passwd-sed-n-‘5-7p’-只展示5到7行，一定要加-n" class="headerlink" title="cat /etc/passwd | sed -n ‘5,7p’ //只展示5到7行，一定要加-n"></a>cat /etc/passwd | sed -n ‘5,7p’ //只展示5到7行，一定要加-n</h1><h1 id="sed-‘s-String1-String2-g’-用字符串2替换字符串1"><a href="#sed-‘s-String1-String2-g’-用字符串2替换字符串1" class="headerlink" title="sed ‘s/String1/String2/g’ //用字符串2替换字符串1"></a>sed ‘s/String1/String2/g’ //用字符串2替换字符串1</h1><pre><code>### 2.4 扩展正则表达式扩展正则表示式用egrep表示RE字符|意义与范例:-:|:-:+|重复一个或一个以上的前一个RE字符？|零个或一个的前一个RE字符\||用or的方式查找字符串()|查找组字符串：比如查找glad和good，就可以egrep -n &#39;g(la|oo)d express_regular.txt### 2.5 awk数据处理工具，相比sed作用于一整行的处理，awk作用于一整列的处理，用于根据内容分析并处理</code></pre><h1 id="last-n-5-awk-‘-printf-1-“-t”-3-’-输出第一行和第三行"><a href="#last-n-5-awk-‘-printf-1-“-t”-3-’-输出第一行和第三行" class="headerlink" title="last -n 5|awk ‘{printf $1 “\t” $3}’ //输出第一行和第三行"></a>last -n 5|awk ‘{printf $1 “\t” $3}’ //输出第一行和第三行</h1><pre><code>## 3.0 shell script### date%Y%m%d 的格式是20190921%y%m%d 的格式是190921date可以直接输入，不需要$date，date --date=&quot;20190924&quot;+%s可一转换成秒### 3.1 数值运算var=$((运算内容))### 3.2 ./ , source ,sh命令的区别三个命令都可以运行脚本，但./在运行之前需要赋权不同点在于：./和sh都是在子进程中运行，运行完后销毁进程，所以不保存局部变量，但source是在当前进程中运行，保存变量。### 3.3 test命令test 命令用于测试文件是否存在以及他的其他信息</code></pre><p>test -e filename //查看文件是否存在</p><pre><code>### 3.4 判断符号 []在判断符号[]中我们可以去判断两数是否相等</code></pre><p>[ “$yn” == “Y” -o “$yn” == “y” ] &amp;&amp; echo “OK, continue!” &amp;&amp; exit 0 </p><pre><code>这里由于dash和bash不兼容，bash中默认判断符号为单个=号，运行脚本会出现unexpected operator1. ：sudo dpkg-reconfigure dash   选NO将ubuntu 默认的shell 链接的dash 改成传统的 bash \2. 使用=号### 3.5 shell script 的默认变量（\$1,$2...)假如我们在执行脚本的命令后面加上几个变量，那么就可以在脚本中引用</code></pre><p>sh sh07.sh one two three<br>那么$0就代表sh7.sh,$1就代表one，依次$#就代表变量的树木，$@就打印所有的变量</p><pre><code>shift用于偏移量</code></pre><p>sh sh07.sh one two three<br>在脚本中写上shift 2 ，那么$0就指向了one</p><pre><code>### 3.6 条件判断式</code></pre><p>if [] ; then </p><p>elif [];then</p><p>else</p><p>fi  //fi代表结束，注意其中的空格<br>```</p><h2 id="4-0-VIM命令"><a href="#4-0-VIM命令" class="headerlink" title="4.0 VIM命令"></a>4.0 VIM命令</h2><p>###<br>删除一块代码：</p><ol><li>设置行号 :set number</li><li>转到多少行  11G</li><li>删除从3行到当前行的代码 3,.d  .代表当前行</li><li>如果只需要删除某一行，可以用dd就行</li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实训结束感悟</title>
      <link href="/2019/07/12/%E5%AE%9E%E8%AE%AD%E7%BB%93%E6%9D%9F%E6%84%9F%E6%82%9F/"/>
      <url>/2019/07/12/%E5%AE%9E%E8%AE%AD%E7%BB%93%E6%9D%9F%E6%84%9F%E6%82%9F/</url>
      
        <content type="html"><![CDATA[<h4 id="简单记一下这次的实训吧"><a href="#简单记一下这次的实训吧" class="headerlink" title="简单记一下这次的实训吧"></a>简单记一下这次的实训吧</h4><p>在报告厅观看完最后实训成果展示后，这次实训就正式结束了，维期21天。接下来又是苦逼的搬寝室，明天又要早起赶高铁，也不多说，只是记录一下重要的事情，贴上实训项目的地址：<br><a href="https://github.com/Gakki90/GarmentMall3.0" target="_blank" rel="noopener">https://github.com/Gakki90/GarmentMall3.0</a></p><p>补充一下：感谢一位组员因得奖而来的分红<br>  地点：学校宿舍                                                                                   </p><p>时间：2019-7-12 16：08 </p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/07/07/hello-world/"/>
      <url>/2019/07/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
