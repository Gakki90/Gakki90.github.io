<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>剑指offer算法题</title>
      <link href="/2019/08/16/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98-%E9%9D%A2%E8%AF%95%E8%83%BD%E5%8A%9B%E7%AF%87/"/>
      <url>/2019/08/16/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98-%E9%9D%A2%E8%AF%95%E8%83%BD%E5%8A%9B%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="面试能力篇"><a href="#面试能力篇" class="headerlink" title="面试能力篇"></a>面试能力篇</h1><a id="more"></a><h2 id="53-在排序数组中查找数字"><a href="#53-在排序数组中查找数字" class="headerlink" title="53.在排序数组中查找数字"></a>53.在排序数组中查找数字</h2><p>题目一:统计一个数字在排序数组中出现的次数</p><p>思路：找到数字在数组第一次出现的位置，和第二次出现的位置，使用二分法求，当数字在出现的位置前面一个数不等于他，那么它就是第一个数，同理当数字在出现的位置后面一个数不等于他，那么它就是第一个数</p><pre><code>  public int getNumberOfK(int[] arr,int k){        if(arr==null||arr.length&lt;=0){            return -1;        }        int length=arr.length;        int first=getFirstIndexOfK(arr,k,0,length);        int last=getLastIndexOfK(arr,k,0,length);        if(first==-1||last==-1)            return -1;        else            return last-first+1;    }    int getFirstIndexOfK(int[] arr,int k,int start,int end){        int mid=(start+end)/2;        while (start&lt;=end){            if(arr[mid]&gt;k){                end=mid-1;            }else if(arr[mid]&lt;k){                start=mid+1;            }else {                if(mid&gt;0&amp;&amp;arr[mid-1]!=k){                    return mid;                }else {                    end=mid-1;                }            }            mid=(start+end)/2;        }        return -1;    }    int getLastIndexOfK(int[] arr,int k,int start,int end){        int mid=(start+end)/2;        while (start&lt;=end){            if(arr[mid]&gt;k){                end=mid-1;            }else if(arr[mid]&lt;k){                start=mid+1;            }else {                if(mid&gt;0&amp;&amp;arr[mid+1]!=k){                    return mid;                }else {                    start=mid+1;                }            }            mid=(start+end)/2;        }        return -1;    }</code></pre><p>题目二：一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在0<del>n-1之内。在范围0</del>n-1内的n个数字有且只有一个不在数组中，找出该数字</p><p>思路：仍然基于二分法，当数字的下标大于他的值并且他的前一个数的下标等于他的值，那么就是所求的数</p><pre><code>int getFirstDiffer(int[] arr,int start,int end){        int mid=(start+end)/2;        while (start&lt;=end){           if(arr[mid]==mid){               start=mid+1;           }else {               if(mid&gt;0&amp;&amp;arr[mid-1]&gt;mid-1){                   end=mid-1;               }else {                   return mid;               }           }            mid=(start+end)/2;        }        return -1;    }</code></pre><p>题目三：<br>假设单调递增的数组里每个元素都是整数且都是唯一的。请实现函数，找出数组中任意一个数值等于其下标的元素。如</p><p>{-3,-1,1,3,5}，数字3和下标相等</p><pre><code>int getNumberSameAsIndex(int[] arr,int start,int end){        int mid=(start+end)/2;        while (start&lt;=end){           if(arr[mid]==mid){               return arr[mid];           }else if(arr[mid]&lt;mid){               start=mid+1;           }else{               end=mid-1;           }            mid=(start+end)/2;        }        return -1;    }</code></pre><h2 id="54-二叉搜索树的第k大节点"><a href="#54-二叉搜索树的第k大节点" class="headerlink" title="54.二叉搜索树的第k大节点"></a>54.二叉搜索树的第k大节点</h2><p>题目：给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。</p><p>思路：中序遍历</p><pre><code>int findKthNode(TreeNode pRoot,int k){        int[] arr=new int[1];        findKthNode(pRoot,k,arr);        return arr[0];    }    int index=0;    void findKthNode(TreeNode pRoot,int k,int[] arr ){        if(pRoot==null){            return;        }        TreeNode pNode=pRoot;        findKthNode(pNode.left,k,arr);        index++;        if(index==k){            arr[0]=pNode.value;        }        findKthNode(pNode.right,k,arr);    }</code></pre><h2 id="55-二叉树的深度"><a href="#55-二叉树的深度" class="headerlink" title="55.二叉树的深度"></a>55.二叉树的深度</h2><p>题目一：求一棵二叉树的深度<br>思路：当输入根节点，树的深度就等于左子树的深度和右子树的深度中较大的加一，递归下去。</p><pre><code>  int findTreeDepth(TreeNode pRoot) {        if(pRoot==null){            return 0;        }        int left=findTreeDepth(pRoot.left);        int right=findTreeDepth(pRoot.right);        return left&gt;right?(left+1):(right+1);    }</code></pre><p>题目二：判断一棵树是不是平衡二叉树<br>平衡二叉树的定义：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p><p>思路：从叶节点开始往上遍历，判断每一层是否是平衡二叉树，这里要定义一个全局变量，isbalanced，若某一处不是平衡的，那么这棵树就不是平衡二叉树</p><pre><code>private boolean isBalanced=true;    public boolean isBalanced_Solution(TreeNode root){        getDepth(root);        return isBalanced;    }    public int getDepth(TreeNode root){        if(root==null){            return 0;        }        int left=getDepth(root.left);        int right=getDepth(root.right);        int depth=1+(left&gt;right?left:right);        if(left-right&gt;=-1&amp;&amp;left-right&lt;=1&amp;&amp;isBalanced){            isBalanced=true;        }else {            isBalanced=false;        }        return depth;    }</code></pre><h2 id="56-数组中数字出现的次数"><a href="#56-数组中数字出现的次数" class="headerlink" title="56.数组中数字出现的次数"></a>56.数组中数字出现的次数</h2><p>题目一：数组中有两个数字恰好都只出现一次，其他的出现两次</p><p>思路：划分，将两个数字划分到两个不同的数组，然后异或，关键是怎么划分，划分的同时，两个相同的数字一定要划分到同一个数组。</p><ol><li>先求出整个数组异或的结果，也就是不相同的两个数字异或的结果，然后转换为二进制，求第一个1出现的地方（indexOf1），出现了1，那么不相同的两个数字在这一位上要么是1，要么是0.</li><li>遍历数组，如果这个数在indexOf1上是1，就划分到一个数组，如果是0，那就划分到另一个数组。</li></ol><p>试想一下，两个相同的数字那么他们在这一位上肯定是相同的，那么他们肯定会被划分到同一个数组。</p><pre><code>public int[] findNumsAppearOnce(int[] num){        if(num==null||num.length&lt;=0){            return new int[2];        }        int length=num.length;        int resultOfXOR=0;        for (int i = 0; i &lt;length ; i++) {            resultOfXOR^=num[i];        }        int indexOf1=indexOfFirst1(resultOfXOR);        int[] result=new int[2];        for (int i = 0; i &lt;length ; i++) {            if(isBit1(num[i],indexOf1)){                result[1]^=num[i];            }else {                result[0]^=num[i] ;            }        }        return result;    }   public int indexOfFirst1(int num){       int indexOf1=0;       while ((num&amp;1)==0){          num= num&gt;&gt;1;           indexOf1++;       }       return indexOf1;   }   public boolean isBit1(int num,int indexOf1){       num=num&gt;&gt;indexOf1;       if((num&amp;1)==1){           return true;       }       else {           return false;       }   }</code></pre><p>题目二：数组中有一个数字只出现一次，而其他数字出现三次</p><p>思路：将数组中所有数字某一位的bit位加起来对3求余，余数就是只出现一次数字某一位bit位的数字</p><pre><code>public int singleNumber(int[] nums) {      if(nums==null||nums.length&lt;=0){            return -1;        }        int[] bitSum=new int[32];        int length=nums.length;        for (int i = 0; i &lt;length; i++) {            int bitMask=1;            for (int j = 0; j &lt;32 ; j++) {                if((nums[i]&amp;bitMask)!=0){                    bitSum[j]++;                }                bitMask=bitMask&lt;&lt;1;            }        }        int result=0;        for (int i = 31; i &gt;=0 ; i--) {            result=result&lt;&lt;1;            result+=bitSum[i]%3;        }        return result;    }</code></pre><h2 id="57-和为s的数字"><a href="#57-和为s的数字" class="headerlink" title="57.和为s的数字"></a>57.和为s的数字</h2><p>题目一：输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p><p>思路：定义两个指针指向头尾，然后如果他们相加小于s那么头指针就++；大于s尾指针++,左右逼近</p><pre><code>public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int sum) {                    ArrayList&lt;Integer&gt; result=new ArrayList&lt;&gt;();        if (array==null||array.length&lt;=1){                return result;            }            int i=0;            int j=array.length-1;            int max=array[j]*array[j-1];            while (i&lt;j){                if(array[i]+array[j]==sum){                    if(array[i]*array[j]&lt;max) {                        result.add(array[i]);                        result.add(array[j]);                        max=array[i]*array[j];                    }                    i++;                    j--;                }else if(array[i]+array[j]&lt;sum){                    i++;                }else {                    j--;                }            }            return result;    }</code></pre><p>其实这里并不需要判断他是不是最小的那个，当左右逼近时，乘积最小的那个数其实就是靠近最外围的。</p><p>题目二：和为s的连续整数序列<br>输入一个整数s，输出所有的和为s的连续整数序列</p><pre><code>输入 15输出 12345,456，78</code></pre><p>思路：定义两个指针small和big，数值等于1和2，然后从big++，比较此时的和与s，如果小于s，big++，如果大于s，就去掉small。让small指向2，循环往复，知道small大于或等于s的中间值。</p><pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) {         ArrayList&lt;ArrayList&lt;Integer&gt; &gt; result=new ArrayList&lt;&gt;();            if(sum&lt;3){                return result;            }            ArrayList&lt;Integer&gt; sequence=new ArrayList&lt;&gt;();            int small=1;            int big=2;            sequence.add(small);            sequence.add(big);            int middle=(sum+1)/2;            int currentSum=3;            while (small&lt;middle){                if(currentSum==sum){                    ArrayList&lt;Integer&gt; path=new ArrayList&lt;&gt;(sequence);                    result.add(path);                    big++;                    sequence.add(big);                    currentSum+=big;                }else if(currentSum&lt;sum){                    big++;                    sequence.add(big);                    currentSum+=big;                }else {                    currentSum-=small;                    small++;                    sequence.remove(0);                }            }            return result;    }</code></pre><h2 id="58-翻转字符串"><a href="#58-翻转字符串" class="headerlink" title="58.翻转字符串"></a>58.翻转字符串</h2><p>题目一：翻转单词顺序，</p><pre><code>输入： &quot;i am a student&quot;输出： &quot;student a am i&quot;</code></pre><p>这道题题目限制较松，不存在输入两边有空格的情况，中间的空格也不需要处理</p><pre><code> public String reverseWords(String s) {        if (s == null) {            return &quot;&quot;;        }        s=s.trim();        char[] str = s.toCharArray();        int length = str.length;        reverseString(str, 0, length - 1);        int begin=0;        for (int i = 1; i &lt; length; i++) {            if (str[i]==&#39; &#39;){                if(i-begin&lt;2){                    continue;                }                reverseString(str,begin,i-1);                begin=i+1;            }        }        if(begin&lt;length){            reverseString(str,begin,length-1);        }        return String.valueOf(str);    }    private void reverseString(char[] str, int start, int end) {        while (start &lt; end) {            char temp = str[start];            str[start] = str[end];            str[end] = temp;            start++;            end--;        }    }</code></pre><p>题目二：左旋转字符串<br>输入一个字符串和一个数字k，将前面k个字符转到后面</p><pre><code>输入： &quot;abcdefg&quot; 和2输出： &quot;cdefgab&quot;</code></pre><p>沿用上一题的reverseString函数，只需要三次调用即可解决</p><pre><code> public String leftRotateString(String s,int k){        if(s==null||s.length()==0||k&lt;0||k&gt;s.length()){            return &quot;&quot;;        }        char[] chars=s.toCharArray();        int length=chars.length;        reverseString(chars,0,chars.length-1);        reverseString(chars,0,length-1-k);        reverseString(chars,length-k,length-1);        return String.valueOf(chars);    }</code></pre><p>注意k的取值</p><h2 id="59-队列中的最大值"><a href="#59-队列中的最大值" class="headerlink" title="59.队列中的最大值"></a>59.队列中的最大值</h2><p>题目一：定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}，{2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}，{2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><p>思路：用一个双端队列，用于保存数字的下标</p><ol><li>当队列为空时直接加入数值的下标，当当前的数值的下标减去队列里第一个元素的下标大于等于滑动窗口大小k时，将对头移出</li><li>移出比队列中当前元素还小的值</li><li>从第三个数开始将对头元素录入结果集。<pre><code>public int[] maxSlidingWindow(int[] num, int k) {     if(num==null||num.length==0||k&lt;=0){         return new int[0];     }     ArrayDeque&lt;Integer&gt; queue=new ArrayDeque&lt;&gt;();     int length=num.length;     int[] maxValue=new int[length-k+1];     int j=0;     for (int i = 0; i &lt; length; i++) {         if (queue.isEmpty()){             queue.add(i);         }         if(i-queue.peekFirst()&gt;=k){             queue.pollFirst();         }         while (!queue.isEmpty()&amp;&amp;num[queue.peekLast()]&lt;=num[i]){             queue.pollLast();         }         queue.add(i);         if(i+2&gt;k){             maxValue[j++]=num[queue.peekFirst()];         }</code></pre></li></ol><pre><code>    }    return maxValue;}</code></pre><pre><code>题目二：请定义一个队列并实现函数max得到队列里的最大值，要求函数max、push_back和pop_front的时间复杂度都是O(1)。思路：用两个双端队列，一个队列用于存放最大值，一个队列按先进先出的顺序push和pop，这里定义一个内部类，将数值和他的index联系起来，存放最大值的队列依据于滑动窗口。</code></pre><p>class QueueWithMax {<br>    ArrayDeque<internaldata> data=new ArrayDeque&lt;&gt;();<br>    ArrayDeque<internaldata> maximum=new ArrayDeque&lt;&gt;();<br>    int curIndex=0;<br>    private class InternalData{<br>        int number;<br>        int index;<br>        public InternalData(int number,int index){<br>            this.number=number;<br>            this.index=index;<br>        }</internaldata></internaldata></p><pre><code>}public void push_back(int number){    InternalData internalData=new InternalData(number,curIndex);    data.add(internalData);    while (!maximum.isEmpty()&amp;&amp;maximum.peekLast().number&lt;=internalData.number){        maximum.pollLast();    }    maximum.add(internalData);    curIndex++;}public void pop_front(){    if(data.isEmpty()){        System.out.println(&quot;queue is empty&quot;);        return;    }    InternalData curData=data.pollFirst();    if(curData.index==maximum.peekFirst().index){        maximum.pollFirst();    }}public int max(){    if(data.isEmpty()){        System.out.println(&quot;queue is empty&quot;);        return 0;    }    return maximum.peekFirst().number;}</code></pre><p>}</p><pre><code>## 60.n个骰子的点数题目:把n个骰子扔在地上，朝上一面加起来的和，计算各种和的可能的概率。思路：递归,自顶向下定义一个大小为maxvalue-n+1的数组，来存储次数</code></pre><p>int g_maxValue=6;</p><pre><code>public void printProbability(int n){    if(n&lt;1){        return;    }    int maxValue=g_maxValue*n;    int[] probabilities=new int[maxValue-n+1];    for (int i = 1; i &lt;=g_maxValue ; i++) {            getProbability(n,n-1,i,probabilities);    }    double total=(int)Math.pow(g_maxValue,n);    for (int i = n; i &lt;=maxValue ; i++) {        double ratio=(double)probabilities[i-n]/total;//要将数组中的        System.out.println(ratio);    }}void getProbability(int original,int current,int sum,int[] probabilities){    if(current==0){        probabilities[sum-original]++;        return;    }    for (int i = 1; i &lt;=g_maxValue ; i++) {            getProbability(original,current-1,sum+i,probabilities);    }}</code></pre><pre><code>思路二：动态规划，定义两个大小为maxValue+1数组，存储次数，扔第一个骰子，那么从1到6都是1次，扔第二个骰子，有六种可能，那么和为n的概率就等于上一次n-1，n-2，n-3，n-4，n-5，n-6概率的总和，有点抽象，就是第二次可以扔出6种可能（1-6），那么和为7的次数，就等于上一次7-1,7-2,7-3,7-4,7-5,7-6的次数的总和</code></pre><p>public void printProbabilityByLoop(int n){<br>        if(n&lt;1){<br>            return;<br>        }<br>        int maxValue=n<em>g_maxValue;<br>        int[][] probabilities=new int[2][maxValue+1];<br>        int flag=1;<br>        for (int i = 1; i &lt;=g_maxValue ; i++) {<br>            probabilities[flag][i]=1;<br>        }<br>        for (int k = 2; k &lt;=n ; k++) {<br>            for (int j = 0; j &lt;k ; j++) {<br>                probabilities[1-flag][j]=0;<br>            }<br>            for (int j = k; j &lt;= g_maxValue</em>k; j++) {<br>                probabilities[1-flag][j]=0;<br>                for (int i = 1; i &lt;j&amp;&amp;i&lt;=g_maxValue ; i++) {<br>                    probabilities[1-flag][j]+=probabilities[flag][j-i];<br>                }</p><pre><code>        }        flag=1-flag;    }    double total=Math.pow(g_maxValue,n);    for (int i = n; i &lt;=maxValue ; i++) {        double ratio=(double)probabilities[flag][i]/total;        System.out.println(i+&quot; : &quot;+ratio);    }}</code></pre><pre><code>## 61.扑克牌中的顺子题目：给定一个数组，判断他是否是连续的，其中0可以为任何数字。排序后统计0的个数和间隔的个数，相比较</code></pre><p> public boolean isContinuous(int[] nums){<br>       if(nums==null||nums.length==0){<br>           return false;<br>       }<br>       Arrays.sort(nums);<br>       int numberOfZero=0;<br>       int numberOfGap=0;<br>       int length=nums.length;<br>       for (int i = 0; i &lt; length&amp;&amp;nums[i]==0; i++) {<br>           numberOfZero++;<br>       }<br>       int small=numberOfZero;<br>       int big=small+1;<br>       while (big&lt;length){<br>           if(nums[big]==nums[small]){<br>               return false;<br>           }<br>           numberOfGap+=nums[big]-nums[small]-1;<br>           small=big;<br>           big=small+1;<br>       }<br>       return numberOfGap&gt;numberOfZero?false:true;<br>   }</p><pre><code>## 62.约瑟夫环题目：0, 1, … , n-1 这n个数字排成一个圈圈，从数字0开始每次从圆圏里删除第m个数字。求出这个圈圈里剩下的最后一个数字。删除数字后，从删除数字后的下一个数字开始计数。思路：常规解法，创造一个环形链表</code></pre><p> public int lastRemaining(int n,int m){<br>        if(n&lt;=0||m&lt;=0){<br>            return -1;<br>        }<br>        ListNode pNode=createCircleList(n);<br>        int count=1;<br>        int alive=5;<br>        while (alive&gt;1){<br>            while (count&lt;m){<br>                pNode=pNode.next;<br>                if(pNode.value!=-1){<br>                    count++;<br>                }<br>            }<br>            pNode.value=-1;<br>            count=0;<br>            alive–;<br>        }<br>        int result=-1;<br>        for (int i = 0; i &lt;n ; i++) {<br>            if(pNode.value!=-1){<br>               result=pNode.value;<br>            }<br>            pNode=pNode.next;<br>        }<br>       return result;<br>    }<br>  public ListNode createCircleList(int n){<br>      ListNode pHead=new ListNode(0);<br>      ListNode curNode=pHead;<br>      for (int i = 1; i &lt;n ; i++) {<br>          ListNode pNode=new ListNode(i);<br>          curNode.next=pNode;<br>          curNode=curNode.next;<br>      }<br>      curNode.next=pHead;<br>      return pHead;<br>  }</p><pre><code>思路二：数学推导：具体我也没咋看懂，但代码很简洁，时间复杂度为O（n）.</code></pre><p>int lastRemainingByMath(int n,int m){<br>      if(n&lt;1||m&lt;1){<br>          return -1;<br>      }<br>      int last=0;<br>      for (int i = 2; i &lt;=n ; i++) {<br>          last=(last+m)%i;<br>      }<br>      return last;<br>  }</p><pre><code>## 63.股票的最大利润题目：给定一组按时间先后顺序的股票价格，求他们的最大利润</code></pre><p>输入：{9,8,5,7,12,16,14}<br>输出: 11 //16-5</p><pre><code>思路：求数组中的最大差异，当然大数要在小数后边，这里用动态规划，每次放入一个数，就求这个数与前面的数中最小的值的差，那么就是求这个差的最大值。</code></pre><p>public int getMaxDiff(int[] nums){<br>        if(nums==null||nums.length==0){<br>            return -1;<br>        }<br>        int length=nums.length;<br>        int min=nums[0];<br>        int diff=nums[1]-nums[0];<br>        for (int i = 2; i &lt;length; i++) {<br>            if(nums[i-1]&lt;min){<br>                min=nums[i-1];<br>            }<br>            int curDiff=nums[i]-min;<br>            if(curDiff&gt;diff){<br>                diff=curDiff;<br>            }</p><pre><code>    }    return diff;}</code></pre><pre><code>## 64.求1+2+3+...+n题目：不同if for while else swich case等关键字求1加到n思路：递归，这里用一个短路运算符&amp;&amp;用于循环的终止条件。</code></pre><p> public int getSum(int n){<br>        int result=n;<br>        int a=0;<br>        boolean value=(n&gt;0)&amp;&amp;(a==(result+=getSum(n-1)));<br>        return result;<br>    }</p><pre><code>## 65.不同加减乘除法做加法题目：不同+-x÷实现加法思路：用位运算，分三步走，第一步先异或，不考虑进位，第二步用与，计算进位，然后左移一步，第三再将异或后的值与进位相异或，那么这时候也有可能继续产生进位，循环下去。</code></pre><p>public int add(int num1,int num2){<br>       int sum;<br>       int carry;<br>       while (num2!=0){<br>           sum=num1^num2;<br>           carry=(num1&amp;num2)&lt;&lt;1;<br>           num1=sum;<br>           num2=carry;<br>       }<br>       return num1;<br>   }</p><pre><code>## 66.构建乘积数组题目:给定长度为 n 的整数数组 A，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</code></pre><p>输入: [1,2,3,4]<br>输出: [24,12,8,6]</p><pre><code>思路：这里不能用到除法，换个方向想，新建数组B，B[i]=A[0]+A[1]+A[2]+...+A[i-1]+A[i+1]+...+A[n-1],看成两部分，一一部分是A[0]+A[1]+A[2]+...+A[i-1],另一部分A[i+1]+...+A[n-1],那么分两部走，第一步从头开始A[0]+A[1]+A[2]+...+A[i-1]=B[i-1]*A[i-1],第二步从尾开始，不太好阐述，直接看代码</code></pre><p> public int[] multiply(int[] A){<br>       if(A==null||A.length==0) {<br>           return new int[0];<br>       }</p><pre><code>   int length=A.length;   int[] B=new int[length];   B[0]=1;   for (int i = 1; i &lt;length ; i++) {       B[i]=B[i-1]*A[i-1];   }   int temp=1;   for (int i = length-2; i&gt;=0 ; i--) {       temp*=A[i+1];       B[i]*=temp;   }   return B;</code></pre><p>   }<br>```</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章主要讲了应聘者所要具有的综合素质，包括编程能力，学习能了，沟通能力，发散思维能力，抽象建模能力，知识迁移能力。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>图解http总结</title>
      <link href="/2019/08/13/%E5%9B%BE%E8%A7%A3http%E6%80%BB%E7%BB%93/"/>
      <url>/2019/08/13/%E5%9B%BE%E8%A7%A3http%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>《图解http》精华总结</p><a id="more"></a><p><strong>注：鉴于大部分的笔记都在纸质笔记本上，这里只对《图解http》粗略记载一下重要的知识点，包括以后面试题中关于计算机网络的知识点都可以记载于此</strong></p><h2 id="第一章-Web网络基础"><a href="#第一章-Web网络基础" class="headerlink" title="第一章 Web网络基础"></a>第一章 Web网络基础</h2><h3 id="URI-与-URL"><a href="#URI-与-URL" class="headerlink" title="URI 与 URL"></a>URI 与 URL</h3><p>URI用字符串表示某一网络资源，URL表示资源的地点（互联网上所处的位置）。</p><h2 id="第二章-简单的http协议"><a href="#第二章-简单的http协议" class="headerlink" title="第二章 简单的http协议"></a>第二章 简单的http协议</h2><h3 id="2-1无状态协议"><a href="#2-1无状态协议" class="headerlink" title="2.1无状态协议"></a>2.1无状态协议</h3><p>HTTP协议不对请求和响应之间的通信状态进行保存，这时为了更快的处理大量事务，确保协议的可伸缩性。为了实现期望的保存状态的功能，于是引入了Cookie奇数。</p><h3 id="2-2-http-1-1-中的方法"><a href="#2-2-http-1-1-中的方法" class="headerlink" title="2.2 http/1.1 中的方法"></a>2.2 http/1.1 中的方法</h3><ul><li>GET 获取资源</li><li>POST 传输实体主体</li><li>PUT 传输文件</li><li>HEAD 获得报文首部</li><li>DELETE 删除文件</li><li>OPTIONS 询问指定资源支持的方法</li><li>TARCE 追踪路径</li><li>CONNECT 要求用隧道协议连接代理<h3 id="2-3-http的持久性连接"><a href="#2-3-http的持久性连接" class="headerlink" title="2.3 http的持久性连接"></a>2.3 http的持久性连接</h3>最初的http通信没进行一次就要断开一次tcp连接，但后来发展成了持久性连接：只要一方没有明确提出断开连接，则保持tcp连接状态。</li><li>管线化：http持久连接中，发送方不同等待响应即可直接发送另一个请求。</li></ul><h2 id="第三章-HTTP报文内的http信息"><a href="#第三章-HTTP报文内的http信息" class="headerlink" title="第三章 HTTP报文内的http信息"></a>第三章 HTTP报文内的http信息</h2><p>用于http协议交互的信息被称为http报文。请求端的称为请求报文，响应端称为响应报文。<br>http报文分为报文首部和报文主体，两者用空行（CR+LF）来划分。通常，并不一定要有报文主体。</p><h3 id="3-1-结构"><a href="#3-1-结构" class="headerlink" title="3.1 结构"></a>3.1 结构</h3><p>报文首部分为请求行/状态行 ，以及首部字段<br>首部字段有四种：通用首部，请求首部，响应首部，实体首部。</p><ol><li>通用首部：请求和响应报文两方都会使用的首部</li><li>请求首部： 请求方报文使用的首部，包括请求的附加内容，客户端信息，响应内容相关优先级等信息</li><li>响应首部：响应报文中的</li><li>实体首部：针对响应报文和请求报文中的实体部分使用的首部，与实体有关的信息<h3 id="3-2-编码"><a href="#3-2-编码" class="headerlink" title="3.2 编码"></a>3.2 编码</h3>在传输过程中通过编码提升速率。</li></ol><ul><li>报文：http通信的基本单位，由8位组字节流组成</li><li>实体：作为请求和响应的有效载荷数据被传输，由首部和主体组成<br>通常报文主体等于实体主体，只有当传输进行编码操作时，实体主体才会发生变化。</li></ul><h2 id="第四章-状态码"><a href="#第四章-状态码" class="headerlink" title="第四章 状态码"></a>第四章 状态码</h2><p>状态码告知服务器端返回的请求结果</p><h3 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h3><p>信息性状态码，指接受的请求正在处理，继续下一步</p><h3 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h3><p>表明请求被正常处理</p><ol><li>200 OK<br>客户端发来的请求已被正常处理了</li><li>204 NOT CONTENT<br>客户端发来的请求已被正常处理了，但返回的响应中不含实体的主体部分。</li><li>206 Partial Content<br>表明客户端进行了范围请求</li></ol><h3 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h3><p>表明浏览器需要进行特殊的处理以正确处理请求</p><ol><li>301 Moved Permanently<br>永久性重定向，表示请求资源已被永久分配到新的URI上了</li><li>302 Found<br>临时性重定向</li><li>303 See Other<br>表示请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源</li><li>304 Not Modeified<br>表明资源已找到，但发生请求未满足条件的情况，直接返回304,304虽然划分在3xx中，但跟重定向没关系。</li><li>307 Temporary Redirect<br>临时性重定向</li></ol><h3 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h3><p>表明客户端是发生错误的原因所在</p><ol><li>400 Bad Request<br>请求报文中发生语法错误</li><li>401 Unauthrorized<br>表明发送的请求需要http认证，当浏览器初次接受到401时，会弹出认证的对话窗口</li><li>403 Forbidden<br>表明请求的资源被服务器设置为拒绝访问</li><li>404 Not Found<br>服务器无法找到请求的资源</li></ol><h3 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h3><ol><li>500 Internal Server Error<br>服务器在执行请求时发生了故障</li><li>503 Service Unvailable<br>服务器处于超负荷和停机维护状态</li></ol><h2 id="第五章-Web服务器"><a href="#第五章-Web服务器" class="headerlink" title="第五章 Web服务器"></a>第五章 Web服务器</h2><p>一台http服务器可以搭建多个web站点，里用虚拟主机（virtua host，又称虚拟服务器）的功能。<br>但因为一台主机的ip地址是相同的，所有在发送http请求时，必须在host首部内完整指定主机名或域名的URI</p><h3 id="通信数据转发程序"><a href="#通信数据转发程序" class="headerlink" title="通信数据转发程序"></a>通信数据转发程序</h3><ol><li>代理<br>代理服务器的基本行为就接收客户端发送的请求然后传给服务器。<ul><li>缓存代理：缓存代理会预先将资源的副本保存在代理服务器上，当代理接收到相同资源的请求，会直接将缓存的副本串给客户端，而不去访问源服务器。缓存有时间期限，客户端也可以有缓存。</li><li>透明代理： 转发请求或响应时，会对报文进行加工</li></ul></li><li>网关<br>网关的工作机制和代理相似，但网关能使通信线路上的服务器提供非http协议服务。利用网关的加密特性能提高通信的安全性。</li><li>隧道<br>隧道通常在相隔甚远的服务器和客户端之间进行中转，他的目的是让他们之间进行安全的通信，使用SSL等加密手段。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java集合详解</title>
      <link href="/2019/08/11/java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/08/11/java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-集合是什么"><a href="#1-集合是什么" class="headerlink" title="1.集合是什么"></a>1.集合是什么</h2><a id="more"></a><p>java集合类存放于java.util包中，是用来存放对象的容器<br>注意:</p><ol><li>集合只能存放对象。比如你存一个 int 型数据 1放入集合中，其实它是自动转换成 Integer 类后存入的，Java中每一种基本类型都有对应的引用类型</li><li>集合存放的是多个对象的引用，对象本身还是在堆内存</li></ol><h2 id="2-集合框架图"><a href="#2-集合框架图" class="headerlink" title="2.集合框架图"></a>2.集合框架图</h2><img src="/2019/08/11/java集合详解/1.png"><p>迭代器（iterator）是一个对象， 它的工作时遍历并选择序列中的对象，它提供了一中访问容器对象中的各个元素，而又不必暴露该对象内部细节的方法。通过迭代器，开发人员不需要了解容器底层的结构，就可以实现对容器的遍历。由于创建迭代器的代价小，因此迭代器通常被称为轻量级的容器。</p><p>它的子接口listIterator在此基础上增加了三种方法，add，previous，hasPrevious，List集合实现的是这个接口，支持在迭代期间向List中添加或删除元素，并且可以在List中双向滚动。</p><p>还有一个特点就是抽象类的使用。如果要自己实现一个集合类，去实现那些抽象的接口会非常麻烦，工作量很大。这个时候就可以使用抽象类，这些抽象类中给我们提供了许多现成的实现</p><p>Iterator:迭代器，它是Java集合的顶层接口（不包括 map 系列的集合，Map接口 是 map 系列集合的顶层接口）<br>Collection:List和Set接口的父接口</p><h2 id="3-集合详解"><a href="#3-集合详解" class="headerlink" title="3.集合详解"></a>3.集合详解</h2><h3 id="Set的无序性问题"><a href="#Set的无序性问题" class="headerlink" title="Set的无序性问题"></a>Set的无序性问题</h3><p>顺序有两个概念：</p><ol><li>按照添加的顺序排列</li><li>按照自然循序a-z，1-无穷，</li></ol><p>Set中HashSet它不能保证自然顺序，也不能保证自然顺序，而set的其他实现类是可以实现这两种顺序的<br>1，LinkedHashset : 保证元素添加的顺序</p><p>2，TreeSet : 保证元素的自然顺序，treeset底层是红黑树</p><pre><code>import java.util.HashSet;import java.util.LinkedHashSet;import java.util.Set;import java.util.TreeSet;public class Prectice {    public static void main(String[] args) {        Set&lt;String&gt; set = new HashSet&lt;&gt;();        set.add(&quot;String1&quot;);        set.add(&quot;String4&quot;);        set.add(&quot;String3&quot;);        set.add(&quot;String2&quot;);        set.add(&quot;String5&quot;);        set.forEach(e-&gt; System.out.print(e+&quot; &quot;));        System.out.println();        //LinkedHashSet会保证元素的添加顺序        Set&lt;String&gt; set2 = new LinkedHashSet&lt;&gt;();        set2.add(&quot;String1&quot;);        set2.add(&quot;String5&quot;);        set2.add(&quot;String3&quot;);        set2.add(&quot;String4&quot;);        set2.add(&quot;String2&quot;);        set2.forEach(e-&gt; System.out.print(e+&quot; &quot;));        System.out.println();        //TreeSet保证元素自然顺序        Set&lt;String&gt; set3 = new TreeSet&lt;&gt;();        set3.add(&quot;String1&quot;);        set3.add(&quot;String5&quot;);        set3.add(&quot;String4&quot;);        set3.add(&quot;String2&quot;);        set3.add(&quot;String3&quot;);        set3.forEach(e-&gt; System.out.print(e+&quot; &quot;));    }}</code></pre><p>输出结果：</p><p>String5 String4 String3 String2 String1       HashSet元素乱序,这里因为他是<br>String1 String5 String3 String4 String2       LinkedHashSet保证元素添加顺序</p><p>String1 String2 String3 String4 String5       TreeSet元素按自然顺序排序</p><h3 id="Hashset中输出元素为什么是“有序的”？"><a href="#Hashset中输出元素为什么是“有序的”？" class="headerlink" title="Hashset中输出元素为什么是“有序的”？"></a>Hashset中输出元素为什么是“有序的”？</h3><p>JDK1.8中hashset的实现变了，又因为插入的是Integer，其hashcode返回就是其自身，所以在对象hashCode这一步引入了巧合的“按大小排序”。然后HashMap.hash(Object)获取了对象的hashCode()之后会尝试进一步混淆，JDK8版java.util.HashMap内的hash算法比JDK7版的混淆程度低；在[0, 2^32-1]范围内经过HashMap.hash()之后还是得到自己。 </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer算法题</title>
      <link href="/2019/08/11/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98-%E4%BC%98%E5%8C%96%E6%95%88%E7%8E%87%E7%AF%87/"/>
      <url>/2019/08/11/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98-%E4%BC%98%E5%8C%96%E6%95%88%E7%8E%87%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="优化效率篇"><a href="#优化效率篇" class="headerlink" title="优化效率篇"></a>优化效率篇</h1><a id="more"></a><h2 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39.数组中出现次数超过一半的数字"></a>39.数组中出现次数超过一半的数字</h2><p>题目：输入一个数组，如果一个数字出现的次数超过一半，就输出它，没有则返回-1。</p><p>思路：可以考虑先将数组排序，然后取中位数，时间复杂度是O（nlogn）<br>下面介绍两种思路</p><p>####1. 基于partition函数的时间复杂度为O（n）的算法<br>我们只需要找中位数，那么它两边的数是否已排序不用管<br>用基于快速排序的partition函数，随机取数，然后划分，每次返回该数的下标，如果下标小于n/2，那么中位数应该位于它的右边，如果下标大于n/2，那么中位数应该位于它的左边<br>找到还要判断它的次数是否超过一半</p><pre><code>  public int moreThanHalfNum(int[] numbers) {        if(numbers==null||numbers.length==0){            return 0;        }        int length=numbers.length;        int mid=length&gt;&gt;1;        int start=0;        int end=length-1;        int index=partition(numbers,start,end);        while (index!=mid){            if(index&lt;mid){                start=index+1;                index=partition(numbers,start,end);            }else {                end=index-1;                index=partition(numbers,start,end);            }        }        if(!checkNum(numbers,length,numbers[index])) {            numbers[index]=0;        }        return numbers[index];    }    public int partition(int[] numbers,int start,int end){        if(start&gt;end){            return -1;        }        int i=start;        int j=end;        int pivot=numbers[start];        while (i&lt;j){            while (i&lt;j&amp;&amp;numbers[j]&gt;=pivot){                j--;            }            while (i&lt;j&amp;&amp;numbers[i]&lt;=pivot){                i++;            }            if(i&lt;j){                int temp=numbers[i];                numbers[i]=numbers[j];                numbers[j]=temp;            }        }        int temp=numbers[start];        numbers[start]=numbers[j];        numbers[j]=temp;            return j;    }    public boolean checkNum(int[] numbers,int length,int result){        int time=0;        for (int i = 0; i &lt;length ; i++) {            if(numbers[i]==result){                time++;            }        }//        System.out.println(time);        return time*2&gt;length;    }</code></pre><p>####2. 基于数组特点的时间复杂度为O（n）的算法<br>思路：这个数出现的次数比其他数字出现次数的总和还多，定义一个变量用来保存数，一个变量times用来计数，当下一个数与当前数不同，times–，相同就times++，当times等于0时，就把下一个数作为变量保存下来，那么最后的数一定是次数最多的那个（如果存在）。</p><pre><code> public int moreThanHalf(int[] numbers){        if(numbers==null||numbers.length&lt;=0){            return 0;        }        int length=numbers.length;        int time=0;        int result=0;        for (int i = 0; i &lt; length; i++) {            if(time==0){                result=numbers[i];                time=1;            }            else if(numbers[i]!=result) {                time--;            }else {                time++;            }        }        if(!checkNum(numbers,length,result)){            result=0;        }        return result;    }</code></pre><h2 id="40-最小的k个数"><a href="#40-最小的k个数" class="headerlink" title="40.最小的k个数"></a>40.最小的k个数</h2><p>题目：输入n个整数，找出其中最小的k个数，</p><pre><code>输入 [4,5,1,6,2,7,3,8]输入最小的4个数字：1,2,3,4</code></pre><p>思路：</p><p>####1. 基于partition函数的时间复杂度为O（n）的算法<br>仍然沿用上一题的parttition函数，当返回的index小于k-1时，那么第k个大的数就在右边，当返回的index大于k-1，那么第k个大的数就在左边</p><pre><code>public int[] getNumbers(int[] input, int k) {        if (input == null || input.length &lt;= 0 || k == 0 || input.length &lt; k) {            return null;        }        int length = input.length;        int[] result = new int[k];        int start = 0;        int end = length - 1;        int index = partition(input, start, end);        while (index != k - 1) {            if (index &gt; k - 1) {                end = index - 1;                index = partition(input, start, end);            } else {                start = index + 1;                index = partition(input, start, end);            }        }        for (int i = 0; i &lt; k; i++) {            result[i] = input[i];        }        return result;    }</code></pre><h4 id="2-基于Treeset集合的时间复杂度为O-nlogk-的算法（适合处理海量数据）"><a href="#2-基于Treeset集合的时间复杂度为O-nlogk-的算法（适合处理海量数据）" class="headerlink" title="2.基于Treeset集合的时间复杂度为O(nlogk)的算法（适合处理海量数据）"></a>2.基于Treeset集合的时间复杂度为O(nlogk)的算法（适合处理海量数据）</h4><p>我们先创建一个大小为k的数据容器，用来存储最小的k个数，依次遍历输入的数组，当容器没满时，就直接将数加入进去，当容器满了，就要比较当前的数与容器中最大的数，若小于就要容器中最大的数移出，并加入当前的数。<br>这个容器可以用红黑树，从而保证查找，删除和插入操作都只需要O（logk）的时间</p><pre><code>   public int[] getNumbersByTree(int[] input, int k) {        if (input == null || input.length &lt;= 0 || k == 0 || input.length &lt; k) {            return null;        }        int[] result = new int[k];        TreeSet&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;();        int length = input.length;        for (int i = 0; i &lt; length; i++) {            if (treeSet.size() &lt; k) {                treeSet.add(input[i]);            } else {                int max = treeSet.last();                if (max &gt; input[i]) {                    treeSet.remove(max);                    treeSet.add(input[i]);                }            }        }        int i=0;        for (int n:treeSet             ) {            result[i]=n;            i++;        }        return result;    }</code></pre><p>第一种解法会改变输入的数组，但速度快，第二解法不会改变原来的数组，虽然速度慢点，但适合处理海量数据，由于内存的大小有限，不可能把海量的数据一次载入内存，</p><h2 id="41-数据流的中位数"><a href="#41-数据流的中位数" class="headerlink" title="41.数据流的中位数"></a>41.数据流的中位数</h2><p>题目：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>思路：</p><img src="/2019/08/11/剑指offer算法题-优化效率篇/1.PNG"><p>AVL树的实现过于复杂，这里使用两个堆来解决<br>一个是最大堆（最大的元素在堆顶），一个是最小堆</p><ul><li><p>当堆中的数（总共的数）是偶数时，要插入一个新的数，先将数插入最大堆，然后将最大堆的最大的数插入最小堆，这时总数为奇数，取最大堆堆顶元素为中位数</p></li><li><p>当堆中的数为奇数时，要插入一个新的数，先将数插入最小堆，在将最小堆堆顶元素插入最大堆，这时总数为偶数，取最小堆和最大堆的堆顶元素的平均值。</p><pre><code>public class Solution {  private int count=0;  private PriorityQueue&lt;Integer&gt; minHeap=new PriorityQueue&lt;&gt;();  private PriorityQueue&lt;Integer&gt; maxHeap=new PriorityQueue&lt;&gt;(15, new Comparator&lt;Integer&gt;() {      @Override      public int compare(Integer o1, Integer o2) {          return o2-o1;      }//PriorityQueue默认是最小堆。  });  public void insert(int num){      if((count&amp;1)==0){          maxHeap.offer(num);          minHeap.offer(maxHeap.poll());      }      else {          minHeap.offer(num);          maxHeap.offer(minHeap.poll());      }      count++;  }  public Double getMedian(){      if((count&amp;1)==0){          return (double) (minHeap.peek() + maxHeap.peek()) /2;      }      else {          return (double)minHeap.peek();      }  }}</code></pre></li></ul><pre><code>## 42.连续子数组的最大和题目：给定一个数组arr，数组中的元素有整数也有负数，数组中的一个或者连续多个数组成一个子数组。求所有子数组里面的最大和。例如现在有数组 {1 ， -2 ， 3 ， 10 ， -4 ， 7 ， 2 ， -5 }。要求时间复杂度为O（n）思路：暴力法不可行，* 动态规划    {% asset_img 2.PNG %}    当前面的数加起来等于负数，那么就抛弃前面的数的和，sum=当前的数，如果加起来的等于正，sum=sum+当前的数，</code></pre><p>  public int findGreatestSumOfSubArray(int[] arr){<br>        if(arr==null||arr.length&lt;0){<br>            return 0;<br>        }<br>        int currentSum=0;<br>        int nGreatestSum=0;<br>        for (int i = 1; i &lt;arr.length; i++) {<br>            if(currentSum&lt;=0){</p><pre><code>            currentSum=arr[i];        }else {            currentSum+=arr[i];        }        if(currentSum&gt;nGreatestSum){            nGreatestSum=currentSum;        }    }    return nGreatestSum;}</code></pre><pre><code>**下面两题偏向于找规律**## 43.1到n整数中1出现的个数题目:输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数。例如输入12，从1到12这些整数中包含1的数字有1，10，11和12，1一共出现了5次。思路：这里书上说的晦涩难懂，参考一篇博客&lt;https://blog.csdn.net/yi_afly/article/details/52012593&gt;从个位分析，找出每位1出现的规律{% asset_img 3.PNG %}这里的former是指weight前面所有位的数，不单单指前面一个位</code></pre><p>public int timesOf1(int n){<br>      int base=1;<br>      int round=n;<br>      int weight=0;<br>      int former=0;<br>      int sum=0;<br>      while (round&gt;0){<br>          weight=round%10;<br>          round=round/10;<br>          if(weight==0){<br>              sum+=round<em>base;<br>          }else if(weight==1){<br>              sum+=round<em>base+former+1;<br>          }else {<br>              sum+=round</em>base+base;<br>          }<br>          base</em>=10;<br>          former=n%base;<br>      }<br>      return sum;<br>  }</p><pre><code>复杂度：O（logn）## 43.数字序列中某一位的数字数字按照0123456789101112131415161718192021…的顺序排列。第5位（从0开始计数）为5，第13位为1，第19位为4…… 求任意第n位对应的数字。思路：找规律，分三步找：1. 找出该数是几位数，1位数有10个，2位数有90个所有当index大于10+90*2时，那么他的位数肯定大于2。2. 找出这个数的数值，可以从他位于n位数的第几个开始着手，比如输入218，219&gt;190，所以他是三位数，三位数从100开始，219-190=29,29=3*9+2，所以他为了三位数的第9个数，等于109（这里从100开始数，数到108后还有两位，所以是第9个数）3. 那么它就位于109的第二位（从高位数）</code></pre><p>public int digitAtIndex(int index) {<br>        if (index &lt; 0) {<br>            return -1;<br>        }<br>        if (index &lt; 10) {<br>            return index;<br>        }<br>        int length = lengthOfNum(index);//这个数的位数<br>        int number = numberBeforeLength(length);//数的长度前面有多少个，比如输入3，前面有90*2+10=190个数字<br>        int indexOfNum = (index - number) % length;//在这个数的第几个，<br>        int countOfNumber = (index - number - indexOfNum) / length;//在n位数的中的第几位<br>        int thisNum = (int) (Math.pow(10, length - 1) + countOfNumber);//index所对应的数字<br>        int digit= digitAtIndexOfNum(thisNum,length-1-indexOfNum);//因为indexOfNum是从前面数的，要从低位数<br>        return digit;</p><pre><code>}int digitAtIndexOfNum(int num,int indexOfThisNum){    int n=0;    int digit=0;    while (n&lt;=indexOfThisNum){        digit=num%10;        num/=10;        n++;    }    return digit;}public int lengthOfNum(int index) {    int n = 2;    int sum = 10;    int base = 10;    while (sum &lt; index) {        sum += n * base * 9;        n++;        base *= 10;    }    return n - 1;}public int numberBeforeLength(int length) {    int n = 2;    int base = 10;    int sum = 10;    while (n &lt; length) {        sum += n * base * 9;        n++;        base *= 10;    }    return sum;}</code></pre><pre><code>## 45.把数组排成最小的数题目：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。思路：引入一个新的排序规则，两个数n和m，如果nm&gt;mn，那么n&gt;m，这nm指的是字符串相加，如：1和2，那么nm=12.现将所有数按照这种规则排列，排列后的顺序就是最小数字的排列顺序。</code></pre><p>  public String printMinNumber(int[] numbers){<br>       if(numbers==null||numbers.length&lt;=0){<br>           return null;<br>       }<br>       List<integer> list = new ArrayList<integer>();<br>       for (int n: numbers<br>            ) {<br>           list.add(n);</integer></integer></p><pre><code>   }   Collections.sort(list, new Comparator&lt;Integer&gt;() {       @Override       public int compare(Integer o1, Integer o2) {           String s1 = String.valueOf(o1);           String s2 = String.valueOf(o2);           String str1 = s1+s2;           String str2 = s2+s1;           return str1.compareTo(str2);       }   }) ;   StringBuilder str=new StringBuilder();   for (int n:list        ) {       str.append(n);   }   return str.toString();</code></pre><p>   }</p><pre><code>## 46.把数组排成最小的数题目：给定一个数字，按照如下规则翻译成字符串：0翻译成“a”，1翻译成“b”…25翻译成“z”。一个数字有多种翻译可能，例如12258一共有5种，分别是bccfi，bwfi，bczi，mcfi，mzi。实现一个函数，用来计算一个数字有多少种不同的翻译方法。思路：自上而下，从最大的问题开始，递归 ：</code></pre><pre><code>                 12258               /       \          b+2258       m+258          /   \         /   \      bc+258 bw+58  mc+58  mz+8      /  \      \        \     \  bcc+58 bcz+8   bwf+8   mcf+8  mzi    /        \       \     \</code></pre><p>   bccf+8        bczi    bwfi   mcfi<br>     /<br> bccfi</p><pre><code>有很多子问题被多次计算，比如258被翻译成几种这个子问题就被计算了两次* 递归</code></pre><p>public int getTranslationCount(int number){<br>     if(number&lt;0){<br>         return 0;<br>     }<br>     String num=String.valueOf(number);<br>     char[] numbers=num.toCharArray();<br>     int length=numbers.length;<br>     return getTranslationCountCore(numbers,length);</p><p> }<br> int getTranslationCountCore(char[] numbers,int length,int start,int count){<br>     if(start&gt;=length-1){<br>         return 1;<br>     }<br>     int digit1=numbers[start]-‘0’;<br>     int digit2=numbers[start+1]-‘0’;<br>     int converted=digit1*10+digit2;</p><pre><code> if(converted&gt;=10&amp;&amp;converted&lt;=25){     count=getTranslationCountCore(numbers,length,start+2,count)             +getTranslationCountCore(numbers,length,start+1,count); } else {     count=getTranslationCountCore(numbers,length,start+1,count); } return count;</code></pre><p> }</p><pre><code>* 动态规划</code></pre><p>public int getTranslationCount(int number){<br>     if(number&lt;0){<br>         return 0;<br>     }<br>     String num=String.valueOf(number);<br>     char[] numbers=num.toCharArray();<br>     int length=numbers.length;<br>     return getTranslationCountCore(numbers,length);</p><p> }<br>  int getTranslationCountCore(char[] numbers,int length){<br>     int[] counts=new int[length];</p><pre><code> for (int i = length-1; i &gt;=0 ; i--) {     int count=0;     if(i&lt;length-1){         count=counts[i+1];     }else {         count=1;     }     if(i&lt;length-1){         int digit1=numbers[i]-&#39;0&#39;;         int digit2=numbers[i+1]-&#39;0&#39;;         int converted=digit1*10+digit2;         if(converted&gt;9&amp;&amp;converted&lt;26){             if(i==length-2){                 count+=1;             }else {                 count += counts[i + 2];             }         }     }     counts[i]=count; } return counts[0];</code></pre><p> }</p><pre><code>## 47.礼物的最大价值题目：在一个m*n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向左或者向下移动一格，知道到达棋盘的右下角。给定一个棋盘及其上面的礼物，请计算你最多能拿多少价值的礼物？思路：动态规划，f(i,j)=max(f(i-1,j),f(i,j-1))+gift(i,j),用循环来做，比递归效率高，需要借助一个辅助的二维数组</code></pre><p>public int getMaxValue(int[][] number) {<br>     if(number==null||number.length&lt;=0){<br>         return 0;<br>     }<br>     int col=number[0].length;<br>     int row=number.length;<br>     return getMaxValueCore1(number,row,col);<br> }<br> int getMaxValueCore(int[][] number,int row,int col){<br>     int[][] maxVaule=new int[row][col];<br>     for (int i = 0; i &lt;row ; i++) {<br>         for (int j = 0; j &lt;col ; j++) {<br>             int left=0;<br>             int up=0;<br>             if(i&gt;0){<br>                 left=maxVaule[i-1][j];<br>             }<br>             if(j&gt;0){<br>                 up=maxVaule[i][j-1];<br>             }<br>             maxVaule[i][j]=Math.max(left,up)+number[i][j];<br>         }<br>     }<br>     return maxVaule[row-1][col-1];<br> }</p><pre><code>**优化空间**遍历顺序是从左至右，从上到下每次计算拿到的礼物最大值的时候，最大值的坐标只依赖(i-1,j)and(i,j-1)两个格子，因此第i-2行及以上所有的格子礼物最大值没有必要保存下来，因此可以用一维数组代替二维数组，一维数组的长度为棋盘的列数，当我们计算坐标为(i,j)格子能够拿到礼物的最大价值f(i,j)的时候，数组钱j个数字分别是f(i,0),f(i,1)...,f(i,j-1)，数组从下标为j的数字开始到最后一个数字，分别为f(i-1,j),f(i-1,j+1),...,f(i-1,n-1)，也就是数组前面j个数字分别是当前第i行前面j个格子礼物的最大值，而后的数字分别保存前面第i-1行n-j个格子礼物的最大值。</code></pre><p>int getMaxValueCore1(int[][] number,int row,int col){<br>        int[] maxVaule=new int[col];<br>        for (int i = 0; i &lt;row ; i++) {<br>            for (int j = 0; j &lt;col ; j++) {<br>                int left=0;<br>                int up=0;<br>                if(i&gt;0){<br>                    left=maxVaule[j];<br>                }<br>                if(j&gt;0){<br>                    up=maxVaule[j-1];<br>                }<br>                maxVaule[j]=Math.max(left,up)+number[i][j];<br>            }<br>        }<br>        return maxVaule[col-1];<br>    }</p><pre><code>## 48.最长不含重复字符的子字符串最长不重复子串：一个字符串中最长的没有重复字符的子串。思路：动态规划，当当前字符(i)与与前面的字符没有重复，那么f(i)=f(i-1)+1,如果重复，就计算重复字符之间的距离d与f(i-1)想比较，若d较大，那么f（i）=f(i-1)+1，否则f（i）=d;怎么判断当前字符与前面的字符重复，可以用一个大小为26的int数组，初始化为-1，那么字符’a&#39;的在数组的位置就是0，0对应的值就是上次他出现在字符串的下标</code></pre><p>public int longestSubString(String str) {<br>     if(str==null||str.length()&lt;=0){<br>         return -1;<br>     }<br>     char[] strs=str.toCharArray();<br>     int[] position=new int[26];<br>     for (int i = 0; i &lt;26; i++) {<br>         position[i]=-1;<br>     }<br>     int curLength=0;<br>     int maxLength=0;<br>     int length=strs.length;<br>     for (int i = 0; i &lt;length ; i++) {<br>         int preIndex=position[strs[i]-‘a’];<br>         if(preIndex&lt;0||i-preIndex&gt;curLength){<br>             curLength++;<br>         }else {<br>             if(curLength&gt;maxLength){<br>                 maxLength=curLength;<br>             }<br>             curLength=i-preIndex;</p><pre><code>     }     position[strs[i]-&#39;a&#39;]=i;     if(curLength&gt;maxLength){         maxLength=curLength;     } } return maxLength;</code></pre><p> }</p><pre><code>## 49.丑数编写一个程序，找出第 n 个丑数。丑数就是只包含质因数 2, 3, 5 的正整数。思路：创建一个大小为n的数组，用于储存丑数，按大小依次求出丑数，假设之前的丑数存起来了，那么下一个丑数就是用2，3,5分别乘某一个丑数（这个丑数必须大于之前丑数最大的），然后取三者最小的，作为下一个，有点抽象。</code></pre><p>public int getUglyNumber(int index) {<br>        if (index &lt; 0)<br>            return 0;<br>        int[] uglyNumbers = new int[index];<br>        uglyNumbers[0] = 1;<br>        int nextUglyNumberIndex = 1;<br>        int multiply2 = 0;<br>        int multiply3 = 0;<br>        int multiply5 = 0;<br>        for (int i = 1; i &lt; index; i++) {<br>            int min = min(uglyNumbers[multiply2] * 2, uglyNumbers[multiply3] * 3, uglyNumbers[multiply5] * 5);<br>            uglyNumbers[nextUglyNumberIndex] = min;<br>            while (uglyNumbers[multiply2] * 2 &lt;= min) {//必须是大于min时跳出循环<br>                multiply2++;<br>            }<br>            while (uglyNumbers[multiply3] * 3 &lt;= min) {<br>                multiply3++;<br>            }<br>            while (uglyNumbers[multiply5] * 5 &lt;= min) {<br>                multiply5++;<br>            }<br>            nextUglyNumberIndex++;</p><pre><code>    }    return uglyNumbers[index - 1];}int min(int number1, int number2, int number3) {    int min = number1 &gt; number2 ? number2 : number1;    return min &lt; number3 ? min : number3;}</code></pre><pre><code>## 50.第一个只出现一次的字符题目：在字符串中找出第一个只出现一次的字符。如输入&quot;abaccdeff&quot;，则输出&#39;b&#39;.思路: 这题用空间来换时间，用一个大小为256个字符的哈希表来存储字符出现的次数，然后在遍历一次字符串，找到第一个出现一次的字符，时间复杂度O(n),空间复杂度是常数所以是o(1)应为char是1个字节的（8bit）最大只有256</code></pre><p>public Character findFirstNotRepeatChar(String str)  {<br>        if(str==null||str.length()&lt;=0){<br>            return  null;<br>        }<br>        HashMap&lt;Character,Integer&gt; table=new HashMap&lt;&gt;(256);<br>        char[] strs=str.toCharArray();<br>        int length=strs.length;<br>        for (int i = 0; i &lt;length; i++) {<br>            table.put(strs[i],table.getOrDefault(strs[i],0)+1);<br>        }<br>        for (int i = 0; i &lt;length ; i++) {<br>            if(table.get(strs[i])==1) {<br>                return strs[i];<br>            }<br>        }<br>        return null;<br>    }</p><pre><code>## 51.数组中的逆序对题目：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。</code></pre><p>输入： 7,5,6，4<br>输出： 5</p><pre><code>思路：基于归并排序，先将数组划分成一个一个的数，比较两个相邻数之间的大小，计算逆序的个数，然后排序，再比较两个相邻已排序的数组之间的逆序个数，比较两个相邻已排序数组之间的逆序个数时，分别用两个指针指向两个数组的最大值，也就是最大的下标，如果第一个数组的指针的值大于第二个指针对应的值，那么第二个指针前面的所有值就是逆序的个数。</code></pre><p>public int inversePairs(int[] data){<br>        if(data==null||data.length&lt;=0){<br>            return 0;<br>        }<br>        int length=data.length;<br>        int[] copy=new int[length];<br>        return inversePairsCore(data,copy,0,length-1);</p><pre><code>}public int inversePairsCore(int[] data,int[] copyOfData,int start,int end){    if(start==end){        return 0;    }    int mid=(start+end)/2;    int left=inversePairsCore(data,copyOfData,start,mid);    int right=inversePairsCore(data,copyOfData,mid+1,end);    int i=mid;    int j=end;    int copyIndex=end;    int count=0;    while (i&gt;=start&amp;&amp;j&gt;=mid+1){        if(data[i]&gt;data[j]){            copyOfData[copyIndex--]=data[i--];            count+=j-mid;        }else {            copyOfData[copyIndex--]=data[j--];        }    }    for (;i&gt;=start;i--){        copyOfData[copyIndex--]=data[i--];    }    for (;j&gt;=mid+1;j--){        copyOfData[copyIndex--]=data[j--];    }    for (int k = start; k &lt;=end ; k++) {        data[k]=copyOfData[k];    }    return left+right+count;}</code></pre><pre><code>## 52.两个链表的第一个公共节点题目：输入两个链表，找出它们的第一个公共结点。思路：两个链表如果含有公共节点，那么就是一个Y字形，可以用两个辅助栈来保存链表节点，从栈顶也就链表尾节点，来比较，空间复杂度和时间复杂度都是O(M+N)。另一种思路是：求出两个链表的长度，然后用两个指针指向两个链表的头节点，让较长链表的指针先走x步（x为两个链表长度之差），然后两个指针再同时走，走到相同节点为止。</code></pre><p>public ListNode getFirstCommonNode(ListNode pHead1,ListNode pHead2){<br>        if(pHead1==null||pHead2==null){<br>            return null;<br>        }<br>        int length1=getListLength(pHead1);<br>        int length2=getListLength(pHead2);<br>        int minusOfLength;<br>        ListNode pListHeadLong=pHead2;<br>        ListNode pListHeadShort=pHead1;<br>        minusOfLength=length2-length1;<br>        if(length1&gt;length2) {<br>            pListHeadLong=pHead1;<br>            pListHeadShort=pHead2;<br>            minusOfLength=length1-length2;<br>        }</p><pre><code>    for (int i = 0; i &lt;minusOfLength; i++) {        pListHeadLong=pListHeadLong.next;    }    while (pListHeadLong!=null&amp;&amp;pListHeadShort!=null&amp;&amp;pListHeadLong!=pListHeadShort){        pListHeadLong=pListHeadLong.next;        pListHeadShort=pListHeadShort.next;    }    return pListHeadLong;}public int getListLength(ListNode listHead){    int count=0;    ListNode pNode=listHead;    while (pNode!=null){        pNode=pNode.next;        count++;    }    return count;}</code></pre><p>```</p><h2 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h2><p>相比空间复杂度，面试官更加看重时间复杂度，<br>降低时间复杂度的第一种办法是采用更高效的算法，比如用动态规划循环代替递归。<br>第二种办法是用空间换时间</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>杂谈</title>
      <link href="/2019/08/07/%E6%9D%82%E8%B0%88/"/>
      <url>/2019/08/07/%E6%9D%82%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="记录一下平时略有感触的杂文"><a href="#记录一下平时略有感触的杂文" class="headerlink" title="记录一下平时略有感触的杂文"></a>记录一下平时略有感触的杂文</h1><a id="more"></a><ul><li>技术好不代表着就要持才自傲，不要把别人对你的尊重和宽容当成是自己争得的荣耀，不要习惯否认他人，不要好为人师，不要因为工作上的事情伤害他人自尊</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer算法题</title>
      <link href="/2019/08/05/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E7%AF%87/"/>
      <url>/2019/08/05/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="解题思路篇"><a href="#解题思路篇" class="headerlink" title="解题思路篇"></a>解题思路篇</h1><a id="more"></a><p><strong>下面三题主要考察用画图来讲解自己的思路</strong></p><h2 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27.二叉树的镜像"></a>27.二叉树的镜像</h2><p>题目:请完成一个函数，输入一棵二叉树，该函数输出他的镜像。</p><img src="/2019/08/05/剑指offer算法题-解题思路篇/2.PNG"><p>思路：自顶向下，利用前序遍历，先访问根节点，然后对根节点的左右子树进行翻转</p><pre><code> public TreeNode invertTree(TreeNode root) {         if (root == null) return null;            // 保存右子树            TreeNode rightTree = root.right;            // 交换左右子树的位置            root.right = invertTree(root.left);            root.left = invertTree(rightTree);            return root;    }</code></pre><h2 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28.对称的二叉树"></a>28.对称的二叉树</h2><p>题目:给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><pre><code>    1   / \  2   2 / \ / \3  4 4  3</code></pre><p>思路：前序遍历：先遍历根节点，再左子节点，再右子节点。<br>那么针对前序遍历的对称的遍历算法：先遍历根节点，再右子节点，再左子节点<br>如果一棵树是对称的，则它的前序遍历与前序遍历的对称遍历时一样的。</p><pre><code>public boolean isSymmetrical(TreeNode root){        return isSymmetrical(root,root);    }boolean isSymmetrical(TreeNode root1,TreeNode root2){        if(root1==null&amp;&amp;root2==null){            return true;        }        if(root1==null||root2==null){            return false;        }        if(root1.value!=root2.value){            return false;        }        return isSymmetrical(root1.left,root2.rigth)&amp;&amp;isSymmetrical(root1.rigth,root2.left);    }</code></pre><h2 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29.顺时针打印矩阵"></a>29.顺时针打印矩阵</h2><p>题目：给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。<br>示例 1:</p><pre><code>输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,3,6,9,8,7,4,5]</code></pre><p>思路：先考虑循环中止条件，把打印看成一圈一圈的打印，每次打印矩阵的一圈，圈的起始点有规律，都是（n，n），n表示1,2,3。。。row是矩阵的行数，col是矩阵的列数，当</p><pre><code>n*2&gt;col&amp;&amp;n*2&gt;row</code></pre><p>时循环终止。<br>接下来在考虑怎么打印一圈，外圈都好打印，当打印到最内圈时，他有3种可能性</p>{% asset_img 1.PNG %}<pre><code>public List&lt;Integer&gt; spiralOrder(int[][] numbers) {        if(numbers==null||numbers.length&lt;=0||numbers[0].length&lt;=0){            return new ArrayList&lt;&gt;();        }        int row=numbers.length;        int col=numbers[0].length;        int start=0;        List&lt;Integer&gt; lists=new ArrayList&lt;&gt;();        while (start*2&lt;col&amp;&amp;start*2&lt;row){            lists.addAll(printMatrixInCircle(numbers,col,row,start));            ++start;        }        return lists;    }    public List&lt;Integer&gt; printMatrixInCircle(int[][] numbers, int col, int row, int start){        int endX=col-1-start;        int endY=row-1-start;        List&lt;Integer&gt; list=new ArrayList&lt;&gt;();        for (int i = start; i &lt;=endX ; i++) {            list.add(numbers[start][i]);        }        if(start&lt;endY){            for (int i = start+1; i &lt;=endY ; i++) {                list.add(numbers[i][endX]);            }        }        if(start&lt;endX&amp;&amp;start&lt;endY){            for (int i = endX-1; i &gt;=start ; i--) {                list.add(numbers[endY][i]);            }        }        if(endY-start&gt;1&amp;&amp;start&lt;endX){            for (int i = endY-1; i &gt;start ; i--) {                list.add(numbers[i][start]);            }        }        return list;    }</code></pre><p>注意行列值的区别，别与坐标系搞混了，emmmmm，这块是个problem。</p><p><strong>下面是用举例来解释思路</strong></p><h2 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30.包含min函数的栈"></a>30.包含min函数的栈</h2><p>题目：<br>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min、push及pop的时间复杂度都是O（1）。</p><p>思路：首先想到每次push进来一个数，就对栈中元素排序，但这样会破坏栈先进后出的结构。<br><strong>用辅助栈：</strong><br>用一个额外的栈来存储最小值，每次push进来一个数，就与辅助栈的栈顶元素相比较，如果这个数更下，就push进辅助栈，如果大，就将辅助栈的栈顶元素再次push辅助栈。</p><img src="/2019/08/05/剑指offer算法题-解题思路篇/3.PNG"><pre><code>public class StackWithMin {    Stack&lt;Integer&gt; data=new Stack&lt;&gt;();    Stack&lt;Integer&gt; min=new Stack&lt;&gt;();    public void stackWithMinPush(int value){        data.push(value);        if(min.size()==0||min.peek()&gt;value){            min.push(value);        }else {            min.push(min.peek());        }    }    public void stackWithMinPop(){        if(data.size()&gt;0&amp;&amp;min.size()&gt;0){            data.pop();            min.pop();        }    }    public int stackWithMinMin(){        if(data.size()&gt;0&amp;&amp;min.size()&gt;0){            return min.peek();        }else {            return -1;        }    }}</code></pre><h2 id="31-栈的压入，弹出序列"><a href="#31-栈的压入，弹出序列" class="headerlink" title="31.栈的压入，弹出序列"></a>31.栈的压入，弹出序列</h2><p>题目: 给定 pushed 和 popped 两个序列，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。<br>示例 1：</p><pre><code>输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]输出：true解释：我们可以按以下顺序执行：push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</code></pre><p>示例 2：</p><pre><code>输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]输出：false解释：1 不能在 2 之前弹出。</code></pre><p>思路：贪心算法,将pushed中元素依次进栈，每次检查栈顶元素是否与popped下一个元素相同，若相同，将栈顶元素出栈同时将popped元素移到下一位进行检查</p><pre><code>public boolean validateStackSequences(int[] pushed, int[] popped) {          if(pushed==null||popped==null||pushed.length!=popped.length){            return false;        }        Stack&lt;Integer&gt; stack=new Stack&lt;&gt;();        int popIndex=0;        for (int i = 0; i &lt;pushed.length ; i++) {            stack.push(pushed[i]);            while (!stack.empty()&amp;&amp;popped[popIndex]==stack.peek())//这里要检查栈是否为空，不然会空指针错误{                popIndex++;                stack.pop();            }        }        return stack.empty();    }</code></pre><h2 id="32-从上往下打印出二叉树"><a href="#32-从上往下打印出二叉树" class="headerlink" title="32.从上往下打印出二叉树"></a>32.从上往下打印出二叉树</h2><h3 id="题目一-从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印"><a href="#题目一-从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印" class="headerlink" title="题目一:从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印"></a>题目一:从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印</h3><p>思路：广度优先遍历，有队列来完成，从队列中取出一个节点遍历他们左右子节点然后放入队列中</p><pre><code> public List&lt;Integer&gt; printFromTopToBottom(TreeNode root) {        if (root == null) {            return new ArrayList&lt;&gt;();        }        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        queue.offer(root);        while (!queue.isEmpty()) {            TreeNode treeNode = queue.poll();            list.add(treeNode.value);            if (treeNode.left != null) {                queue.offer(treeNode.left);            }            if (treeNode.right != null) {                queue.offer(treeNode.right);            }        }        return list;    }</code></pre><p>//注意队列的使用，offer方法以及poll方法。</p><h3 id="题目二：分行从上到下打印二叉树"><a href="#题目二：分行从上到下打印二叉树" class="headerlink" title="题目二：分行从上到下打印二叉树"></a>题目二：分行从上到下打印二叉树</h3><pre><code>    1   / \  2   2 / \ / \3  4 4  3输出：12 23 4 4 3</code></pre><p>思路：在前面题的举出上添加两个变量，一个变量用来保存下一个层有多少个节点，另一个用来保存这一层还有多少个节点没打印。</p><pre><code> public void printFromTopToBottom(TreeNode root) {        if (root == null) {            return;        }        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        queue.offer(root);        int nextLevel=0;        int toBePrint=1;        while (!queue.isEmpty()) {            TreeNode treeNode = queue.poll();            System.out.print(treeNode.value+&quot; &quot;);            if (treeNode.left != null) {                queue.offer(treeNode.left);                nextLevel++;            }            if (treeNode.right != null) {                queue.offer(treeNode.right);                nextLevel++;            }            --toBePrint;            if(toBePrint==0){//这一层打印完，开始一下层                toBePrint=nextLevel;                nextLevel=0;                System.out.print(&quot;\n&quot;);            }        }    }</code></pre><h3 id="题目三：之字形打印二叉树"><a href="#题目三：之字形打印二叉树" class="headerlink" title="题目三：之字形打印二叉树"></a>题目三：之字形打印二叉树</h3><pre><code>    1   / \  2   3 / \ / \4  5 6  7输出：1 3 2 4 5 6 7</code></pre><p>思路：这里需要用来两个栈，当层数为奇数层时（root为第一层），先遍历右节点入栈2，在遍历左节点入栈2，当层数为偶数时，先遍历左节点入栈1，在遍历右节点入栈1。</p><pre><code>public void printFromTopToBottom(TreeNode root) {        if (root == null) {            return;        }        Stack&lt;TreeNode&gt;[] stacks=new Stack[2];        stacks[0]=new Stack&lt;&gt;();        stacks[1]=new Stack&lt;&gt;();//栈的数组需要分别初始化才能使用        int current=1;        stacks[current].push(root);        while (!stacks[1].isEmpty()||!stacks[0].isEmpty()) {            TreeNode treeNode = stacks[current].pop();            System.out.print(treeNode.value+&quot; &quot;);            if(current==1) {                if(treeNode.left!=null){                    stacks[0].push(treeNode.left);                }                if(treeNode.right!=null){                    stacks[0].push(treeNode.right);                }            }            if(current==0){                if(treeNode.right!=null){                    stacks[1].push(treeNode.right);                }                if(treeNode.left!=null){                    stacks[1].push(treeNode.left);                }            }            if(stacks[current].isEmpty()){                current=1-current;            }        }    }</code></pre><h2 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33.二叉搜索树的后序遍历序列"></a>33.二叉搜索树的后序遍历序列</h2><p>题目：输入一个整数数组，判断其是不是一个二叉搜索树的后序遍历序列</p><pre><code>    1   / \  2   3 / \ / \4  5 6  7后序遍历：4,5,2，6,7,3,1</code></pre><p>思路：后序遍历：先遍历左子节点再遍历右子节点，最后遍历根节点<br>整数数组中，最后一个为根节点，先从头遍历数组，当某个数大于根节点时，break，那么后边的数就是树的右子树，前边就是左子树，如果右子树中有比根节点更小的数，那么这棵树就不是二叉搜索树。</p><pre><code>public boolean verifySquenceOfBst(int[] nums,int start,int end){        if(nums==null||nums.length&lt;0){            return false;        }        int i=start;        for(;i&lt;end;i++){            if(nums[i]&gt;nums[end]){                break;            }        }        int j=i;        for (;j&lt;end;j++){            if(nums[j]&lt;nums[end]){                return false;            }        }        boolean left=true;        if(i&gt;start){            left=verifySquenceOfBst(nums,start,i-1) ;        }        boolean right=true;        if(i&lt;end){            right=verifySquenceOfBst(nums,i,end-1);        }        return left&amp;&amp;right;    }</code></pre><h2 id="34-二叉树中和为某一值的路径（难度偏高）"><a href="#34-二叉树中和为某一值的路径（难度偏高）" class="headerlink" title="34.二叉树中和为某一值的路径（难度偏高）"></a>34.二叉树中和为某一值的路径（难度偏高）</h2><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p><pre><code>输入：    1   / \  3   2 / \ / \4  5 6  7        7输出：[1,3,5][1,2,6]</code></pre><p>思路：深度优先搜索，遍历每条到叶节点的路径，跟前序遍历相似，前序遍历本身就是深度搜索，这里没有用到栈，因为树的节点数确定，只需按照左右节点遍历下去就行</p><pre><code>public List&lt;List&lt;Integer&gt;&gt; findPath(TreeNode root, int expectedSum) {        List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();        List&lt;Integer&gt; path = new ArrayList&lt;&gt;();        if(root == null)            return lists;        hasPathSum(root,expectedSum,path,lists);        return lists;    }    public void hasPathSum(TreeNode root, int expectedSum,List&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; lists){        if(root==null){            return;        }        path.add(root.value);        int target=expectedSum-root.value;        boolean isLeaf=(root.left==null&amp;&amp;root.right==null);        if(isLeaf&amp;&amp;target==0){            List&lt;Integer&gt; p=new ArrayList&lt;&gt;(path);//复制path            lists.add(p);        }        if(root.left!=null){            hasPathSum(root.left,target,path,lists);            path.remove(path.size()-1);//每次遍历一个节点后，需要将它删除，才能回到上一个节点        }        if (root.right != null) {            hasPathSum(root.right,target,path,lists);            path.remove(path.size()-1);        }    }</code></pre><p>当到达目标值时，需要复制整条路径，而不是将原来的路径加入lists，因为path时引用变量，接下来path的改变会导致lists中path的改变。</p><p><strong>下面主要考察分而治之的思想</strong></p><h2 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35.复杂链表的复制"></a>35.复杂链表的复制</h2><p>题目：实现一个函数复制一个复杂链表，在复杂链表中，除了有一个next指针指向下一个节点，还有一个指针指向随机的一个节点</p><p>思路：如果按常规，复制所有的节点，并把节点的next指向下一个，那么那个随机指针就需要重新遍历节点找到是第几个 O(n2），因为你不知道复制的节点和原来的节点的对应关系，你也可以用哈希表来存储他们之间的映射关系O(n)，用空间换时间。</p><p>最好的方法：</p><ol><li>先复制每一个节点，并按若下图排列,即每个节点后面跟着他的复制节点<img src="/2019/08/05/剑指offer算法题-解题思路篇/4.PNG"></li><li>接下来设置复制的节点的随机指针，即原来的节点的随机指针的下一个<img src="/2019/08/05/剑指offer算法题-解题思路篇/5.PNG"></li><li>最好拆分两个链表，奇数为原始的，偶数为复制后的<img src="/2019/08/05/剑指offer算法题-解题思路篇/6.PNG"></li></ol><pre><code> public ListNode clone(ListNode pHead){        cloneNode(pHead);        connectingSiblingNode(pHead);        return reConnectNodes(pHead);    }    public void cloneNode(ListNode pHead){        ListNode pNode=pHead;        while (pNode!=null){            ListNode pCloned=new ListNode(0);            pCloned.value=pNode.value;            pCloned.next=pNode.next;            pCloned.pSibling=null;            pNode.next=pCloned;            pNode=pCloned.next;        }    }    void connectingSiblingNode(ListNode pHead){        ListNode pNode=pHead;        while (pNode!=null){            ListNode pCloned=pNode.next;            if(pNode.pSibling!=null){                pCloned.pSibling=pNode.pSibling.next;            }            pNode=pCloned.next;        }    }    ListNode reConnectNodes(ListNode pHead){        ListNode pNode=pHead;        ListNode pClonedHead=pHead.next;        while (pNode!=null){            ListNode pCloned=pNode.next;            if(pCloned.next!=null){                pNode.next=pCloned.next;                pCloned.next=pNode.next.next;            }           else {               pNode.next=null;               pCloned.next=null;            }            pNode=pNode.next;        }        return pClonedHead;    }</code></pre><p>三个函数的循环差不多，只是拆分是要注意末尾的处理</p><h2 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36.二叉搜索树与双向链表"></a>36.二叉搜索树与双向链表</h2><p>题目：将一个二叉搜索树转换成一个排序的双向链表,即二叉树的left等于链表的previous，right等于链表中的right</p><img src="/2019/08/05/剑指offer算法题-解题思路篇/7.PNG"><p>思路：用中序遍历，同时设置一个指向上一个遍历的节点的指针，lastNodeInList，遍历当前节点时，将上一个节点的right指向当前节点，并将当前节点的left指向上一个节点，同时lastNodeInList指针指向当前节点</p><pre><code>  public TreeNode convert(TreeNode root){        TreeNode lastNodeInList=null;        lastNodeInList=convertNode(root,lastNodeInList);        TreeNode headNodeInList=lastNodeInList;        while (headNodeInList!=null&amp;&amp;headNodeInList.left!=null){            headNodeInList=headNodeInList.left;        }        return headNodeInList;    }    public TreeNode convertNode(TreeNode root, TreeNode lastNodeInList){        if(root==null){            return null;        }        TreeNode pNode=root;        if(pNode.left!=null){            lastNodeInList= convertNode(pNode.left,lastNodeInList);        }        pNode.left=lastNodeInList;        if(lastNodeInList!=null){            lastNodeInList.right=pNode;        }        lastNodeInList=pNode;        if (pNode.right != null) {            lastNodeInList=convertNode(pNode.right,lastNodeInList);        }        return lastNodeInList;    }</code></pre><h2 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h2><p>这里要补充参数调用时出现的问题，我在写第二个函数时，没有设返回值，以为lastNodeInlist指针改变后不需要返回就可以调用，但其实不是。</p><ol><li>在方法体内对参数进行运算，不会影响原有变量的值（基本类型不会改变值，引用类型不会改变引用地址）。</li><li>在方法体内对参数的属性进行操作，将改变原有变量的属性值（如集合、数组中的元素）</li></ol><p>原因是方法在执行的时候有栈帧的概念，入栈的时候只是压栈方法参数是传入参数的副本。</p><img src="/2019/08/05/剑指offer算法题-解题思路篇/8.PNG"><p>此时区分数据类型：基本类型和引用类型</p><ul><li><p>基本类型：值存放在局部变量表中，无论如何修改只会修改当前栈帧的值，方法执行结束对方法外不会做任何改变；此时需要改变外层的变量，必须返回主动赋值。</p></li><li><p>引用数据类型：指针存放在局部变量表中，调用方法的时候，副本引用压栈，赋值仅改变副本的引用。但是如果直接改变副本引用的值，修改了引用地址的对象，此时方法以外的引用此地址对象当然被修改。（两个引用，同一个地址，任何修改行为2个引用同时生效）</p></li></ul><p>关于String，本质是final类型char数组，不可修改，只能赋值，在做参数传入方法修改时，其实是新建对象，必须返回重新对外面的变量赋值才会对外面的String引用生效。String不是引用传递</p><p>String源码</p><pre><code> public String replace(char oldChar, char newChar) {        if (oldChar != newChar) {            int len = value.length;            int i = -1;            char[] val = value; /* avoid getfield opcode */            while (++i &lt; len) {                if (val[i] == oldChar) {                    break;                }            }            if (i &lt; len) {                char buf[] = new char[len];                for (int j = 0; j &lt; i; j++) {                    buf[j] = val[j];                }                while (i &lt; len) {                    char c = val[i];                    buf[i] = (c == oldChar) ? newChar : c;                    i++;                }                //String的value 是final char[]，一旦创建不能改变                return new String(buf, true);            }        }        return this;</code></pre><h2 id="37-序列化二叉树"><a href="#37-序列化二叉树" class="headerlink" title="37.序列化二叉树"></a>37.序列化二叉树</h2><p>题目：实现两个函数，分别用来序列化和反序列化二叉树</p><ul><li><p>二叉树序列化（持久化）<br>  二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。<br>  序列化可以基于 先序、中序、后序、按层 的二叉树遍历方式来进行修改。原理都是一样的（即遍历顺序不同而已，对每个结点的处理都是一样的），序列化的结果是一个字符串，序列化时通过  某种符号表示空节点（$），以, 表示一个结点值的结束（value!）。</p></li><li><p>二叉树的反序列化</p><p>  二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树</p></li></ul><p>思路：都才用前序遍历，并用StringBuilder保存序列化结果</p><pre><code> public String serialize(TreeNode root) {        StringBuilder str = new StringBuilder();        serializeCore(root, str);        return str.toString();    }    public void serializeCore(TreeNode root, StringBuilder str) {        if (root == null) {            str.append(&quot;$,&quot;);        } else {            str.append(root.value + &quot;,&quot;);            serializeCore(root.left, str);            serializeCore(root.right, str);        }    }    public TreeNode deSerialize(String str) {        if (str == null &amp;&amp; str.length() &lt;= 0) {            return null;        }        String[] strs = str.split(&quot;,&quot;);        return deSerializeCore(strs);    }    int index = 0;//用于递归调用中strs下标的变化    TreeNode deSerializeCore(String[] strs) {        if (&quot;$&quot;.equals(strs[index])) {            index++;            return null;        }        TreeNode root = new TreeNode(Integer.valueOf(strs[index]));        index++;        root.left = deSerializeCore(strs);        root.right = deSerializeCore(strs);        return root;    }</code></pre><h2 id="38-字符串的排列与组合"><a href="#38-字符串的排列与组合" class="headerlink" title="38.字符串的排列与组合"></a>38.字符串的排列与组合</h2><h3 id="题目一：输入一个字符串，打印出该字符串的所有排列。"><a href="#题目一：输入一个字符串，打印出该字符串的所有排列。" class="headerlink" title="题目一：输入一个字符串，打印出该字符串的所有排列。"></a>题目一：输入一个字符串，打印出该字符串的所有排列。</h3><pre><code>输入 &quot;abc&quot;输出 abc acb bac bca cab cba</code></pre><p>思路：每次从中取一个字符，与第一个字符交换，然后把字符串分为两部分，一部分是第一个字符，另一部分是后面的字符，然后后面的字符进行排列，依次递归。</p><pre><code> public void permutation(char[] str) {        if (str == null || str.length == 0) {            return;        }        permutationCore(str, 0);    }    public void permutationCore(char[] str, int begin) {        if (begin == str.length-1) {//当begin等于最后一个数时才能输出，即一次排列进行到了最后一个数            System.out.println(str);        } else {            for (int i = begin; i &lt; str.length; i++) {                swap(str, begin, i);                permutationCore(str, begin + 1);                swap(str, i, begin);//因为是在原字符串上操作，所有一次排列完成后，必须恢复原样，才能进行下一次排列            }        }    }    public void swap(char[] str, int index1, int index2) {        char temp = str[index1];        str[index1] = str[index2];        str[index2] = temp;    }</code></pre><h3 id="题目二：输入一个字符串，打印该字符的所有组合"><a href="#题目二：输入一个字符串，打印该字符的所有组合" class="headerlink" title="题目二：输入一个字符串，打印该字符的所有组合"></a>题目二：输入一个字符串，打印该字符的所有组合</h3><pre><code>输入 &quot;abc&quot;输出 abc ab ac bc a b c</code></pre><p>思路：输入n个字符，如果要从中取m个数，我们把这n个字符分成两部分，一部分是第一个字符，另一部分是后面的字符，如果取第一个字符，接下来就从n-1个字符中取m-1个，如果不去第一个字符，接下来就从n-1个字符中取m个字符。依次递归</p><pre><code>public void combine(char[] str) {        if (str == null || str.length == 0) {            return;        }        List&lt;Character&gt; result=new ArrayList&lt;&gt;();        for (int n = 1; n &lt;=str.length ; n++) {            combineCore(str, 0,n,result);        }    }    public void combineCore(char[] str,int begin, int n,List&lt;Character&gt; result) {        if(n==0){            System.out.println(result.toString());            return;//当n=0时才能输出        }        if(begin==str.length){            return;//n！=0然而begin到末尾了，这时舍弃result        }else {            result.add(str[begin]);//选第一个数            combineCore(str, begin + 1, n - 1, result);            result.remove(result.size() - 1);//不选第一个数            combineCore(str, begin + 1, n, result);        }    }</code></pre><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>解决复杂问题的三种办法：<strong>画图，举例，分解</strong></p><ul><li>图形能使抽象的问题形象化，针对链表和二叉树有很好的效果</li><li>举例能使问题具体化，很多算法问题都很抽象，使用举例来寻找他们之间的规律</li><li>复杂问题分解成许多小问题，分治法，动态规划，贪心等方法都应用了这种思路</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM</title>
      <link href="/2019/08/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/"/>
      <url>/2019/08/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/</url>
      
        <content type="html"><![CDATA[<h1 id="《深入理解java虚拟机》精华总结"><a href="#《深入理解java虚拟机》精华总结" class="headerlink" title="《深入理解java虚拟机》精华总结"></a>《深入理解java虚拟机》精华总结</h1><a id="more"></a><h2 id="1-java虚拟机运行时数据区域"><a href="#1-java虚拟机运行时数据区域" class="headerlink" title="1.java虚拟机运行时数据区域"></a>1.java虚拟机运行时数据区域</h2><p>java虚拟就在执行java程序时会将他所管理的内存划分为若干个不同的数据区域</p><img src="/2019/08/02/深入理解JVM/1.jpg" title="[]"><p>方法区和堆时线程共享的数据区，其他的不是</p><h3 id="1-1-程序计数器："><a href="#1-1-程序计数器：" class="headerlink" title="1.1 程序计数器："></a>1.1 程序计数器：</h3><p>&#160; &#160;一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器，在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选择下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都依赖它来实现。每个线程都有独立的程序计数器，如果线程执行的是java方法，则计数器记录的是字节码指令的地址，如果是Native方法，则为空，此内存是唯一没有规定任何OutOfMemoryError情况的区域</p><h3 id="1-2-Java虚拟机栈"><a href="#1-2-Java虚拟机栈" class="headerlink" title="1.2 Java虚拟机栈"></a>1.2 Java虚拟机栈</h3><p>&emsp;虚拟机栈描述的是java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口灯信息。每个方法从执行到结束，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。<br>&#8195;经常有人把java内存分为栈内存和堆内存（不知道是否正确），栈内存就指的是虚拟机栈，或者说是虚拟机栈中局部变量表的部分，堆内存后面会讲。<br>&emsp;局部变量表存放了编译期所知的基本数据类型，对象引用类型和returnAddress（指向一条字节码指令的地址）其中64位的double和float占据两个局部变量空间，其余的数据类型占据一个。</p><p>这个区域规定了两个异常状况：</p><ol><li>StackOverflowError：当线程所申请的栈深度大于虚拟机所允许的深度</li><li>OutOfMemoryError：如果虚假机栈可以动态扩展，扩展时无法申请到足够的内存        </li></ol><h3 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3 本地方法栈"></a>1.3 本地方法栈</h3><p>与java虚拟机栈类似，只不过是java虚拟机栈为虚拟机执行java方法（也就是字节码服务），而本地方法栈则为虚拟机执行Native方法，也会存在虚拟机栈出现的两种异常状况</p><h3 id="1-4-Java堆"><a href="#1-4-Java堆" class="headerlink" title="1.4 Java堆"></a>1.4 Java堆</h3><p>&emsp;Java堆时java虚拟机所管理的内存最大的一块，此区域的唯一目的就是存放对象实例。<br>&emsp;Java堆时垃圾收集器管理的主要区域，（GC堆），现在收集器基本都用分带收集算法，所以java堆可以细分为新生代和老年带，划分的目的都是为了更好的回收内存或者更快的分配内存。如果堆中没有内存完成对象实例分配，并且对也无法扩展，会抛出OutOfMemory异常。</p><h3 id="1-5-方法区"><a href="#1-5-方法区" class="headerlink" title="1.5 方法区"></a>1.5 方法区</h3><p>&emsp;用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译期编译后的代码等数据<br>&emsp;除了Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载<br>&emsp;当方法区无法满足内存分配需求时，将抛出OutOfMemoryErroy异常<br>log</p><h3 id="1-6-运行时常量池"><a href="#1-6-运行时常量池" class="headerlink" title="1.6 运行时常量池"></a>1.6 运行时常量池</h3><p>&emsp;是方法区的一部分。class文件中除了包含类的版本，字段，方法，接口等描述信息，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。<br>&emsp;运行时常量池对于class文件常量池最重要的特是具备动态性，java并不要求常量一定只有编译期才能产生，运行时也可能将新的常量放入池中。String的intern（）方法。<br>&emsp;也会产生OutOfMemoryError异常</p><h3 id="1-7-直接内存"><a href="#1-7-直接内存" class="headerlink" title="1.7 直接内存"></a>1.7 直接内存</h3><p>此区域并不是虚拟机运行时数据区的一部分，但是这部分区域也被频繁使用，也存在OutOfMemory异常，显然，本机直接内存的分配不会受到java对大小的限制，但会受到本机总内存大小以及处理器寻址空间的限制。</p><h2 id="2-HotSpot虚拟机对象探秘"><a href="#2-HotSpot虚拟机对象探秘" class="headerlink" title="2.HotSpot虚拟机对象探秘"></a>2.HotSpot虚拟机对象探秘</h2><h3 id="2-1对象的创建"><a href="#2-1对象的创建" class="headerlink" title="2.1对象的创建"></a>2.1对象的创建</h3><ol><li><p>检查<br>在语言层面上，创建对象仅仅是用new关键字，当虚拟机遇到new指令时，首先将去常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否被加载，解析和初始化过。如果没有，将执行类加载过程（后面会讲）</p></li><li><p>分配内存<br>把一块确定大小的内存从java堆中划分出来，有两种内存分配方式</p><ul><li><p>指针碰撞：<br>假设java堆中内存是绝对规整的，用过的内存在一边，闲置的在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅把那个指针向空闲内存方向移动与对象大小相同的距离。</p></li><li><p>空闲列表：<br>如果java堆中的内存不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法进行简单的指针碰撞，虚拟机就必须维护一个列表，记录上哪些内存是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象，并更新列表</p><p>选择哪种方式由java堆是否规整决定，java堆是否规整又取决于所采用的垃圾收集器是否带有压缩整理功能决定</p></li></ul></li><li><p>init<br>内存分配完成后，虚拟机将分配到的内存空间都初始化为零值，执行new指令后接着执行(init)方法,把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来</p></li></ol><h3 id="2-2对象的内存布局"><a href="#2-2对象的内存布局" class="headerlink" title="2.2对象的内存布局"></a>2.2对象的内存布局</h3><p>分为三个区域：对象头header，实例数据instance data，对齐填充 Padding</p><h4 id="对象头："><a href="#对象头：" class="headerlink" title="对象头："></a>对象头：</h4><p>包括两部分信息</p><ul><li>第一部分用于储存对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程id，偏向时间戳等。</li><li>另一部分用时类型指针，即对象指向他的类元数据的指针，虚拟机通过这个指针来确定他是哪个对象的实例</li></ul><h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>是对象真正存储的有效信息，是在程序代码中所定义的各种类型的字段内容。</p><h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><p>没有特别的含义，仅仅起到占位符的作用，Hotspot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍</p><h3 id="2-3对象的访问定位"><a href="#2-3对象的访问定位" class="headerlink" title="2.3对象的访问定位"></a>2.3对象的访问定位</h3><p>建立对象是为了使用对象，java程序需要通过java虚拟机栈的引用数据（reference）来操作堆上的及具体对象，堆上的具体对象又要到方法区找到对象的类型数据。有两个方法定义这个引用通过何种方式去定位</p><ul><li>句柄访问<br>从java堆中划分一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址</li><li>使用直接指针访问<img src="/2019/08/02/深入理解JVM/2.png" title="[]"></li></ul><p>两种方法各有优势：<br>使用句柄的优势在于当对象被移动时，（垃圾收集时会频繁的移动对象），只会改变句柄中的实例数据指针，而reference不需要改变<br>使用直接指针，最大好处就是速度快，节省了时间开销，Hotspot就是用的这种方式</p><h3 id="3-OutOfMemory异常"><a href="#3-OutOfMemory异常" class="headerlink" title="3.OutOfMemory异常"></a>3.OutOfMemory异常</h3><h4 id="3-1-Java堆溢出"><a href="#3-1-Java堆溢出" class="headerlink" title="3.1 Java堆溢出"></a>3.1 Java堆溢出</h4><p>Java堆用于存储对象实例，只要不断的创建对象，并且保证GCRoots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在数量到达最大堆的容量限制后就会产生内存溢出异常</p><p>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置</p><p>如果不存在泄露，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗</p><h4 id="3-2-虚拟机栈和本地方法栈溢出"><a href="#3-2-虚拟机栈和本地方法栈溢出" class="headerlink" title="3.2 虚拟机栈和本地方法栈溢出"></a>3.2 虚拟机栈和本地方法栈溢出</h4><p>Hotspot不区分虚拟机栈和本地方法栈，对于HotSpot来说，虽然-Xoss参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由-Xss参数设定。关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：</p><p>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError</p><p>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常</p><p>在单线程下，无论由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常</p><p>如果是多线程导致的内存溢出，与栈空间是否足够大并不存在任何联系，这个时候每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。解决的时候是在不能减少线程数或更换64为的虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程</p><h4 id="3-3-方法区和运行时常量池溢出"><a href="#3-3-方法区和运行时常量池溢出" class="headerlink" title="3.3 方法区和运行时常量池溢出"></a>3.3 方法区和运行时常量池溢出</h4><p>String.intern()是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用</p><p>由于常量池分配在永久代中，可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小，从而间接限制其中常量池的容量。</p><ul><li><p>Intern():</p><p> JDK1.6 intern方法会把首次遇到的字符串实例复制到永久代，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是一个引用</p><p> JDK1.7 intern()方法的实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此intern()</p></li></ul><h2 id="4-垃圾收集"><a href="#4-垃圾收集" class="headerlink" title="4.垃圾收集"></a>4.垃圾收集</h2><p>虚拟机栈，本地方法栈，程序计数器随线程而生，随线程而灭，这几个区域内就不需要过多考虑回收问题</p><h3 id="4-1如何确定对象的“存活”"><a href="#4-1如何确定对象的“存活”" class="headerlink" title="4.1如何确定对象的“存活”"></a>4.1如何确定对象的“存活”</h3><ol><li>引用计数算法<br>给对象添加一个引用计数器，如果它被引用，就+1，引用失效就-1，任何时候计数器为0就是不可能再被使用.<br>然而假设有两个对象相互被引用（即循环），用引用计数器算法无法通知GC收集器回收他们，实际上这两个对象已经不可能被访问了，这也从侧面说明了java虚拟机并不是靠这种算法来判断对象是否存活。</li><li>可达性分析算法<br>通过一系列的成为”GC ROOT”的对象作为起始点，从这些节点开始向下搜索，搜索通过的路径成为引用链（reference chain），当一个对象没有任何引用链相连，那么它就是不可用的。</li></ol><h3 id="4-2-引用"><a href="#4-2-引用" class="headerlink" title="4.2 引用"></a>4.2 引用</h3><p>JDK1.2 之前，引用定义为如果reference类型的数据中存储的数值代表另外一块内存的起始地址，则代表引用。这种定义很纯粹，太过狭隘。<br>JDK1.2之后，将引用分为四种，4中引用强度依次减弱</p><ol><li>强引用<br>类似<em>Object obj=new Object()</em>,只要强引用一直在，垃圾收集器永远不会回收掉被引用的对象。</li><li>软引用<br>用于描述一些还有用但非必需的对象，在系统将要发生内存溢出异常之前，将会把这些对象列为回收范围之中进行第二次回收，如果回收之后内存还是不够，才会抛出内存溢出异常。</li><li>弱引用<br>用于描述非必需对象，当垃圾收集器开始工作时，无论内存是否溢出，都会回收这类对象</li><li>虚引用<br>唯一目的就是这个对象在被垃圾收集器回收时会收到一个通知。</li></ol><h3 id="4-3-finalize方法"><a href="#4-3-finalize方法" class="headerlink" title="4.3 finalize方法"></a>4.3 finalize方法</h3><p>即便是在可达性分析算法中不可达的对象，也并非”非死不可”，真正宣告一个对象的死亡，需要经过两次标记过程。</p><ul><li>第一次标记：对象进行可达性分析后，没有与GC root的引用链相连的对象，将会被第一次标记并进行一次筛选，来判断他是否有必要执行finalize方法<br>筛选条件：如果对象没有覆盖finalize方法或者虚拟机已经调用了它的finalize方法，它就没必要执行下一步。</li><li>第二次标记：这时对象被判定为需要执行finalize方法，并被放置在一个叫 F-Queue的队列中，finalize方法是对象逃脱死亡的最好一次方法，稍后Gc会对队列中的对象进行第二次标记，如果对象此时重新与GC引用链连接上，那么它就会被移出“即将回收”的集合。</li></ul><h3 id="4-4-回收方法区"><a href="#4-4-回收方法区" class="headerlink" title="4.4 回收方法区"></a>4.4 回收方法区</h3><p>方法区（HotSpot虚拟机中的永久代），java虚拟机规范并不要去在方法区中实现垃圾收集，因为性价比很低，。<br>主要回收两部分内容：</p><ul><li>常量：与java对象非常类似，如果它没有被引用，就会被回收</li><li>无用的类：判断一个类是否无用比较复杂：<ol><li>该类的所有实例已被回收</li><li>加载该类的classloder已经被回收</li><li>该类对应的java.lang.class没有在任何地方被引用，无法在任何地方通过反射来访问该类的方法。</li></ol></li></ul><h3 id="4-4-垃圾收集算法"><a href="#4-4-垃圾收集算法" class="headerlink" title="4.4 垃圾收集算法"></a>4.4 垃圾收集算法</h3><ol><li><p>标记-清除算法：<br>算法分为标记和清除两个阶段:首先标记所有需要回收的对象，在标记 完成后统一回收所有对象<br>主要不足有两个：</p><ul><li>效率低：标记和清除两个效率都不高</li><li>空间问题：标记清除后产生大量不连续的内存碎片，导致在分配较大对象时，无法找到足够连续内存而引起又一次的垃圾收集</li></ul></li><li><p>复制算法<br>为了解决标记清除算法的效率问题，他将可用内存按照容量划分为大小相等的两块，每次只使用其中的一块。当这块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可<br>不足：</p><ul><li>将内存缩小为了原来的一半<br>实际中我们并不需要按照1:1比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor<br>当另一个Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代</li></ul></li><li><p>标记-整理算法<br>复制收集算法在对象存活率较高时效率较低，还需要额外的空间进行分配担保。<br>标记整理算法的过程仍然和标记清除算法一样，只是在标记完成后，现将对象往一端移动，然后直接清理掉边界以外的内存</p></li><li><p>分代收集算法<br>新生代就用复制算法，因为他们“朝生夕死”，老年代就用标记整理或者标记清除算法。</p></li></ol><h3 id="4-5-垃圾收集器"><a href="#4-5-垃圾收集器" class="headerlink" title="4.5 垃圾收集器"></a>4.5 垃圾收集器</h3><p>收集算法是对内存回收的方法论，垃圾收集器就是内存回收的具体实现</p><img src="/2019/08/02/深入理解JVM/3.PNG"><ol><li><p>Serial收集器<br>单线程收集器，不仅仅使用一个cpu和一个线程去完成垃圾收集工作，更重要的是他会暂停所有用户线程，知道它收集完成。</p></li><li><p>Parnew收集器<br>serial收集器的多线程版本，除了使用多线程进行垃圾收集，其它的和serial收集器一样</p></li><li><p>Paraller Scavenge收集器<br>它也是使用复制算法的收集器，，又是并行的多线程处理器，它与parnew收集器的关注点不同，CMS等收集器的关注点是尽可能的缩短垃圾收集时用户线程的停顿时间，而paraller scavenge目的是达到一个可控的吞吐量（throughput)</p><ul><li>吞吐量=（运行用户代码时间）/（运行用户代码时间+垃圾收集时间）</li></ul></li><li><p>Serial Old收集器<br>serial收集器的老年代版本，同样是一个单线程收集器，使用标记-整理算法，</p></li><li><p>paraller old收集器<br>paraller scavenge收集器的老年代版本，使用多线程和标记-整理算法，</p></li><li><p>CMS收集器<br>是一种以获取最短回收停顿时间为目标的收集器，基于标记-清除算法实现的，它分为四个步骤：</p><ol><li>初始标记：标记一下GC root能关联到的对象</li><li>并发标记： GC root tracing的过程</li><li>重新标记： 修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</li><li>并发清理</li></ol><p>优点:并发收集，低停顿<br>缺点：</p><ol><li>CMS收集器对CPU资源非常敏感，CMS默认启动的回收线程数是（CPU数量+3）/4，</li><li>CMS收集器无法处理浮动垃圾，可能出现Failure失败而导致一次Full GC的产生</li><li>CMS是基于标记清除算法实现的</li></ol></li><li><p>G1收集器<br>面向服务器应用的垃圾收集器</p><ol><li>并行与并发：使用多个cpu来缩短stop-the-world停顿的时间</li><li>分代收集</li><li>空间整合，不会产生内存碎片</li><li>可预测的停顿：能让使用者明确指定在一个长度为M毫秒的时间片段上，消耗在垃圾收集上的时间不得超过n毫秒</li></ol><p>运行方式：初始标记，并发标记，最终标记，筛选标记</p></li></ol><h3 id="4-6-jvm中的新生代Eden和survivor区"><a href="#4-6-jvm中的新生代Eden和survivor区" class="headerlink" title="4.6 jvm中的新生代Eden和survivor区"></a>4.6 jvm中的新生代Eden和survivor区</h3><img src="/2019/08/02/深入理解JVM/9.PNG"><p>jvm将年轻代中的分为了三个部分：Eden和两个survivor区域（分为称为from和to），默认比例为8:1，新创建的对象会被分配到eden区域，经过一次GC后，如果还会存活，将会被移动到from区域，to区域是空的，而在from区域，会根据他们的年龄判断他们的走向，年龄达到阈值的进入老年代，没有达到的将会进入to区域，这时from和eden区域就都是空的了，然后from和to交换角色，来保证to区域永远是空的，直到to区域全部被填满，那么其中所有的对象都会进入老年代</p><img src="/2019/08/02/深入理解JVM/4.png"><h2 id="5-内存分配与回收策略"><a href="#5-内存分配与回收策略" class="headerlink" title="5.内存分配与回收策略"></a>5.内存分配与回收策略</h2><ul><li><strong>对象优先在eden区中分配，当eden可用区域不充足时，会发生minorGC</strong></li><li>大对象直接进入老年代，所谓大对象就是指大量连续内存空间的java对象，</li><li>长期存活的对象进入老年代，每个对象有一个年龄计数器，没熬过一个minorGC 就会涨一岁，当达到阈值就会进入老年代</li><li>动态对象年龄判断：并不要求对象年龄达到阈值，而是当survivor空间中相同年龄所有对象的个数大于survivor空间的一半，那么年龄大于或等于该年龄的就会直接进入老年代</li><li>空间分配担保：<ol><li>发生minorGC前，会检查老年代可用空间是否大于新生代总空间。成立，minor gc安全。</li><li>不成立，会查看HandlePromotionFailure设置是否允许担保失败。<strong>如果不允许，将会进行full gc</strong></li><li>如果允许，那么继续检查老年代可用空间是否大于历次晋升到老年代对象的平均大小。</li><li><strong>如果大于，那么尝试进行有风险的minor gc，因为如果这次对象较多，survivor区域无法容纳，就需要老年代进行担保，如果老年代也无法容纳就会在失败后发生full gc</strong></li></ol></li></ul><h2 id="6-0虚拟机类加载机制"><a href="#6-0虚拟机类加载机制" class="headerlink" title="6.0虚拟机类加载机制"></a>6.0虚拟机类加载机制</h2><p>虚拟机把描述类的class文件加载到内存，然后经过校验，解析和初始化转换为虚拟机可用的java类型，就是类加载机制。</p><img src="/2019/08/02/深入理解JVM/5.PNG"><p>类型的加载，连接和初始化都是在程序运行时完成的</p><h3 id="6-1-什么时候开始进行类加载"><a href="#6-1-什么时候开始进行类加载" class="headerlink" title="6.1 什么时候开始进行类加载"></a>6.1 什么时候开始进行类加载</h3><ol><li>new:遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候</li><li>反射:使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始</li><li>用到父类：当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</li><li>main方法：当虚拟机启动时候，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类</li><li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化</li></ol><p>上述五种称为主动引用，下面三种被动引用，不会触发类的初始化</p><ol><li>子类引用父类的静态字段</li><li>通过数组来定义类：SuperClass[] sca =new SuperClass[10]</li><li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</li></ol><p>接口与类的加载不同：当类初始化时，要求父类都已初始化了，当接口初始化时，只有用到父类的地方（如接口中的常量）才会进行初始化。</p><h3 id="6-2-类加载的过程"><a href="#6-2-类加载的过程" class="headerlink" title="6.2 类加载的过程"></a>6.2 类加载的过程</h3><ol><li>加载：加载是类加载的一个阶段，在加载阶段，需要完成以下三个事情<ul><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换成方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.class对象，作为方法区这个类的各种数据入口</li></ul></li><li>验证：验证是连接阶段的第一步，这一阶段的目的是为了确保class文件的字节流符合当前虚拟机的要求<ul><li>文件格式验证</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ul></li><li>准备：正式为类变量分配内存并设置初始值的阶段，初始值一般是0，但当变量是final类型是，将直接设置为用户自定义变量</li><li>解析：虚拟机将常量池中的符号引用转换为直接引用<ul><li>符号引用：用一组符号来描述所引用的目标，字面量</li><li>直接引用：直接指向目标的指针，相对偏移量，或是一个能直接定位到目标的句柄</li></ul></li><li>初始化：根据程序员的主观计划去初始化类变量和其他资源，如定义变量的值，因为初始值是0。初始化是执行类构造器<clinit>()方法的过程。<ul><li><clinit>方法是由编译期自动收集类中的复制动作和静态语句块而产生的。</clinit></li></ul></clinit></li></ol><h3 id="6-4-类加载器"><a href="#6-4-类加载器" class="headerlink" title="6.4 类加载器"></a>6.4 类加载器</h3><p>根据指定名称将class文件加载到jvm内存，转换为class对象，这就是类加载器的职责。分为两种：</p><ul><li>启动类加载器：由C++语言实现（针对HotSpot）,负责将存放在<java_home>\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中。</java_home></li><li>其他类加载器：有java语言实现，继承自抽象类classloader<ul><li>扩展类加载器（Extension ClassLoader）：负责加载<java_home>\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库。</java_home></li><li>应用程序类加载器（Application ClassLoader）：负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。<h4 id="6-4-1-类与类加载器"><a href="#6-4-1-类与类加载器" class="headerlink" title="6.4.1 类与类加载器"></a>6.4.1 类与类加载器</h4>判断两个类是否来源于同一class文件，是根据加载他们的类加载器来的，即使一个class文件被不同类加载器加载，生成的class对象是不同的。这里的相同包括代表类对象的equals方法，isAssignableFrom方法，isInstance方法。<h4 id="6-4-2-双亲委派模型"><a href="#6-4-2-双亲委派模型" class="headerlink" title="6.4.2 双亲委派模型"></a>6.4.2 双亲委派模型</h4><img src="/2019/08/02/深入理解JVM/6.PNG"></li></ul></li><li>层次关系：要求除了顶层类加载器，其它类加载器都要有自己的父加载器，这种父子关系并不是通过继承去实现的，而是通过组合去实现的。</li><li>工作机制：当一个类加载器收到加载类的请求，它首先不会自己去加载，而是将这个请求委派给父加载器，每一层次都是如此，因此所有请求都会最终到达顶层的启动类加载器，只有父加载器反馈自己不能加载时，子类才会尝试自己去加载。</li><li>好处：java类随着他们的类加载器一起具备了一种层级关系。<img src="/2019/08/02/深入理解JVM/7.PNG"><h4 id="6-4-3-破坏双亲委派模型"><a href="#6-4-3-破坏双亲委派模型" class="headerlink" title="6.4.3 破坏双亲委派模型"></a>6.4.3 破坏双亲委派模型</h4>双亲委派模型并不是一种强制性约束，而是一种推荐的类加载器的实现方式。</li></ul><ol><li>自定义类加载器，重写loadClass方法；</li><li>使用线程上下文类加载器；</li></ol><h2 id="7-0-java内存模型"><a href="#7-0-java内存模型" class="headerlink" title="7.0 java内存模型"></a>7.0 java内存模型</h2><p>java内存模型用来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的内存访问效果。</p><ul><li>主要目标:定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出这样的底层细节。这里的变量包括静态字段，实例字段和构成数组对象的元素，但不包括局部变量和方法参数（线程私有）。</li></ul><img src="/2019/08/02/深入理解JVM/8.PNG"><p>java内存模型规定了所有变量都存储在主内存中，而线程的工作内存保存了被该线程所用到的变量的主内存副本拷贝。线程间变量值的传递均需要通过主内存来完成。</p><h3 id="7-1-内存间的相互操作"><a href="#7-1-内存间的相互操作" class="headerlink" title="7.1 内存间的相互操作"></a>7.1 内存间的相互操作</h3><p>关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：</p><p>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</p><p>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p><p>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</p><p>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</p><p>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</p><p>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p><p>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</p><p>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</p><p>Java内存模型还规定了在执行上述八种基本操作时，还定义了一些规则，这里不再阐述。</p><h3 id="7-2-volatile型变量"><a href="#7-2-volatile型变量" class="headerlink" title="7.2 volatile型变量"></a>7.2 volatile型变量</h3><blockquote><p>重排序： 在执行程序时，编译期和处理器为了提高程序性能，经常会对指令进行重排序。重排序分为三种</p><ul><li>编译器优化的重排序，在不改变单线程语义的情况下重新安排语句的执行顺序</li><li>指令级并行的顺序，现代处理器采用指令级并行技术来将多条指令重叠执行。如果不在数据依赖性，就可以改变指令执行的顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读写缓冲区，这看起来加载和存储操作像是在乱序执行。<br>为了保证内存的可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。Java内存模型把内存屏障分为LoadLoad、LoadStore、StoreLoad和StoreStore四种。</li></ul></blockquote><p>当一个变量被定义为valatile型时，他具有以下两种特性</p><ol><li>保证他对所有线程的可见性，这里的可见性是指当一条线程改变了这个变量的值，那么对于其他线程来说是可以立即得知的。<br>由于volatile只能保证可见性，在不符合以下两个场景时，仍然需要加锁来保证原子性：<ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li><li>变量不需要与其他的状态变量共同参与不变约束</li></ul></li><li>禁止指令重排序：普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中执行顺序一致，这个就是所谓的线程内表现为串行的语义</li></ol><h3 id="7-3-对于long和double型变量的特殊规则"><a href="#7-3-对于long和double型变量的特殊规则" class="headerlink" title="7.3 对于long和double型变量的特殊规则"></a>7.3 对于long和double型变量的特殊规则</h3><p>java内存模型要求对于8个操作都要具有原子性，但对于64位的：允许虚拟机将没有被volatile修饰的64位数据的读写操作分为32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这4个操作的原子性。</p><h3 id="7-4-java内存模型的特性"><a href="#7-4-java内存模型的特性" class="headerlink" title="7.4 java内存模型的特性"></a>7.4 java内存模型的特性</h3><ol><li>原子性：一组操作要么全部成功，要么全部失败。由java内存模型保证的原子性变量操作有：read ，load，assign，use，store，write。如果需要更大范围的原子性操作，就可以用lock与unlock操作，反应到java代码中就是同步代码块-synchronized。</li><li>可见性：当一个线程修改了变量的值，其他线程能够立即的得知这个修改。java内存模型是通过在变量修改后将新值同步到主内存中，在变量读取前刷新变量值来这种依赖主内存做传播媒介的方式来实现可见性的。除volatile之外，还有两个关键字能实现可见性：synchronized和final。final的可见性是指：被final修饰的字段在构造器中一旦初始化完成，那么无需同步就可以被其他线程正确访问。</li><li>有序性：两个方面：volatile禁止指令重排序，synchronized保证持有同一个锁的两个同步代码块只能串行进入。</li></ol><h3 id="7-5-先行发生原则"><a href="#7-5-先行发生原则" class="headerlink" title="7.5 先行发生原则"></a>7.5 先行发生原则</h3><p>这些先行原则无需同步就已经存在了，如果不在这些原则中就不能保证顺序性，虚拟机就可以对他们进行重排序了</p><ol><li><p>程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确的说，应该是控制顺序而不是程序代码顺序，因为要考虑分支。循环等结构</p></li><li><p>管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而后面的是指时间上的先后顺序</p></li><li><p>Volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的后面同样是指时间上的先后顺序</p></li><li><p>线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作</p></li><li><p>线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、ThradisAlive()的返回值等手段检测到线程已经终止执行</p></li><li><p>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断时间的发生，可以通过Thread.interrupted()方法检测到是否有中断发生</p></li><li><p>对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始</p></li><li><p>传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论</p></li></ol><h2 id="8-0-线程"><a href="#8-0-线程" class="headerlink" title="8.0 线程"></a>8.0 线程</h2><p>并发并不一定依赖多线程。</p><h3 id="8-1-线程的实现"><a href="#8-1-线程的实现" class="headerlink" title="8.1 线程的实现"></a>8.1 线程的实现</h3><p>线程是比进程更轻量级的单位，线程的引入，可以将进程的资源分配和执行调度分开。</p><ol><li>使用内核线程实现：程序一般不会直接去使用内核线程，而是使用内核线程的一种高级接口——轻量级进程，也就是线程。局限性：各种线程操作需要系统调用，系统调用的代价相对较高，需要再用户态和内核态来回切换，其次线程会消耗掉一定的内存资源。</li><li>使用用户线程实现：</li><li>使用前面两种混合实现</li></ol><h3 id="8-2-线程的调度"><a href="#8-2-线程的调度" class="headerlink" title="8.2 线程的调度"></a>8.2 线程的调度</h3><p>主要的调度方式有两种：协同式和抢占式</p><ul><li><p>协同式调度：线程的执行时间由线程本身控制</p></li><li><p>抢占式调度：线程的执行时间由系统来分配<br>java使用的是抢占式。<br>java有十个优先级，</p></li></ul><h3 id="8-3-线程的状态转换"><a href="#8-3-线程的状态转换" class="headerlink" title="8.3 线程的状态转换"></a>8.3 线程的状态转换</h3><ul><li><p>新建</p></li><li><p>运行：可能正在执行。可能正在等待CPU为它分配执行时间</p></li><li><p>无限期等待：不会被分配CUP执行时间，它们要等待被其他线程显式唤醒</p></li><li><p>限期等待：不会被分配CUP执行时间，它们无须等待被其他线程显式唤醒，一定时间会由系统自动唤醒</p></li><li><p>阻塞：阻塞状态在等待这获取到一个排他锁，这个时间将在另一个线程放弃这个锁的时候发生；等待状态就是在等待一段时间，或者唤醒动作的发生</p></li><li><p>结束：已终止线程的线程状态，线程已经结束执行</p><img src="/2019/08/02/深入理解JVM/10.png"><h2 id="9-0-线程安全"><a href="#9-0-线程安全" class="headerlink" title="9.0 线程安全"></a>9.0 线程安全</h2><p>当多个线程访问同一个对象，如果不用考虑他们在运行环境下的调度和交替执行，也不需要额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。</p><h3 id="9-1-线程安全的分类"><a href="#9-1-线程安全的分类" class="headerlink" title="9.1 线程安全的分类"></a>9.1 线程安全的分类</h3><p>按照“线程安全”的安全程度由强至弱</p></li></ul><ol><li>不可变对象：例如由final定义的对象是不可变的，String对象是一个典型的不可变对象，我们调用它的subString和replace方法时并不是在原来的对象基础上修改，而是返回一个新构造的对象。常用的还有枚举类，Long，Double等数值的包装类型</li><li>绝对线程安全：瞒住线程安全的定义、不需要额外的同步措施即可达到线程安全。在javaApi中，大多数标注自己是线程安全的类，大多不是绝对的线程安全，而是相对线程安全，例如Vector，hashtable。</li><li>相对线程安全：就是通常意义上的线程安全，单独操作时他是线程安全的，但某些操作下，需要额外的同步措施才能保证他的线程安全。</li><li>线程兼容：指对象本身不是线程安全的，但通过在调用端使用同步手段来使对象在并发环境下可以安全使用，例如Arraylist和HashMap。</li><li>线程对立：对象本身不是线程安全，也无法通过同步手段达到。例如Thread的suspend和resume方法。</li></ol><h3 id="9-2-线程安全的实现手段"><a href="#9-2-线程安全的实现手段" class="headerlink" title="9.2 线程安全的实现手段"></a>9.2 线程安全的实现手段</h3><ol><li><p>互斥：例如临界区，信号量，互斥量都是主要的互斥实现手段。在java中，最常见的就是synchronized关键字，有两点要注意：</p><ul><li>第一，synchronized同步块对于同一线程来说是可重入的（可重入性：如果当前线程已经获得了某个监视器对象所持有的锁，那么该线程在该方法中调用另外一个同步方法也同样持有该锁），不会出现自己锁死自己的情况。</li><li>第二，唤醒或阻塞一个线程都需要操作系统来完成，从用户太转换成内核态，需要耗费处理器时间，所以synchronized是一个重量级的操作，可通过阻塞线程自旋来优化。</li></ul><p>除了synchronized以外，还有一种可重入锁（reentrantlock），他增加了三种特性：等待可中断（正在等待的线程可以放弃等待，去处理其他事情)，公平锁(按序拿锁），锁可以绑定多个条件。JDK1.6以后，synchronized已经优化到和Reentrantlock一样的效率。</p></li><li><p>非阻塞同步：前面的都称为阻塞同步。互斥同步算是一种悲观的并发策略，总是认为不去做正确的同步措施，就是发生问题。随着硬件指令集发展，出现一种乐观的策略：先进行操作，如果没有其他线程争用共享数据那操作就成功了，否则就再采取补偿措施，，这些乐观的并发策略不会将线程挂起，因此叫非阻塞同步，关于硬件指令集的发展，这里不再具体介绍。这类方法有AtomicInteger的incrementandget方法。</p></li><li><p>无同步方案：如果一个方法本身不涉及到共享数据，那么就无需同步措施。</p><ul><li>可重入代码：代码执行后可中断然后再回来调用它是不会出现问题的，可重入代码都是线程安全的，反之则不然。特性：<br>不依赖堆上的数据和公共资源，用到的状态量都由参数传入，不调用不可重入方法</li><li>线程本地存储： 共享数据在一个线程里被执行，那么就是线程安全的。</li></ul></li></ol><h2 id="10-0-锁优化"><a href="#10-0-锁优化" class="headerlink" title="10.0 锁优化"></a>10.0 锁优化</h2><p>单纯的synchronized使用的锁太重量，在某些场景下有更好的解决方案</p><h3 id="10-1-自旋锁与自适应自旋"><a href="#10-1-自旋锁与自适应自旋" class="headerlink" title="10.1 自旋锁与自适应自旋"></a>10.1 自旋锁与自适应自旋</h3><p>互斥同步时会引起阻塞，影响性能，因为挂起线程和恢复线程都需要转入内核态，如果锁状态只会持续很短一段时间然后就释放了，那么这段时间去挂起和恢复线程就不值得，这时候可以让线程执行一个忙循环，这就是所谓的自旋锁。</p><h3 id="10-2-锁消除"><a href="#10-2-锁消除" class="headerlink" title="10.2 锁消除"></a>10.2 锁消除</h3><p>虚拟机即时编译期在运行时，会对一些代码进行同步，但是被检测到不可能存在共享数据竞争的锁进行消除。主要判定依据是逃逸分析检测。</p><h3 id="10-3-锁粗化"><a href="#10-3-锁粗化" class="headerlink" title="10.3 锁粗化"></a>10.3 锁粗化</h3><p>如果一系列连续操作都要对同一个对象反复加锁和解锁，那即使没有线程竞争，也会导致不必要的消耗。<br>如果虚拟机探测到有这样一串零碎的操作都对同一个对象进行加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。</p><h3 id="10-4-轻量级锁"><a href="#10-4-轻量级锁" class="headerlink" title="10.4 轻量级锁"></a>10.4 轻量级锁</h3><p>对于绝大部分的锁，在整个同步周期内都是不存在竞争的，如果没有竞争，轻量级锁就是CAS（比较和交换）来代替互斥量，如果存在锁竞争，除了互斥量的消耗，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁比重量级还慢。</p><h3 id="10-5-偏向锁"><a href="#10-5-偏向锁" class="headerlink" title="10.5 偏向锁"></a>10.5 偏向锁</h3><p>如果说轻量级锁是在无竞争的情况下使用CAS代替互斥量，那么偏向锁就是在无竞争的情况下把整个同步消除掉。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer算法题</title>
      <link href="/2019/07/26/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98-%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81%E7%AF%87%E2%80%9C/"/>
      <url>/2019/07/26/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98-%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81%E7%AF%87%E2%80%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="高质量代码篇"><a href="#高质量代码篇" class="headerlink" title="高质量代码篇"></a>高质量代码篇</h1><a id="more"></a><h2 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16.数值的整数次方"></a>16.数值的整数次方</h2><p>题目：<br>实现函数double Power(double base,int exponent),求base的exponent次方。不得使用库函数，同时不需要考虑大数问题</p><p>思路：需要考虑特殊值的问题：</p><ul><li>1、底数为0，指数为负数的情况，无意义</li><li>2、指数为0，返回1</li><li>3、指数为负数，返回1.0/base,-exponent</li><li>4、指数正数，base,exponent，<br>还有效率问题，如果使用连乘效率太低，整数的n次方公式<img src="/2019/07/26/剑指offer算法题-高质量代码篇“/1.jpg" title="[]"></li></ul><pre><code>double pow(double base,int exponent) throws Exception {        if(equal(base,0.0)&amp;&amp;exponent&lt;0){            throw new Exception(&quot;invalid parameters&quot;);        }        if(equal(exponent,0.0)){            return 1;        }        int absExponent=exponent;        if(exponent&lt;0){            absExponent=-exponent;        }        double result=powerWithUnsignedExponent(base,absExponent);        if (exponent&lt;0){            result=1/result;        }        return result;    }    double powerWithUnsignedExponent(double base,int exponent){        if(exponent==0){            return 1;        }        if(exponent==1){            return base;        }        double result=powerWithUnsignedExponent(base,exponent&gt;&gt;1);//用右移代替除法        result*=result;        if((exponent&amp;1) ==1){//这里当指数为奇数时，需要再乘以base                result*=base;        }        return result;    }    boolean equal(double a,double b){        if(a-b&lt;0.0000001&amp;&amp;a-b&gt;-0.0000001){            return true;        }        return false;    }</code></pre><p>由于计算机表示小数（包括float和double型小数）都会有误差，我们不能直接用等号（==）判断两个小数是否相等。如果两个小数的差的绝对值很小，比如小于0.0000001，就可以认为他们相等。</p><h2 id="17-打印从1到最大的n位数"><a href="#17-打印从1到最大的n位数" class="headerlink" title="17.打印从1到最大的n位数"></a>17.打印从1到最大的n位数</h2><p>题目：输入数字n，按顺序打印出从1到最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数999。</p><h3 id="思路1-考虑到int和long只能表示32或64位的二进制数，这里用字符串表示就不会出现溢出问题，首先创造一个字符数组（全部初始化为0），然后对它的最低位，也就n-1的下标位进行加1，其中要考虑进位问题以及到达循环结束，也就是到达最大的n位数，打印时也要对开始的0位进行剔除。"><a href="#思路1-考虑到int和long只能表示32或64位的二进制数，这里用字符串表示就不会出现溢出问题，首先创造一个字符数组（全部初始化为0），然后对它的最低位，也就n-1的下标位进行加1，其中要考虑进位问题以及到达循环结束，也就是到达最大的n位数，打印时也要对开始的0位进行剔除。" class="headerlink" title="思路1: 考虑到int和long只能表示32或64位的二进制数，这里用字符串表示就不会出现溢出问题，首先创造一个字符数组（全部初始化为0），然后对它的最低位，也就n-1的下标位进行加1，其中要考虑进位问题以及到达循环结束，也就是到达最大的n位数，打印时也要对开始的0位进行剔除。"></a>思路1: 考虑到int和long只能表示32或64位的二进制数，这里用字符串表示就不会出现溢出问题，首先创造一个字符数组（全部初始化为0），然后对它的最低位，也就n-1的下标位进行加1，其中要考虑进位问题以及到达循环结束，也就是到达最大的n位数，打印时也要对开始的0位进行剔除。</h3><pre><code>public void printToMaxOfNDigits(int n) {        if (n &lt;= 0) {            return;        }        char[] number = new char[n];        for (int i = 0; i &lt; n; i++) {            number[i] = &#39;0&#39;;        }        while (!increment(number)) {            printNumber(number);        }    }    public boolean increment(char[] number) {        boolean isOverflow = false;        int carryFlag = 0;        int length = number.length;        for (int i = length - 1; i &gt;= 0; i--) {            int sum = number[i] - &#39;0&#39; + carryFlag;//注意ascall码的转换            if (i == length - 1) {//每次都从最低位加1                sum++;            }            if (sum &gt;= 10) {                if (i == 0) {                    isOverflow = true;                    break;                } else {                    sum -= 10;                    carryFlag = 1;                    number[i] = (char) (&#39;0&#39; + sum);                }            } else {                number[i] = (char) (&#39;0&#39; + sum);                break;            }        }        return isOverflow;    }    public void printNumber(char[] number) {//如果单纯的剔除0位，会导致后面为0的位也会被剔除。        boolean isBeginning0 = true;        for (int i = 0; i &lt; number.length; i++) {            if (number[i] != &#39;0&#39;) {                isBeginning0 = false;            }            if (!isBeginning0) {                System.out.print(number[i]);            }        }        System.out.print(&quot;\n&quot;);    }</code></pre><h3 id="思路2：其实就是n个从0到9的全排列-用递归法求"><a href="#思路2：其实就是n个从0到9的全排列-用递归法求" class="headerlink" title="思路2：其实就是n个从0到9的全排列,用递归法求"></a>思路2：其实就是n个从0到9的全排列,用递归法求</h3><pre><code>public void printToMaxOfNDigits(int n) {        if (n &lt;= 0) {            return;        }        char[] number = new char[n];        for (int i = 0; i &lt;10 ; i++) {            number[0]= (char) (i+&#39;0&#39;);            printToMaxOfNDigitsRecruisively(number,n,0);        }    }public void printToMaxOfNDigitsRecruisively(char[] number,int n,int index){        if(index==n-1){//递归终止条件，注意index的变化            printNumber(number);            return;        }        for (int i = 0; i &lt;10 ; i++) {            number[index+1]= (char) (i+&#39;0&#39;);            printToMaxOfNDigitsRecruisively(number,n,index+1);        }    }</code></pre><h2 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18.删除链表的节点"></a>18.删除链表的节点</h2><h3 id="题目1："><a href="#题目1：" class="headerlink" title="题目1："></a>题目1：</h3><p>给定单向链表的头节点和一个节点，定义一个函数在O（1）时间内删除该节点，该节点定义如下：</p><pre><code>public class ListNode {    int value;    ListNode next;    public ListNode(int value){        this.value=value;    }}</code></pre><p>思路： 肯定不能用传统方法，用被删除节点的下一个节点的内容覆盖被删除节点，并把该节点的next指向该节点下一个节点的next。但要分三种情况</p><img src="/2019/07/26/剑指offer算法题-高质量代码篇“/2.PNG" title="[]"><pre><code>public static void deleteNode(ListNode firstNode,ListNode toBeDeleted){        if(firstNode==null||toBeDeleted==null){            return;        }        if(toBeDeleted.next!=null){//有后续节点            ListNode nextNode=toBeDeleted.next;            toBeDeleted.value=nextNode.value;            toBeDeleted.next=nextNode.next;        }        else if(firstNode==toBeDeleted){//无后续节点，并且总共只有一个节点            firstNode=null;        }else {//被删节点是最后一个节点            ListNode currentNode=firstNode;            while(currentNode.next!=toBeDeleted){                currentNode=currentNode.next;            }            currentNode.next=null;        }    }</code></pre><p>注意当被删节点时最后一个节点时，不能单纯的将它赋值为null，要找到他的上一个节点，否则它虽然是null，但还是会被引用。</p><h3 id="题目二："><a href="#题目二：" class="headerlink" title="题目二："></a>题目二：</h3><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><p>思路：首先new一个新的节点，新的节点的next就是链表的头结点，用于处理头节点要被删除的情况，然后用两个指针，preNode和pNode。pNode用来寻找到重复元素的最后一个，preNode指向重复结点第一个的前一个，所以preNode永远在pNode的前面，然后preNode.next=pNode.next来删除节点、</p><pre><code>public static ListNode deleteDuolication(ListNode firstNode) {        if (firstNode == null || firstNode.next == null) {            return firstNode;        }        ListNode headNode=new ListNode(0);//新建节点        headNode.next=firstNode;        ListNode preNode=headNode;        ListNode pNode=headNode.next;        while (pNode!=null){            if(pNode.next!=null&amp;&amp;pNode.value==pNode.next.value){//注意递归的循环。pNext                while (pNode.next!=null&amp;&amp;pNode.next.value==pNode.value){//这两个条件是一样的                    pNode=pNode.next;                }                preNode.next=pNode.next;                pNode=pNode.next;            }            else {                preNode=preNode.next;                pNode=pNode.next;            }        }        return headNode.next;//返回的是head节点的后面一个节点    }</code></pre><h2 id="19-正则表达式的匹配"><a href="#19-正则表达式的匹配" class="headerlink" title="19.正则表达式的匹配"></a>19.正则表达式的匹配</h2><p>题目：请实现一个函数用来匹配包括’.’和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’*‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab*ac*a”匹配，但是与”aa.a”和”ab*a”均不匹配</p><p>思路：<br>当模式中当前字符的后面一个字符不是’*‘时：<br>直接判断他们是否相等，或模式中是否是’.’</p><p>当模式中当前字符的后面一个字符是’*‘时：有两种情况<br>1：字符串字符与模式中的字符相等，他有两种选择：</p><ul><li>忽略当前模式的* 即模式下标+2（因为<em>可以匹配0个字符），比如abc与ab\</em>bc</li><li>字符串下标+1，</li></ul><p>2：不相等，只有一种选择：</p><ul><li>忽略当前模式的* 即模式下标+2（因为*可以匹配0个字符）</li></ul><pre><code>public static boolean match(char[] str,char[] pattern){        if(str==null||pattern==null){            return false;        }        int strIndex=0;        int patternIndex=0;        return  matchCore(str,pattern,strIndex,patternIndex);    }    public static boolean matchCore(char[] str,char[] pattern,int strIndex,int patternIndex){        //有效性检验，两个同时到达尾部，匹配成功        if(strIndex==str.length&amp;&amp;patternIndex==pattern.length){            return true;        }        //pattern先到，匹配失败        if(str.length!=strIndex&amp;&amp;patternIndex==pattern.length){            return false;        }        //模式第二个是*        if(patternIndex+1&lt;pattern.length&amp;&amp;pattern[patternIndex+1]==&#39;*&#39;){            if((strIndex!=str.length&amp;&amp;str[strIndex]==pattern[patternIndex])                    ||strIndex!=str.length&amp;&amp;pattern[patternIndex]==&#39;.&#39;){                return matchCore(str,pattern,strIndex,patternIndex+2)                        ||matchCore(str,pattern,strIndex+1,patternIndex);            }            else {                return matchCore(str,pattern,strIndex,patternIndex+2);            }        }        //模式第二个不是*        if((strIndex!=str.length&amp;&amp;str[strIndex]==pattern[patternIndex])                ||strIndex!=str.length&amp;&amp;pattern[patternIndex]==&#39;.&#39;){            return matchCore(str,pattern,strIndex+1,patternIndex+1);        }        return false;    }</code></pre><p>为什么下标pattern比str先到就匹配失败：<br>比如 abb与ab*<br>str下标比pattern先到，但还是匹配成功</p><h2 id="20-表示数值的字符串"><a href="#20-表示数值的字符串" class="headerlink" title="20.表示数值的字符串"></a>20.表示数值的字符串</h2><p>题目：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p><p>本题考查对字符串的编程能力，我们需要从不同类型的数值中分析规律，要全面考虑数值整数，小数，指数部分的特点以及正负号出现的位置等等。</p><p>思路：</p><p>对字符串的每个字符进行判别分析，</p><ol><li>小数点和e/E都只能出现一次，并且e后面不能出现小数点，e是整数</li><li>对于+号和-号，只能出现在第一个数字以及e的后一位</li></ol><pre><code>public boolean isNumber(char[] str) {        if (str.length == 0 || str == null) {            return false;        }        int index = 0;        while (index &lt; str.length &amp;&amp; str[index] != &#39;.&#39; &amp;&amp; str[index] != &#39;e&#39; &amp;&amp; str[index] != &#39;E&#39;) {//首先要判断index是否越界，不然会出现outofbound错误            if (scanInteger(str, index)) {                index++;            } else {                return false;            }        }        if (str[index] == &#39;.&#39;) {            index++;//+1越过小数点            while (index &lt; str.length &amp;&amp; str[index] != &#39;e&#39; &amp;&amp; str[index] != &#39;E&#39;) {                if (scanUnsignedInteger(str, index)) {                    index++;                } else {                    return false;                }            }        }        if (str[index] == &#39;e&#39; || str[index] == &#39;E&#39;) {            index++;//+1越过e            while (index &lt; str.length) {                if (scanInteger(str, index)) {                    index++;                } else {                    return false;                }            }        }        if (index == str.length) {            return true;        } else {            return false;        }    }    //无符号数判断    public boolean scanUnsignedInteger(char[] str, int index) {        if (str[index] &gt;= &#39;0&#39; &amp;&amp; str[index] &lt;= &#39;9&#39;) {            return true;        }        return false;    }    public boolean scanInteger(char[] str, int index) {        if (str[index] == &#39;+&#39; || str[index] == &#39;-&#39;) {//若出现符号，+1越过后判断无符号数            index++;            if (index == str.length) {                return false;            }        }        return scanUnsignedInteger(str, index);    }</code></pre><h2 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21.调整数组顺序使奇数位于偶数前面"></a>21.调整数组顺序使奇数位于偶数前面</h2><p>题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><p>思路：类似于快排，此题主要考察对扩展性的理解，将一个单独的函数解耦，一部分是判断数组位于哪里的标准，另一部分是拆分数组的操作。</p><pre><code>      public void reOrder(int[] nums){            if (nums.length &lt; 2 || nums == null) {                return;            }            int beginIndex=0;            int endIndex=nums.length-1;            while (beginIndex&lt;endIndex){                while (beginIndex&lt;endIndex&amp;&amp;isEven(nums[endIndex])){                    endIndex--;                }                while (beginIndex&lt;endIndex&amp;&amp;!isEven(nums[beginIndex])){                    beginIndex++;                }                if(beginIndex&lt;endIndex){                    int temp=nums[beginIndex];                    nums[beginIndex]=nums[endIndex];                    nums[endIndex]=temp;                }            }        }        public boolean isEven(int n){            return (n&amp;1)==0;        }</code></pre><h2 id="鲁棒性"><a href="#鲁棒性" class="headerlink" title="鲁棒性"></a>鲁棒性</h2><p>鲁棒是英文Robust的音译。有时也成为健壮性。所谓的鲁棒性是指程序能够判断输入是否合乎要求，并对不合乎要求的输入予以正确的处理</p><h2 id="22-链表的倒数第k个节点"><a href="#22-链表的倒数第k个节点" class="headerlink" title="22.链表的倒数第k个节点"></a>22.链表的倒数第k个节点</h2><p>题目:输入一个链表，输出该链表中倒数第k个结点,单向链表，从1开始计数</p><p>思路：用两个指针，第一个指针指向头结点，开始向后遍历，遍历k-1步后，第二个指针指向头结点，然后两个指针一起向后遍历，这里第一个指针和第二指针之间就永远相差k-1个节点。当第一个指针到达最后的节点，那么第二个指针就是所求，</p><pre><code>public ListNode findKthToTail(ListNode firstNode,int k){           if(firstNode==null||k==0){               return null;           }           ListNode pAhead=firstNode;           ListNode pBehind=null;           for (int i = 0; i &lt;k-1 ; i++) {               if(pAhead.next!=null){                   pAhead=pAhead.next;               }else {                   return null;               }           }           pBehind=firstNode;           while (pAhead.next!=null){               pAhead=pAhead.next;               pBehind=pBehind.next;           }           return pBehind;       }</code></pre><p><strong>程序的鲁棒性要注意三点：</strong><br>输入的firstNode是否为null，链表是否有k个节点<br>如果是在c++中，还要注意k是否为无符号整数，因为k=0，k-1就变成了0xFFFFFFFF,在java中不存在无符号整数。</p><h2 id="23-链表中环的入口节点"><a href="#23-链表中环的入口节点" class="headerlink" title="23.链表中环的入口节点"></a>23.链表中环的入口节点</h2><p>题目：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><img src="/2019/07/26/剑指offer算法题-高质量代码篇“/3.PNG"><p>图中所示链表应返回2.</p><p>思路：</p><ol><li>首先要判断链表是否有环，用两个指针，一个指针一次走一步，另一个指针一次走两步，当他们相遇时就有环，不相遇则无环。</li><li>接下来要求出环中的节点数（n个），因为当定义两个指针指向头结点，一个指针先走n步，然后两个指针再同时走，当他们再次相遇时就是入口节点。</li><li>求节点数就是用1中相遇时的节点，因为这个节点必然在环中，从它开始遍历，当它回到它自身时，计算出节点数。</li></ol><pre><code> public ListNode findEntryNodeOfLoop(ListNode pHead) {        ListNode meetingNode = findMeetingNode(pHead);        if (meetingNode == null) {            return null;        }        int nodesInLoop = 1;        ListNode pNode = meetingNode;        while (pNode.next != meetingNode) {            pNode = pNode.next;            nodesInLoop++;        }        ListNode pNode1 = pHead;        ListNode pNode2 = pHead;        for (int i = 0; i &lt; nodesInLoop; i++) {            pNode1 = pNode1.next;        }        while (pNode1 != pNode2) {            pNode1 = pNode1.next;            pNode2 = pNode2.next;        }        return pNode1;    }    public ListNode findMeetingNode(ListNode pHead) {        if (pHead == null) {            return null;        }        ListNode pSlow = pHead;        ListNode pFast = pHead;        while (pSlow != null &amp;&amp; pFast != null) {            pSlow = pSlow.next;            pFast = pFast.next;            if (pFast!= null) {//不能一次走两步，要判断第一步是否是空，才能走第二步                pFast = pFast.next;            }            if (pSlow == pFast) {                return pFast;            }        }        return null;    }</code></pre><h2 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24.反转链表"></a>24.反转链表</h2><p>题目：反转一个单链表。</p><p>思路：反转时要定义三个指针，一个指针指向当前节点，另一个指针指向下一个节点，因为反转时会造成链表的断裂，无法遍历到下一个节点，最后一个指针用来指向反转后的头节点，即尾部节点</p><pre><code>public ListNode reverseList(ListNode pHead) {       if(pHead==null){           return null;       }       if(pHead.next==null){           return pHead;       }       ListNode pReversedHead=null;       ListNode pNode=pHead;       ListNode pPrev=null;       while (pNode!=null){           ListNode pNext=pNode.next;           if(pNext==null){               pReversedHead=pNode;           }           pNode.next=pPrev;           pPrev=pNode;           pNode=pNext;       }       return pReversedHead;   }</code></pre><h2 id="25-合并两个有序链表"><a href="#25-合并两个有序链表" class="headerlink" title="25.合并两个有序链表"></a>25.合并两个有序链表</h2><p>题目：输入两个递增排序的链表，合并两个链表并使新链表中的节点依然是递增排序的。</p><p>思路：如图：</p><img src="/2019/07/26/剑指offer算法题-高质量代码篇“/4.PNG"><pre><code>public ListNode mergeLists(ListNode pHead1, ListNode pHead2) {        if (pHead1 == null) {            return pHead2;        } else if (pHead2 == null) {            return pHead1;        }        ListNode pHead3 = null;        if (pHead1.value &gt; pHead2.value) {            pHead3 = pHead2;            pHead3.next = mergeLists(pHead1, pHead2.next);        } else {            pHead3 = pHead1;            pHead3.next = mergeLists(pHead1.next, pHead2);        }        return pHead3;    }</code></pre><h2 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26.树的子结构"></a>26.树的子结构</h2><p>题目：给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p><pre><code> 给定的树 s：     3    / \   4   5  / \ 1   2    /   0给定的树 t：   4  / \ 1   2返回 false。</code></pre><p>思路：用递归，从根节点开始，分别判断左右节点的值是否相同</p><pre><code> public boolean hasSubTree(TreeNode root1, TreeNode root2) {        boolean result=false;        if(root1!=null&amp;&amp;root2!=null){            if(root1.value==root2.value){                result=doesTree1HasTree2(root1,root2);            }            if(!result){               result=hasSubTree(root1.left,root2);            }            if(!result){                result=hasSubTree(root1.rigth,root2);            }        }        return result;    }    public boolean doesTree1HasTree2(TreeNode root1,TreeNode root2){        if(root2==null){            return true;        }        if(root1==null){            return false;        }        if(root1.value!=root2.value){            return false;        }        return doesTree1HasTree2(root1.left,root2.left)&amp;&amp;doesTree1HasTree2(root1.rigth,root2.rigth);}</code></pre><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>高质量的代码具有规范性，完整性，鲁棒性。</p><img src="/2019/07/26/剑指offer算法题-高质量代码篇“/5.PNG">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客部署时遇到的问题</title>
      <link href="/2019/07/25/hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2019/07/25/hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="部署博客时遇到的错误"><a href="#部署博客时遇到的错误" class="headerlink" title="部署博客时遇到的错误:"></a>部署博客时遇到的错误:</h2><a id="more"></a><p>用hexo g 生成时<br>遇到</p><pre><code>YAMLException: end of the stream or a document separator is expected at line 19, column 1:</code></pre><p>并不是文件格式出问题，而是是因为我直接拷贝之前的md文件，缺少了_config.yml文件自动在hexo n 生成出来的md文件中的部分内容所导致的。<br>解决方案：<br>重新新建一个md文件：</p><pre><code>hexo new &quot;fileName&quot;</code></pre><p>然后转移文章内容。</p><h2 id="图片无法显示"><a href="#图片无法显示" class="headerlink" title="图片无法显示"></a>图片无法显示</h2><p>hexo-asset-image插件不能用的问题<br>这个插件我猜是没有更新及时支持新版的hexo，我的是3.9.0 （可以通过 hexo -version 命令查看版本）</p><p>安装hexo-asset-image的时候就不太正常，如下图</p><img src="/2019/07/25/hexo博客部署时遇到的问题/1.jpg" title="[]"><p>之前根据网上的教程找的hexo文章插入图片的教程大多都是让装hexo-asset-image这个插件， 可是我装好以后发现有问题，生成的html图片路径是”/.com/xxx.jpg”这样的，明显不能访问于是去官网看了下文档，官网显示新版的hexo已经加入了图片标签的支持，如下图：</p><p>post_asset_folder:true 这个参数设置为true后(_config.yml文件中)，每次new命令创建文章的时候就会生成同名的资源文件夹，部署的时候就会把资源文件同步上传到文章目录下在发布文章时，先把我们要用到的图片放到文章目录下面的同名目录 ，比如我 hexo new test这样就会在_post目录下面生成test.md文件和test目录，test目录就是这篇文章的资源目录</p><h3 id="使用官方提供的标签（老版本的好像没有）"><a href="#使用官方提供的标签（老版本的好像没有）" class="headerlink" title="使用官方提供的标签（老版本的好像没有）"></a>使用官方提供的标签（老版本的好像没有）</h3><p>假如我们要插入一张a.jpg的图片，就先复制图片到test目录下面，然后在需要插入图片的地方插入标签 </p><blockquote></blockquote><p>发布的时候就能正常显示了</p><h3 id="使用markdown方式插入图片"><a href="#使用markdown方式插入图片" class="headerlink" title="使用markdown方式插入图片"></a>使用markdown方式插入图片</h3><p>后来又发现可以直接使用传统的md规范的方式来插入图片，如：</p><pre><code>![图片描述](a.jpg) </code></pre><p>注意这里跟使用hexo-asset-image插件的方式去区别是更简化了，都不需要写相对目录了，只写文件名就行，hexo会从默认的文章目录下面同名目录下找到资源文件</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java反射机制</title>
      <link href="/2019/07/24/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/07/24/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-反射的概述："><a href="#1-反射的概述：" class="headerlink" title="1.反射的概述："></a>1.反射的概述：</h2><a id="more"></a><p>java反射机制是在运行状态中，对于任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。要想剖解一个类，必须先获取到该类的字节码文件对象。</p><p><strong>反射就是把java类中的各种成分映射到一个个的java对象</strong></p><p>例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。<br>     （其实：一个类中这些成员方法、构造方法、在加入类中都有一个类来描述）<br>如图是类的正常加载过程：反射的原理在与class对象。<br>熟悉一下加载的时候：Class对象的由来是将class文件读入内存，并为之创建一个Class对象。</p><img src="/2019/07/24/java反射机制/3.png" title="[类加载过程]"><h2 id="2-反射的使用"><a href="#2-反射的使用" class="headerlink" title="2.反射的使用"></a>2.反射的使用</h2><h3 id="获取class对象的三种方式："><a href="#获取class对象的三种方式：" class="headerlink" title="获取class对象的三种方式："></a>获取class对象的三种方式：</h3><ul><li><ol><li>Object——》getClass（）</li></ol></li><li><ol start="2"><li>任何数据类型（包括基本数据类型）都有一个静态的classs属性</li></ol></li><li><ol start="3"><li>通过class类的静态方法： forName（String className）<br>```<br>package fanshe;<br>/**</li></ol><ul><li><p>获取Class对象的三种方式</p></li><li><p>1 Object ——&gt; getClass();</p></li><li><p>2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性</p></li><li><p>3 通过Class类的静态方法：forName（String  className）(常用)</p></li><li></li><li><p>/<br>public class Fanshe {<br> public static void main(String[] args) {</p><pre><code> //第一种方式获取Class对象   Student stu1 = new Student();//这一new 产生一个Student对象，一个Class对象。 Class stuClass = stu1.getClass();//获取Class对象 System.out.println(stuClass.getName()); //第二种方式获取Class对象 Class stuClass2 = Student.class; System.out.println(stuClass == stuClass2);//判断第一种方式获取的Class对象和第二种方式获取的是否是同一个 //第三种方式获取Class对象 try {     Class stuClass3 = Class.forName(&quot;fanshe.Student&quot;);//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名     System.out.println(stuClass3 == stuClass2);//判断三种方式是否获取的是同一个Class对象 } catch (ClassNotFoundException e) {     e.printStackTrace(); }</code></pre><p> }<br>}<br>```</p></li></ul></li><li><p><em>注意：在运行期间，一个类，只有一个Class对象产生*</em><br>三种方式常用第三种，第一种对象都有了还要反射干什么。第二种需要导入类的包，依赖太强，不导包就抛编译错误。一般都第三种，一个字符串可以传入也可写在配置文件中等多种方法。</p></li></ul><p>通过反射还可以获取构造方法，成员方法等，反射在实际开发中使用的不多，像c++，pascal等语言没有提供这样的特性。由于反射机制能够实现在运行时对类进行装载，因此能够增加程序的灵活性，但是不恰当的使用反射机制，也会严重影响系统的性能。</p><p>若想深入了解反射特性，可参考这篇博客:<br><a href="https://blog.csdn.net/sinat_38259539/article/details/71799078" target="_blank" rel="noopener">https://blog.csdn.net/sinat_38259539/article/details/71799078</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer算法题</title>
      <link href="/2019/07/18/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/"/>
      <url>/2019/07/18/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识篇"><a href="#基础知识篇" class="headerlink" title="基础知识篇"></a>基础知识篇</h1><a id="more"></a><h2 id="3-二维数组中查找目标值"><a href="#3-二维数组中查找目标值" class="headerlink" title="3.二维数组中查找目标值"></a>3.二维数组中查找目标值</h2><p>题目描述：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每<br>一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二<br>维数组和一个整数，判断数组中是否含有该整数。</p><p>思路：从右上角或左下角开始找，逐行删除，或者用二分法查找</p><pre><code>boolean find(int[][] array,int target){        if (array.length == 0) {            return false;        }        int row = 0;        int column = array[0].length-1;        while (row &lt; array.length &amp;&amp; column &gt;= 0) {            if(array[row][column] == target) {                return true;            }            if(array[row][column] &gt; target) {                column--;            } else {                row++;            }        }        return false;    }</code></pre><p>这里 array.length 返回的是列的长度</p><h2 id="4-替换字符串中的空格"><a href="#4-替换字符串中的空格" class="headerlink" title="4. 替换字符串中的空格"></a>4. 替换字符串中的空格</h2><p>题目描述：将一个字符串中的空格替换成“%20”<br>例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<br>一般是要求在原来的字符串上进行替换</p><p>思路：先遍历一次字符串，计算出替换后字符串的长度，然后从后向前复制,复杂度为O(n)</p><pre><code>String replaceSpace(StringBuffer str){        if(str==null)            return null;        int spaceNum=0;        for (int i = 0; i &lt;str.length() ; i++) {            if(str.charAt(i)==&#39; &#39;)                spaceNum++;        }        int length=str.length();        str.setLength(str.length()+spaceNum*2);        int index=str.length()-1;        for (int i=length-1;i&gt;0;i--){            if(&#39; &#39;== str.charAt(i)) {                str.setCharAt(index--, &#39;0&#39;);                str.setCharAt(index--, &#39;2&#39;);                str.setCharAt(index--, &#39;%&#39;);            }            else                str.setCharAt(index--,str.charAt(i));        }            return String.valueOf(str);    }</code></pre><p>字符串的比较要用equals，基本类型用==</p><h2 id="7-根据前序和中序遍历重建二叉树"><a href="#7-根据前序和中序遍历重建二叉树" class="headerlink" title="7.根据前序和中序遍历重建二叉树"></a>7.根据前序和中序遍历重建二叉树</h2><p>题目描述：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p>思路：先找出根节点，然后利用递归方法构造二叉树<br>前序遍历的第一个节点就是根节点，然后找到中序遍历中根节点的位置，根节点左边的就是左子树，右边就是右子树，然后再到前序遍历中找到左子树的个数，和右子树的个数，然后递归方法</p><pre><code>public TreeNode buildTree(int[] pre, int[] in) {        return makeTree(pre,in,0,pre.length-1,0,in.length-1);    } TreeNode makeTree(int[] pre,int[] in,int preStart,int preEnd,int inStart,int inEnd){        if (preStart&gt;preEnd){            return null;        }        TreeNode root=new TreeNode(pre[preStart]);        for (int i = inStart; i &lt;inEnd ; i++) {//这里是遍历中序，从起点开始            if(pre[preStart]==in[i]){                root.left=makeTree(pre,in,preStart+1,preStart+i-inStart,inStart,i-1);                root.right=makeTree(pre,in,preStart+i-inStart +1,preEnd,i+1,inEnd);                break;            }        }        return root;    }</code></pre><p>尤其注意前序遍历中的左子树的end（prestart+1-instart）</p><h2 id="8-二叉树的下一个节点"><a href="#8-二叉树的下一个节点" class="headerlink" title="8.二叉树的下一个节点"></a>8.二叉树的下一个节点</h2><p>题目描述：给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><p>思路：若节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点；若节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果</p><pre><code>public TreeNode getNext(TreeNode pNode) {        if(pNode==null){            return null;        }        TreeNode pNext=null;        if(pNode.right!=null){            pNext=pNode.right;            while (pNext.left!=null){                pNext=pNext.left;            }        }else if (pNode.parent!=null){            TreeNode current=pNode;            TreeNode pParent=current.parent;            while (pParent!=null&amp;&amp;pParent.right==current){                current=current.parent;                pParent=current.parent;            }            pNext=pParent;        }            return pNext;    }</code></pre><p>注意pNode.parent!=null时，循环条件中的内容，current和pparent的迭代。</p><h2 id="9-用两个栈实现队列"><a href="#9-用两个栈实现队列" class="headerlink" title="9. 用两个栈实现队列"></a>9. 用两个栈实现队列</h2><p>题目描述：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><p>思路：（push）第一个栈用来压入元素，（pop）然后当第二个栈为空时，栈1的全部元素出栈到第二个栈，第二个栈最后一个元素直接出栈。</p><pre><code>class Queue {    private Stack stack1;    private Stack stack2;    /** Initialize your data structure here. */    public Queue() {    }    /** Push element x to the back of queue. */    public void push(int x) {            stack1.push(x);    }    /** Removes the element from in front of queue and returns that element. */    public int pop() throws Exception {        if(stack1.isEmpty()&amp;&amp;stack2.isEmpty()){            throw new Exception(&quot;empty&quot;);//因为返回值是int，用exception来表示栈为空的情况        }        if(stack2.isEmpty()){            while (!stack1.isEmpty()) {//这里要讲栈1所有的元素压入栈2                stack2.push(stack1.pop());            }        }        return (int) stack2.pop();    }</code></pre><h2 id="10-斐波那契数列的应用"><a href="#10-斐波那契数列的应用" class="headerlink" title="10. 斐波那契数列的应用"></a>10. 斐波那契数列的应用</h2><h3 id="10-1-输出斐波那契数列的第n项"><a href="#10-1-输出斐波那契数列的第n项" class="headerlink" title="10.1 输出斐波那契数列的第n项"></a>10.1 输出斐波那契数列的第n项</h3><p>题目描述：现在要求输入一个整数n，请你输出斐波那契数列的第n项。<br>斐波那契数列：</p><img src="/2019/07/18/剑指offer算法题-基础知识篇/1.PNG" title="[斐波那契数列函数]"><p>思路：递归的效率低，使用循环方式。</p><pre><code>public static long Fibonacci(long x){        if(x==0){            return 0;        }        if(x==1){            return 1;        }        long fibNMinusOne=1;        long fibNMinusTwo=0;        long fibN=0;        for (int i = 2; i &lt;=x ; ++i) {            fibN=fibNMinusOne+fibNMinusTwo;            fibNMinusTwo=fibNMinusOne;            fibNMinusOne=fibN;//这里注意先赋值给fibNMiusTwo，再赋值给fibNMinusOne        }        return fibN;    }</code></pre><h3 id="10-2-青蛙跳台阶-1或2级"><a href="#10-2-青蛙跳台阶-1或2级" class="headerlink" title="10.2. 青蛙跳台阶(1或2级)"></a>10.2. 青蛙跳台阶(1或2级)</h3><p>题目描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p>思路：斐波那契数列思想：当只有一级台阶时，只有一种跳法，两级台阶有两种跳法，当有n级台阶时，小青蛙第一步跳1级，那么剩下的就是n-1级台阶，第一步跳两级，就是n-2级台阶，依次求。</p><p>算法与上一题一样，只是起点与输入的数字不同。</p><h3 id="10-3-小矩形无重叠覆盖大矩形"><a href="#10-3-小矩形无重叠覆盖大矩形" class="headerlink" title="10.3 小矩形无重叠覆盖大矩形"></a>10.3 小矩形无重叠覆盖大矩形</h3><p>题目描述：我们可以用2x1的小矩形横着或者竖着去覆盖更大的矩形。请问用<br>n个2x1的小矩形无重叠地覆盖一个2xn的大矩形，总共有多少种方法？</p><p>思路：斐波那契数列思想</p><img src="/2019/07/18/剑指offer算法题-基础知识篇/2.PNG" title="[如图]"><p>第一次竖着放，那么后边有2x（n-1)的区域；第一次横着放，那么底下就必须横着放，后边就有2x（n-2）的区域</p><h3 id="10-4-青蛙跳台阶-n级"><a href="#10-4-青蛙跳台阶-n级" class="headerlink" title="10.4. 青蛙跳台阶(n级)"></a>10.4. 青蛙跳台阶(n级)</h3><p>题目描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳<br>上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br>思路：2^(n-1)</p><h2 id="对几万名员工的年龄排序"><a href="#对几万名员工的年龄排序" class="headerlink" title="对几万名员工的年龄排序"></a>对几万名员工的年龄排序</h2><p>题目描述：</p><p>面试官： 请实现一个排序算法，要求时间复杂度为O（N）<br>应聘者：请问对什么数字进行排序，共有多少数字？<br>面试官：我们想对公司所有员工按年龄排序，我们公司共有几万名员工；<br>应聘者：也就是说数字的大小在一个较小的范围之内，对吗？<br>面试官：是的<br>应聘者：可以使用辅助空间吗？<br>面试官：看你用多少内存，只允许使用常量大小的辅助空间，不得超过O(N);<br>应聘者：好的，我知道了；</p><p>思路：用额外的空间来存储每个年龄出现的次数，得到一个类似直方图的分布，然后对原来的数组重新排序。</p><pre><code> public static int[] sort(int[] ages) throws Exception {        if(ages.length&lt;=1||ages==null){            return ages;        }        int oldestAge=99;        int[] timeOfAge=new int[oldestAge+1];        for (int i = 0; i &lt;oldestAge+1 ; ++i) {//这题大多数以++i的形式赋值，只会影响初始值和结束值，不会影响循环次数。            timeOfAge[i]=0;        }        for (int i = 0; i &lt;ages.length ; ++i) {            int age=ages[i];            if(age&lt;0||age&gt;oldestAge){                throw new Exception(&quot;age out of bound&quot;);            }            timeOfAge[age]+=1;        }        int index=0;        for (int i = 0; i &lt;oldestAge ; ++i) {            for (int j = 0; j &lt;timeOfAge[i] ; ++j) {                ages[index]=i;//这里直接抛弃原来的数组，直接赋值                index++;            }        }        return ages;    }</code></pre><p>这里用100的整数空间换来了O（n）的时间效率；</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="最简单的快排："><a href="#最简单的快排：" class="headerlink" title="最简单的快排："></a>最简单的快排：</h3><pre><code>public static void quickSort(int[] A ,int left ,int right){        if(left&gt;=right){            return;        }else {            int i=left;            int j=right;            int t=A[left];            while (i&lt;j){                while (j&gt;i&amp;&amp;A[j]&gt;=t){                    j--;                }                while (i&lt;j&amp;&amp;A[i]&lt;=t){                    i++;                }                if(i&lt;j){                    int temp=A[i];                    A[i]=A[j];                    A[j]=temp;                }            }            A[left]=A[i];            A[i]=t;            quickSort(A,left,i-1);            quickSort(A,i+1,right);        }    }</code></pre><p> 注意：去左边的值为中枢，遍历时应先从后往前寻找比中枢小的值，而不是从前往后寻找比中枢大的值，因为最终是left与i交换值，i如果从前往后没有找到比中枢大的值，那么此时left不需要交换位置，然而i的位置已经变了，交换后就会出错。<br> 还有当两边都划分完了，此时i和j应该值是一样的</p><h2 id="11-旋转数组的最小数字："><a href="#11-旋转数组的最小数字：" class="headerlink" title="11.旋转数组的最小数字："></a>11.旋转数组的最小数字：</h2><p>题目描述：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数<br>组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元<br>素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。</p><p>思路：用二分法，当mid&gt;=index1 时，最小数则在mid的右边，当mid&lt;=index时，最小数在mid的左边，有两个特例，1：当旋转数组是他本身时，即未旋转，直接返回第一个数；2：若左中右三值相等，按序来查找。</p><pre><code>public int Min(int[] nums,int length) throws Exception {        if(nums==null||length&lt;=0){            throw new Exception(&quot;invalid parameters&quot;);        }        int index1=0;        int index2=length-1;        int midIndex=index1;//在这里考虑了当第一个数小于最后一个数，即未旋转时，直接返回index1        while (nums[index1]&gt;=nums[index2]){            if(index2-index1==1){                midIndex=index2;                break;            }            midIndex=(index1+index2)/2 ;            if(nums[midIndex]==nums[index1]&amp;&amp;nums[midIndex]==nums[index2]){//前后中三数相等，按序                return minInOrder(nums,index1,index2);            }           else if(nums[midIndex]&gt;=nums[index1]){                index1=midIndex;            }else if(nums[midIndex]&lt;=nums[index2]){                index2=midIndex;            }        }        return nums[midIndex];    }    public int minInOrder(int[] nums,int index1,int index2){        int result=nums[index1];        for (int i = index1+1; i &lt;index2 ; i++) {            if(nums[i]&lt;result){                result=nums[i];            }        }        return result;    }</code></pre><p><strong>补充一个小知识点</strong>：<br>在for循环中 i++与++i的效果是相等的</p><p>for(表达式1；表达式2；表达式3) 语句<br>它的执行过程如下： </p><p>1) 先求解表达式1。<br>2) 求解表达式2，若其值为真（非0），则执行for语句中指定的内嵌语句，然后执行下面第3）步；若其值为假（0），则结束循环，转到第5）步。<br> 3) 求解表达式3。<br>4) 转回上面第2）步继续执行。<br> 5) 循环结束，执行for语句下面的一个语句</p><p> 但他们的运行时间有差别，在java中，i++需要一个临时变量来存储自增前的值，而++i不需要，建议大家以后在写for循环且不影响逻辑的情况下多使用++i，少使用i++     </p><h2 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12.矩阵中的路径"></a>12.矩阵中的路径</h2><p> 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p><p>思路：回溯法：回溯法可以看成是蛮力法的升级版<br>这个一个走路径的问题，需要判断这个矩阵中的每一个结点是否可以走一条路径，在走的过程中，设置一个和矩阵大小相同的整型数组表示是否已经访问，如果某个结点访问了，那么该结点的是否访问则为1。每次遍历一个结点的时候，递归的方式分别向左、向右、向上、向下。  </p><pre><code>public boolean hasPath(char[] matrix, int rows, int cols, char[] str) {        if(matrix==null||rows&lt;1||cols&lt;1||str.length&lt;0){            return false;        }        int[] flag=new int[matrix.length];        for (int i = 0; i &lt;rows ; i++) {            for (int j = 0; j &lt; cols; j++) {                if(hasPathCore(matrix,flag,rows,cols,i,j,str,0)){                    return true;                }            }        }        return false;    }    public boolean hasPathCore(char[] matrix,int[] flag, int rows, int cols,int i,int j, char[] str,int k){        int index=i*cols+j;        if(i&lt;0||j&lt;0||i&gt;=rows||j&gt;=cols||matrix[index]!=str[k]||flag[index]==1){            return false;        }        if(k+1==str.length){//最终结束条件            return true;        }        flag[index]=1;//标识已走过        if(hasPathCore(matrix,flag,rows,cols,i+1,j,str,k+1)        ||hasPathCore(matrix,flag,rows,cols,i,j+1,str,k+1)        ||hasPathCore(matrix,flag,rows,cols,i-1,j,str,k+1)        ||hasPathCore(matrix,flag,rows,cols,i,j-1,str,k+1)){            return true;        }        flag[index]=0;//这个路径是死路，将其重置。        return false;    }</code></pre><p><strong>补充：递归，回溯和DFS的区别</strong><br>递归是一种算法结构，回溯是一种算法思想<br>一个递归就是在函数中调用函数本身来解决问题<br>回溯就是通过不同的尝试来生成问题的解，有点类似于穷举，但是和穷举不同的是回溯会“剪枝”，意思就是对已经知道错误的结果没必要再枚举接下来的答案了，比如一个有序数列1,2,3,4,5，我要找和为5的所有集合，从前往后搜索我选了1，然后2，然后选3 的时候发现和已经大于预期，那么4,5肯定也不行，这就是一种对搜索过程的优化</p><p>回溯搜索是深度优先搜索（DFS）的一种<br>对于某一个搜索树来说（搜索树是起记录路径和状态判断的作用），回溯和DFS，其主要的区别是，回溯法在求解过程中不保留完整的树结构，而深度优先搜索则记下完整的搜索树。</p><p>为了减少存储空间，在深度优先搜索中，用标志的方法记录访问过的状态，这种处理方法使得深度优先搜索法与回溯法没什么区别了。</p><h2 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13.机器人的运动范围"></a>13.机器人的运动范围</h2><p>题目描述：地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><p>思路：回溯法，与上题类似，</p><pre><code>public int movingCount(int threshold,int rows,int cols){        if(threshold&lt;0||rows&lt;0||cols&lt;0){            return 0;        }        boolean[] visited=new boolean[rows*cols];        for (int i = 0; i &lt;visited.length ; i++) {            visited[i]=false;        }        int count=movingCountCore(threshold,rows,cols,0,0,visited);        return count;    }    int movingCountCore(int threshold,int rows,int cols,int row,int col,boolean[] visited){        int count=0;        if(check(threshold,rows,cols,row,col,visited)){            visited[row*cols+col]=true;            count=1+movingCountCore(threshold,rows,cols,row+1,col,visited)                    +movingCountCore(threshold,rows,cols,row,col+1,visited)                    +movingCountCore(threshold,rows,cols,row-1,col,visited)                    +movingCountCore(threshold,rows,cols,row,col-1,visited);        }        return count;    }    boolean check(int threshold,int rows,int cols,int row,int col,boolean[] visited){        if(row&lt;0||row&gt;=rows||col&lt;0||col&gt;=cols||visited[row*cols+col]                ||getDigitSum(row)+getDigitSum(col)&gt;threshold){            return false;        }        return true;    }    int getDigitSum(int num){        int sum=0;        while (num&gt;0){            sum+=num%10;            num/=10;        }        return sum;    }</code></pre><h2 id="14-剪绳子"><a href="#14-剪绳子" class="headerlink" title="14.剪绳子"></a>14.剪绳子</h2><p>题目描述：<br>给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m≥1）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]<em>k[1]</em>…*k[m]可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。</p><h3 id="第一种思路：动态规划："><a href="#第一种思路：动态规划：" class="headerlink" title="第一种思路：动态规划："></a>第一种思路：动态规划：</h3><p>把大问题化成小问题，对小问题求最优解，再将小问题的最优解组合起来能否是整个问题的最优解。将绳子从第i处剪，长度分为i与l-i，然后分别求i和l-i的最优解，但0,1，2,3的最优解已经知晓，从4到length（绳子的长度）依次求最优解，</p><pre><code>    public int maxProductAfterCutting(int length){        if(length&lt;2){            return 0;        }        if(length==2){            return 1;        }        if(length==3){            return 2;        }        int[] product=new int[length+1];        product[0]=0;        product[1]=1;        product[2]=2;        product[3]=3;//这里指的是绳子长度&gt;4的绳子切成3，2，1时的最优解        for (int i = 4; i &lt;=length ; i++) {            int max=0;            for (int j = 1; j &lt;=i/2 ; j++) {//只需计算到i的一半                 product[i]=product[j]*product[i-j];                    if(max&lt;product[i]){                        max=product[i];                    }            }            product[i]=max;        }        int max=product[length];        return max;    }</code></pre><h3 id="第二种思路-贪婪"><a href="#第二种思路-贪婪" class="headerlink" title="第二种思路:贪婪"></a>第二种思路:贪婪</h3><p>从问题的某一个初始解出发逐步逼近给定的目标，以尽快求得更好的解。当算法达到某一步不能前进时，停止算法</p><p>当n&gt;=5n&gt;=5时，3(n−3)&gt;=2(n−2)3(n−3)&gt;=2(n−2)且只在n取5时取等号，且它们都大于nn，所以应把绳子剪成尽量多的3，让剩下的都是2这样的组合。</p><p>书上言尽于此，我想了下如果剪成其它大小的会不会更好。如果剪成4，那么4=2×2=2+24=2×2=2+2就还是和剪成两个2一样，如果剪成5，那么5还能继续剪剪成3和2，往后也是一样。试想更大的数，比如15，得到一段15以后不剪是不可能的，因为前面说了这时候3(n−3)&gt;2(n−2)&gt;n3(n−3)&gt;2(n−2)&gt;n，那么剪成更小的段，只要不小于5就一定满足这个就要继续减，如果比5小，从1~4的情况都想过了，4是不用管的或者剪成两个2，3就保留，2也保留，1不要出现。</p><pre><code>  public int greedyCutting(int length){        if(length&lt;2){            return 0;        }        if(length==2){            return 1;        }        if(length==3){            return 2;        }        int timesOf3=length/3;        if(length-timesOf3*3==1){            timesOf3-=1;//余数为1，即含数字4，此时剪成两个2更大        }        int timeOf2=(length-timesOf3*3)/2;        return  ((int) Math.pow(3,timesOf3)*(int)Math.pow(2,timeOf2));//pow函数返回double类型    }</code></pre><h2 id="动态规划与贪心算法的区别："><a href="#动态规划与贪心算法的区别：" class="headerlink" title="动态规划与贪心算法的区别："></a>动态规划与贪心算法的区别：</h2><ul><li>贪心：<br>基本思想：贪心算法并不从整体最优上加以考虑，它所做的选择只是在某种意             &emsp;&emsp;&emsp;&emsp;&emsp;义上的局部最优解。<br>基本要素：最优子结构性质和贪心选择性质。</li></ul><table><thead><tr><th>最优子结构性质</th><th align="center">贪心选择性质</th></tr></thead><tbody><tr><td>问题的整体最优解中包含子问题的最优解</td><td align="center">整体的最优解可通过一系列局部最优解达到，每次的选择可依赖以前作出的选择，但不依赖后续选择</td></tr></tbody></table><ul><li>动态规划<br>基本思想：将待求解的问题分解成若干个子问题，先求解子问题，然后从<br>&emsp;&emsp;&emsp;&emsp;&emsp;这些子问题的解得到原问题的解。<br>基本要素：最优子结构性质和重叠子问题性质</li></ul><p><strong>共同点</strong>:<br>两者都具有最优子结构性质<br><strong>不同点</strong>：</p><ol><li>动态规划算法中，每步所做的选择往往依赖于相关子问题的解，因而只有在解出相关子问题时才能做出选择。而贪心算法，仅在当前状态下做出最好选择，即局部最优选择，然后再去解做出这个选择后产生的相应的子问题。</li><li>动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常自顶向下的方式进行</li></ol><h2 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15.二进制中1的个数"></a>15.二进制中1的个数</h2><p>题目描述：任意给定一个32位有符号整数n，求n的二进制表示中1的个数，比如n = 5（0101）时，返回2，n = 15（1111）时，返回4</p><p>思路：<br>最原始的思路，不断对n进行右移，判断最后一个数是否为1（与1相与），但n如果是负数，则会陷入死循环，因为负数右移第一个数增加的是1，（补充：除法的效率比移位运算低的多）。<br>另一种思路：<br>不断对1进行左移，在与原整数相与，32位整数需要循环32次<br>最好的解法：<br>一个整数减去1，则第一个1后面的0全部变为1，第一个1变为0，得到的数与原来的相与，再重复以上操作，有多少个1重复多少次</p><pre><code>int timesOf1(int num){        int count=0;        while (num!=0){            int temp=num-1;            num=num&amp;temp;            count++;        }        return count;    }</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown-语法</title>
      <link href="/2019/07/17/MarkDown-%E8%AF%AD%E6%B3%95-1/"/>
      <url>/2019/07/17/MarkDown-%E8%AF%AD%E6%B3%95-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown-语法"><a href="#Markdown-语法" class="headerlink" title="Markdown 语法"></a>Markdown 语法</h1><a id="more"></a><h2 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h2><p>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p><p>注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。</p><p>示例：</p><pre><code># 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题</code></pre><h2 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h2><ul><li><p>加粗<br>要加粗的文字左右分别用两个*号包起来</p></li><li><p>斜体<br>要倾斜的文字左右分别用一个*号包起来</p></li><li><p>斜体加粗<br>要倾斜和加粗的文字左右分别用三个*号包起来</p></li><li><p>删除线<br>要加删除线的文字左右分别用两个~~号包起来</p></li></ul><h2 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h2><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;<br>示例：</p><blockquote><p> i am iron man</p></blockquote><h2 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h2><p>三个或者三个以上的 - 或者 * 都可以。<br>示例：</p><hr><hr><hr><hr><h2 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h2><p>语法：</p><pre><code>![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</code></pre><p>示例:</p><img src="/2019/07/17/MarkDown-语法-1/dragon.jpg" title="[斐波那契数列函数]"><h2 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h2><p>语法：</p><pre><code>[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加</code></pre><p>示例：</p><pre><code>[简书](http://jianshu.com)[百度](http://baidu.com)</code></pre><p>效果如下：</p><p><a href="http://jianshu.com" target="_blank" rel="noopener">简书</a><br><a href="http://baidu.com" target="_blank" rel="noopener">百度</a></p><h2 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h2><ul><li>无序列表</li></ul><p>语法：<br>无序列表用 - + * 任何一种都可以</p><pre><code>- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格</code></pre><ul><li>有序列表</li></ul><p>语法：<br>数字加点</p><pre><code>1.列表内容2.列表内容3.列表内容</code></pre><p>注意：序号跟内容之间要有空格</p><ul><li>列表嵌套</li></ul><p>上一级和下一级之间敲三个空格即可</p><h2 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h2><p>语法：</p><pre><code>表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略</code></pre><p>示例：</p><pre><code>姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟</code></pre><table><thead><tr><th>姓名</th><th align="center">技能</th><th align="right">排行</th></tr></thead><tbody><tr><td>刘备</td><td align="center">哭</td><td align="right">大哥</td></tr><tr><td>关羽</td><td align="center">打</td><td align="right">二哥</td></tr><tr><td>张飞</td><td align="center">骂</td><td align="right">三弟</td></tr></tbody></table><h2 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h2><p>语法：</p><ul><li>单行代码：代码之间分别用一个反引号包起来<pre><code>`代码neir`</code></pre><code>代码neir</code></li><li>代码块：代码之间分别用三个反引号，且两边的反引号单独占一行</li></ul><pre><code>  代码...  代码...  代码...</code></pre><h2 id="十丶缩进"><a href="#十丶缩进" class="headerlink" title="十丶缩进"></a>十丶缩进</h2><p>在语句前面加</p><ul><li>&amp;ensp； 代表一个空格</li><li>&amp;emsp； 代表两个空格</li><li>&amp;#160； 代表一个空格</li><li>&amp;#8194；一个空格</li><li>&amp;#8195； 两个</li></ul><p>注意上方后面的分号也要加进去</p><h2 id="十一丶转义字符"><a href="#十一丶转义字符" class="headerlink" title="十一丶转义字符"></a>十一丶转义字符</h2><p>当想输入特殊字符是 可以在特殊字符前面加上/来表示</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 常用命令（待补充）</title>
      <link href="/2019/07/17/Ubuntu-Command/"/>
      <url>/2019/07/17/Ubuntu-Command/</url>
      
        <content type="html"><![CDATA[<h2 id="Ubuntu-常用命令"><a href="#Ubuntu-常用命令" class="headerlink" title="Ubuntu 常用命令"></a>Ubuntu 常用命令</h2><a id="more"></a><h3 id="简单命令一-严格区分大小写-："><a href="#简单命令一-严格区分大小写-：" class="headerlink" title="简单命令一(严格区分大小写)："></a>简单命令一(严格区分大小写)：</h3><pre><code>$ ①sudo dpkg -ilinuxqq_1.0-preview1_i386.deb//安装qq命令</code></pre><pre><code>$ ②cd /                  ##打开系统根目录</code></pre><pre><code>$ ③ls                    ##列出文件和目录</code></pre><pre><code>④cd /home</code></pre><pre><code>⑤cd    和 cd  ../..和  cd ~类似     ##进入用户主目录</code></pre><pre><code>⑥cd /etc              ##该目录下存放着系统和软件的配置文件</code></pre><pre><code>⑦cat fstab            ##其中定义了各硬盘分区所挂在的目录路径</code></pre><p>Tab键可以进行命令补全，只有一个时补全内容，（需要按两次键）多个时列出（命令，目录，文件等都适用）</p><p>通配符 * ，？，_,[]。</p><p>⑧pwd                     ##显示当前所在的目录</p><p>⑨cd ..                   ##退到上一级目录</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>实训结束感悟</title>
      <link href="/2019/07/12/%E5%AE%9E%E8%AE%AD%E7%BB%93%E6%9D%9F%E6%84%9F%E6%82%9F/"/>
      <url>/2019/07/12/%E5%AE%9E%E8%AE%AD%E7%BB%93%E6%9D%9F%E6%84%9F%E6%82%9F/</url>
      
        <content type="html"><![CDATA[<h4 id="简单记一下这次的实训吧"><a href="#简单记一下这次的实训吧" class="headerlink" title="简单记一下这次的实训吧"></a>简单记一下这次的实训吧</h4><p>在报告厅观看完最后实训成果展示后，这次实训就正式结束了，维期21天。接下来又是苦逼的搬寝室，明天又要早起赶高铁，也不多说，只是记录一下重要的事情，贴上实训项目的地址：<br><a href="https://github.com/Gakki90/GarmentMall3.0" target="_blank" rel="noopener">https://github.com/Gakki90/GarmentMall3.0</a></p><p>补充一下：感谢一位组员因得奖而来的分红<br>  地点：学校宿舍                                                                                   </p><p>时间：2019-7-12 16：08 </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/07/07/hello-world/"/>
      <url>/2019/07/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
